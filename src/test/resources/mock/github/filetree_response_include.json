{
  "data": {
    "repository": {
      "object": {
        "entries": [
          {
            "name": "Blink1Device.hpp",
            "type": "blob",
            "object": {
              "text": "/**\n * @file Blink1Device.hpp\n * @brief Header file for blink1_lib::Blink1Device\n */\n\n#pragma once\n\n#include <blink1-lib.h>\n#include <functional>\n#include <memory>\n#include <optional>\n\n#include \"PatternLine.hpp\"\n#include \"PatternLineN.hpp\"\n#include \"PlayState.hpp\"\n#include \"RGB.hpp\"\n#include \"RGBN.hpp\"\n\nnamespace blink1_lib {\n\n    /**\n     * A wrapper around the blink1 C library used to control blink1 devices\n     */\n    class Blink1Device {\n        std::unique_ptr<blink1_device, std::function<void(blink1_device*)>> device;\n        bool blocking{false};\n\n        static void destroyBlinkDevice(blink1_device* device) noexcept;\n\n        public:\n            /**\n             * Defines how to interpret the string initializer passed into the constructors\n             * that take strings\n             */\n            enum class STRING_INIT_TYPE {\n                /** Interpret the initializer as a path to the device */\n                PATH,\n                /** Interpret the initializer as a serial ID */\n                SERIAL\n            };\n\n            /**\n             * Color to clear to if Blink1Device::clearOnExit is set to true. Defaults to black/off.\n             */\n            RGB clearColor{0, 0, 0};\n\n            /**\n             * Set to true to clear the LEDs when the destructor is called.\n             * The clear color can be changed with Blink1Device::clearColor.\n             */\n            bool clearOnExit{false};\n\n            /**\n             * Default constructor\n             */\n            Blink1Device() noexcept;\n\n            /**\n             * @param id The ID of the device to initialize\n             */\n            explicit Blink1Device(const std::uint32_t id) noexcept;\n\n            /**\n             * @param stringInitializer String to select the device to initialize\n             * @param initType How to interpret the the string\n             */\n            Blink1Device(const std::string& stringInitializer, const STRING_INIT_TYPE initType) noexcept;\n\n            /**\n             * @param stringInitializer String to select the device to initialize\n             * @param initType How to interpret the the string\n             */\n            Blink1Device(const char* stringInitializer, const STRING_INIT_TYPE initType) noexcept;\n\n            Blink1Device(const Blink1Device& other) = delete;\n            Blink1Device& operator=(const Blink1Device& other) = delete;\n\n            /**\n             * Destructor.\n             */\n            ~Blink1Device();\n\n            /**\n             * Returns whether or not the device is successfully connected\n             *\n             * @return true if the device is connected and ready, false otherwise\n             */\n            [[nodiscard]] bool good() const noexcept;\n\n            /**\n             * Returns the same thing as good()\n             *\n             * @return Whatever good() returns\n             * @see good()\n             */\n            [[nodiscard]] explicit operator bool() const noexcept;\n\n            /**\n             * Gets the version of the device that is connected. Returns std::nullopt if good() returns false\n             *\n             * @return The version of the device\n             */\n            [[nodiscard]] std::optional<int> getVersion() const noexcept;\n\n            /**\n             * Fades the device to another color over time. If this device has multiple LEDs,\n             * all LEDs will fade to that color.\n             *\n             * By default this function is non-blocking to allow for processing while the\n             * fade is occurring. This behavior can be changed with setBlocking(bool).\n             *\n             * @param fadeMillis The amount of time in milliseconds for the fade to last\n             * @param rgb RGB color to fade to\n             *\n             * @return true if the command was successfully sent to the device, false otherwise\n             *\n             * @see setBlocking(bool)\n             * @see setBlocking()\n             * @see setNonBlocking()\n             */\n            bool fadeToRGB(const std::uint16_t fadeMillis, const RGB& rgb) noexcept;\n\n            /**\n             * Fades the device to another color over time. Only fades the LED specified in\n             * the RGBN value.\n             *\n             * By default this function is non-blocking to allow for processing while the\n             * fade is occurring. This behavior can be changed with setBlocking(bool).\n             *\n             * @param fadeMillis The amount of time in milliseconds for the fade to last\n             * @param rgbn RGB color to fade to along with which LED on the device to fade to\n             *\n             * @return true if the command was successfully sent to the device, false otherwise\n             *\n             * @see setBlocking(bool)\n             * @see setBlocking()\n             * @see setNonBlocking()\n             */\n            bool fadeToRGBN(const std::uint16_t fadeMillis, const RGBN& rgbn) noexcept;\n\n            /**\n             * Sets the color of all LEDs on the device. The same as calling\n             * fadeToRGB(const std::uint16_t, const RGB&) with fadeMillis set to 0.\n             *\n             * @param rgb The color to set\n             *\n             * @return true if the command was successfully sent to the device, false otherwise\n             */\n            bool setRGB(const RGB& rgb) noexcept;\n\n            /**\n             * Sets the color of the specified on the device. The same as calling\n             * fadeToRGBN(const std::uint16_t, const RGBN&) with fadeMillis set to 0.\n             *\n             * @param rgbn The color to set along with which LED to set it on\n             *\n             * @return true if the command was successfully sent to the device, false otherwise\n             */\n            bool setRGBN(const RGBN& rgbn) noexcept;\n\n            /**\n             * Reads the RGB value of the given LED & the fade time\n             *\n             * @note The underlying function takes in fadeMillis as a parameter,\n             *       but it's not documented at all. This makes me think the function\n             *       might return the target RGB value rather than the current value,\n             *       but the docs say current, so I'm really not sure\n             *\n             * @param ledn The index of the LED to read\n             *\n             * @return A PatternLine (an RGB plus a fade time) if the value could be read successfully, std::nullopt otherwise\n             */\n            [[nodiscard]] std::optional<PatternLine> readRGBWithFade(const std::uint8_t ledn) const noexcept;\n\n            /**\n             * Reads the RGB value of the given LED\n             *\n             * @note The underlying function takes in fadeMillis as a parameter,\n             *       but it's not documented at all. This makes me think the function\n             *       might return the target RGB value rather than the current value,\n             *       but the docs say current, so I'm really not sure\n             *\n             * @param ledn The index of the LED to read\n             *\n             * @return The RGB value if it was read successfully, std::nullopt otherwise\n             */\n            [[nodiscard]] std::optional<RGB> readRGB(const std::uint8_t ledn) const noexcept;\n\n            /**\n             * Plays a programmed pattern on the device\n             *\n             * @param pos Position to start playing from\n             * @see writePatternLine(const PatternLine&, const std::uint8_t)\n             * @see writePatternLineN(const PatternLineN&, const std::uint8_t)\n             *\n             * @return true if the command was successfully sent to the device, false otherwise\n             */\n            bool play(const std::uint8_t pos) noexcept;\n\n            /**\n             * Plays a stored pattern on a loop\n             *\n             * @param startpos Start position for the loop\n             * @param endpos End position for the loop\n             * @param count Number of times to repeat (0 to repeat forever)\n             *\n             * @return true if the command was successfully sent to the device, false otherwise\n             */\n            bool playLoop(const std::uint8_t startpos, const std::uint8_t endpos, const std::uint8_t count) noexcept;\n\n            /**\n             * Stop playing the pattern that was playing\n             *\n             * @return true if the command was successfully sent to the device, false otherwise\n             */\n            bool stop() noexcept;\n\n            /**\n             * Reads the current PlayState of the device\n             *\n             * @return The PlayState if it could be read, std::nullopt otherwise\n             */\n            [[nodiscard]] std::optional<PlayState> readPlayState() const noexcept;\n\n            /**\n             * Writes a PatternLine to the device at the specified position\n             *\n             * @note On mk2 devices, this saves the pattern to volatile memory. Call savePattern()\n             *       to save the pattern in volatile memory into non-volatile memory\n             *\n             * @param line The line to write\n             * @param pos The position to write the line to - a number from 0 to max_patt (no documentation on what the value is)\n             * @see savePattern()\n             *\n             * @return true if the command was sent successfully to the device, false otherwise\n             */\n            bool writePatternLine(const PatternLine& line, const std::uint8_t pos) noexcept;\n\n            /**\n             * Writes a PatternLineN to the device at the specified position\n             *\n             * @note On mk2 devices, this saves the pattern to volatile memory. Call savePattern()\n             *       to save the pattern in volatile memory into non-volatile memory\n             *\n             * @param line The line to write\n             * @param pos The position to write the line to - a number from 0 to max_patt (no documentation on what the value is)\n             * @see savePattern()\n             *\n             * @return true if the command was sent successfully to the device, false otherwise\n             */\n            bool writePatternLineN(const PatternLineN& line, const std::uint8_t pos) noexcept;\n\n            /**\n             * Reads the pattern line stored at the given position\n             *\n             * @note The documentation doesn't say whether this reads from volatile or\n             *       non-volatile memory, but I'd assume is the volatile memory\n             *\n             * @param pos The position to read\n             *\n             * @return The PatternLine if it could be read successfully, std::nullopt otherwise\n             */\n            [[nodiscard]] std::optional<PatternLine> readPatternLine(const std::uint8_t pos) const noexcept;\n\n            /**\n             * Reads the pattern line stored at the given position\n             *\n             * @note The documentation doesn't say whether this reads from volatile or\n             *       non-volatile memory, but I'd assume is the volatile memory\n             *\n             * @param pos The position to read\n             *\n             * @return The PatternLineN if it could be read successfully, std::nullopt otherwise\n             */\n            [[nodiscard]] std::optional<PatternLineN> readPatternLineN(const std::uint8_t pos) const noexcept;\n\n            /**\n             * Saves the pattern in volatile memory into the non-volatile storage\n             *\n             * @note Based on the documentation, this probably will always return a failure due\n             *       to the function call timing out before it is actually able to save to the flash\n             *\n             * @return true if it was saved successfully, false otherwise\n             */\n            bool savePattern() noexcept;\n\n            /**\n             * Enables the blink1-lib gamma curve\n             *\n             * @note Docs say it should probably always be disabled\n             */\n            static void enableDegamma() noexcept;\n\n            /**\n             * Disable the blink1-lib gamma curve\n             *\n             * @note Docs say it should probably always be disabled\n             */\n            static void disableDegamma() noexcept;\n\n            /**\n             * Vendor ID for blink1 devices\n             */\n            [[nodiscard]] static int vid() noexcept;\n\n            /**\n             * Product ID for blink1 devices\n             */\n            [[nodiscard]] static int pid() noexcept;\n\n            /**\n             * Returns the cache index for this device\n             *\n             * @return The cache index if it was found, std::nullopt otherwise\n             */\n            [[nodiscard]] std::optional<int> getCacheIndex() const noexcept;\n\n            /**\n             * Clear blink1 device cache for this device\n             *\n             * @return The cache index that was cleared if anything was cleared, std::nullopt otherwise\n             */\n            std::optional<int> clearCache() noexcept;\n\n            /**\n             * Gets serial ID for this device\n             *\n             * @return 8-hexdigit serial number string if device is good, std::nullopt otherwise\n             */\n            [[nodiscard]] std::optional<std::string_view> getSerial() const noexcept;\n\n            /**\n             * Returns whether the device is a MK2 device\n             *\n             * @return Whether the device is a MK2 device if the device is good, std::nullopt otherwise\n             */\n            [[nodiscard]] std::optional<bool> isMk2() const noexcept;\n\n            /**\n             * Sets the blocking mode for this device (technically just for this library for this\n             * device, as the underlying C library does not have a blocking mode).\n             *\n             * When in blocking mode, fade commands will not return until the fade time is up. If\n             * blocking mode is disabled, the fade commands will return immediately. By default,\n             * all functions are non-blocking.\n             *\n             * @param blocking Whether or not to be in blocking mode\n             *\n             * @see fadeToRGB()\n             * @see fadeToRGBN()\n             */\n            void setBlocking(bool blocking) noexcept;\n\n            /**\n             * Sets the device to be in blocking mode.\n             *\n             * @see setBlocking(bool)\n             */\n            void setBlocking() noexcept;\n\n            /**\n             * Sets the device to be in non-blocking mode.\n             *\n             * @see setBlocking(bool)\n             */\n            void setNonBlocking() noexcept;\n\n            /**\n             * Returns whether the device is in blocking mode.\n             *\n             * @return Whether blocking mode is set.\n             *\n             * @see setBlocking(bool)\n             */\n            [[nodiscard]] bool isBlocking() const noexcept;\n    };\n}\n",
              "isBinary": false
            },
            "path": "include/Blink1Device.hpp"
          },
          {
            "name": "Blink1TestingLibrary.hpp",
            "type": "blob",
            "object": {
              "text": "/**\n * @file Blink1TestingLibrary.hpp\n * @brief Provides functions to control a simulated blink(1) device for testing\n */\n\n#pragma once\n\n#include <exception>\n#include <string>\n#include <vector>\n#include <map>\n\n#include \"RGB.hpp\"\n#include \"PlayState.hpp\"\n#include \"PatternLineN.hpp\"\n\n#include \"blink1-lib.h\"\n\n/// @cond\ntypedef struct hid_device_ {} hid_device_;\n/// @endcond\n\n/**\n * @brief Testing library namespace.\n *\n * This library simulates blink(1) devices for use in testing. It keeps track of\n * each device opened by the application, but for simplicity each one maps to the\n * same simulated device. For example, setting LED 1 to red on device 1 and then\n * reading the color of LED 1 on device 2 will return red, despite device 2 not\n * having the color set.\n *\n * Additional functions provided in this namespace allow for controlling the\n * simulated device in ways that are not normally possible.\n */\nnamespace fake_blink1_lib {\n    /// @cond\n    extern std::vector<blink1_device*> blink1_devices;\n    extern std::map<long, blink1_lib::RGB> ledColors;\n    extern std::map<long, uint16_t> ledFadeMillis;\n    extern std::map<long, blink1_lib::PatternLineN> patternLines;\n    extern int cacheIndex;\n    extern std::string serial;\n    extern bool isMk2;\n    extern uint8_t patternLineLEDN;\n    extern blink1_lib::PlayState playState;\n    extern int blink1Version;\n    extern bool successfulOperation;\n    extern bool successfulInit;\n    extern bool degammaEnabled;\n    extern int vid;\n    extern int pid;\n    /// @endcond\n\n    /**\n     * Resets all features of the simulated blink(1) device to their default values.\n     * LEDs are cleared and all devices are removed. This function should be in the\n     * teardown for your test cases.\n     */\n    void CLEAR_ALL();\n\n    /**\n     * Indicates whether there are any blink(1) devices still connected to the application.\n     * Whenever a blink1_lib::Blink1Device goes out of scope, the corresponding device\n     * should be disconnected, so this can be used to determine whether any devices are still\n     * in scope.\n     *\n     * @return `true` if all blink(1) devices have been properly closed and freed, `false` otherwise\n     */\n    bool ALL_DEVICES_FREED();\n\n    /**\n     * Sets the value that will be read by blink1_lib::Blink1Device::getVersion(). The default value is `0`.\n     */\n    void SET_BLINK1_VERSION(int version);\n\n    /**\n     * Sets whether operations that can fail should succeed or not. By default, all operations will fail -\n     * functions returning optionals will have empty results, functions that return bools will return\n     * `false`, etc.\n     */\n    void SET_BLINK1_SUCCESSFUL_OPERATION(bool op);\n\n    /**\n     * Sets whether attempting to open a new blink(1) device should succeed or not.\n     * The default value is `false`.\n     */\n    void SET_BLINK1_SUCCESSFUL_INIT(bool init);\n\n    /**\n     * Sets the value that will be read by blink1_lib::Blink1Device::vid().\n     * The default value is `0`.\n     */\n    void SET_BLINK1_VID(int _vid);\n\n    /**\n     * Sets the value that will be read by blink1_lib::Blink1Device::pid().\n     * The default value is `0`.\n     */\n    void SET_BLINK1_PID(int _pid);\n\n    /**\n     * Sets the value that will be read by blink1_lib::Blink1Device::getCacheIndex().\n     * The default value is `0`.\n     */\n    void SET_CACHE_INDEX(int index);\n\n    /**\n     * Sets the value that will be read by blink1_lib::Blink1Device::getSerial().\n     * The default value is `\"\"`.\n     */\n    void SET_SERIAL(std::string serial);\n\n    /**\n     * Sets the value that will be read by blink1_lib::Blink1Device::isMk2().\n     * The default value is `false`.\n     */\n    void SET_IS_MK2(bool mk2);\n\n    /**\n     * For internal use.\n     */\n    bool SUCCESS(blink1_device* dev);\n\n    /**\n     * Returns the color of simulated LED `n`.\n     */\n    blink1_lib::RGB GET_RGB(long n);\n\n    /**\n     * Sets the color of simulated LED `n` to `rgb`.\n     */\n    void SET_RGB(blink1_lib::RGB rgb, long n);\n\n    /**\n     * Gets the `fadeMillis` value that was used in the last call to either\n     * blink1_lib::Blink1Device::fadeToRGB or blink1_lib::Blink1Device::fadeToRGBN\n     * for the LED at index `n`.\n     */\n    uint16_t GET_FADE_MILLIS(long n);\n\n    /**\n     * Sets the most recent `fadeMillis` value for LED `n`.\n     */\n    void SET_FADE_MILLIS(uint16_t fadeMillis, long n);\n\n    /**\n     * Reads the pattern line set by blink1_lib::Blink1Device::writePatternLineN at position `pos`.\n     */\n    blink1_lib::PatternLineN GET_PATTERN_LINE(long pos);\n\n    /**\n     * Sets the pattern line at position `pos` to `line`.\n     */\n    void SET_PATTERN_LINE(blink1_lib::PatternLineN line, long pos);\n\n    /**\n     * Gets the value of the play state, bypassing the need to have a device and read from it.\n     */\n    blink1_lib::PlayState GET_PLAY_STATE();\n\n    /**\n     * Sets the value that will be read by blink1_lib::Blink1Device::readPlayState().\n     */\n    void SET_PLAY_STATE(blink1_lib::PlayState state);\n}\n",
              "isBinary": false
            },
            "path": "include/Blink1TestingLibrary.hpp"
          },
          {
            "name": "Documentation.hpp",
            "type": "blob",
            "object": {
              "text": "/**\n * @file Documentation.hpp\n * @brief This file is just a place to put documentation for the front\n *        page of the doxygen docs\n */\n\n// Shouldn't ever get included but hey might as well\n#pragma once\n\n/**\n * @mainpage Blink1 Lib\n *\n * This library provides a C++ wrapper around the blink1-lib C library\n *\n * Main class: blink1_lib::Blink1Device\n *\n * Also of note is the testing library: fake_blink1_lib\n */\n\n/**\n * Namespace for the project\n */\nnamespace blink1_lib {\n\n}\n",
              "isBinary": false
            },
            "path": "include/Documentation.hpp"
          },
          {
            "name": "PatternLine.hpp",
            "type": "blob",
            "object": {
              "text": "/**\n * @file PatternLine.hpp\n * @brief Header file for blink1_lib::PatternLine\n */\n\n#pragma once\n\n#include <cstdint>\n\n#include \"RGB.hpp\"\n\nnamespace blink1_lib {\n\n    /**\n     * Originally a line in a blink1 pattern, but mostly just a way to keep an RGB\n     * value and a fade time together in one object\n     */\n    struct PatternLine {\n        /**\n         * Fade time in milliseconds\n         */\n        std::uint16_t fadeMillis{0};\n\n        /**\n         * RGB value\n         */\n        RGB rgb;\n\n        /**\n         * Default constructor\n         *\n         * Initializes all values to 0\n         */\n        PatternLine() noexcept = default;\n\n        /**\n         * @param _rgb RGB value for this PatternLine\n         * @param _fadeMillis Fade time in milliseconds\n         */\n        PatternLine(const RGB& _rgb, const std::uint16_t _fadeMillis) noexcept;\n\n        /**\n         * @param _r Red value for RGB\n         * @param _g Green value for RGB\n         * @param _b Blue value for RGB\n         * @param _fadeMillis Fade time in milliseconds\n         */\n        PatternLine(const std::uint8_t _r, const std::uint8_t _g, const std::uint8_t _b, const std::uint16_t _fadeMillis) noexcept;\n\n        /**\n         * Equality operator\n         *\n         * @param other Object to compare to\n         * @return true if the objects are equal, false otherwise\n         */\n        [[nodiscard]] bool operator==(const PatternLine& other) const noexcept;\n\n        /**\n         * Inequality operator\n         *\n         * @param other Object to compare to\n         * @return true if the objects are not equal, false otherwise\n         */\n        [[nodiscard]] bool operator!=(const PatternLine& other) const noexcept;\n\n        /**\n         * Output operator\n         *\n         * @param os Output stream\n         * @param patternLine PatternLine to output\n         */\n        friend std::ostream& operator<<(std::ostream& os, const PatternLine& patternLine);\n    };\n}\n",
              "isBinary": false
            },
            "path": "include/PatternLine.hpp"
          },
          {
            "name": "PatternLineN.hpp",
            "type": "blob",
            "object": {
              "text": "/**\n * @file PatternLineN.hpp\n * @brief Header file for blink1_lib::PatternLineN\n */\n\n#pragma once\n\n#include <cstdint>\n\n#include \"RGBN.hpp\"\n\nnamespace blink1_lib {\n\n    /**\n     * Same as a PatternLine, but uses RGBN to also store an LED ID\n     */\n    struct PatternLineN {\n        /**\n         * Fade time in milliseconds\n         */\n        std::uint16_t fadeMillis{0};\n\n        /**\n         * RGBN value\n         */\n        RGBN rgbn;\n\n        /**\n         * Default constructor\n         *\n         * Initializes all values to 0\n         */\n        PatternLineN() noexcept = default;\n\n        /**\n         * @param _rgbn RGBN value\n         * @param _fadeMillis Fade time in milliseconds\n         */\n        PatternLineN(const RGBN& _rgbn, const std::uint16_t _fadeMillis) noexcept;\n\n        /**\n         * @param _r Red value\n         * @param _g Green value\n         * @param _b Blue value\n         * @param _n LED index\n         * @param _fadeMillis Fade time in milliseconds\n         */\n        PatternLineN(const std::uint8_t _r, const std::uint8_t _g, const std::uint8_t _b, const std::uint8_t _n, const std::uint16_t _fadeMillis) noexcept;\n\n        /**\n         * Equality operator\n         *\n         * @param other Object to compare to\n         * @return true if the objects are equal, false otherwise\n         */\n        [[nodiscard]] bool operator==(const PatternLineN& other) const noexcept;\n\n        /**\n         * Inequality operator\n         *\n         * @param other Object to compare to\n         * @return true if the objects are not equal, false otherwise\n         */\n        [[nodiscard]] bool operator!=(const PatternLineN& other) const noexcept;\n\n        /**\n         * Output operator\n         *\n         * @param os Output stream\n         * @param patternLine PatternLineN to output\n         */\n        friend std::ostream& operator<<(std::ostream& os, const PatternLineN& patternLine);\n    };\n}\n",
              "isBinary": false
            },
            "path": "include/PatternLineN.hpp"
          },
          {
            "name": "PlayState.hpp",
            "type": "blob",
            "object": {
              "text": "/**\n * @file PlayState.hpp\n * @brief Header for blink1_lib::PlayState\n */\n\n#pragma once\n\n#include <cstdint>\n#include <ostream>\n\nnamespace blink1_lib {\n\n    /**\n     * The state of the blink1 devive playing patterns\n     */\n    struct PlayState {\n        /**\n         * Whether a pattern is currently playing\n         */\n        bool playing{false};\n\n        /**\n         * The index in the pattern where the play/loop started\n         */\n        std::uint8_t playStart{0};\n\n        /**\n         * The index in the pattern where the play/loop will end\n         */\n        std::uint8_t playEnd{0};\n\n        /**\n         * Number of repetitions left in a loop\n         */\n        std::uint8_t playCount{0};\n\n        /**\n         * The current index in the pattern\n         */\n        std::uint8_t playPos{0};\n\n        /**\n         * Default constructor\n         *\n         * Initializes all values to 0\n         */\n        PlayState() noexcept = default;\n\n        /**\n         * @param _playing Whether a pattern is currently playing\n         * @param _playStart The index in the pattern where the play/loop started\n         * @param _playEnd The index in the pattern where the play/loop will end\n         * @param _playCount The number of repetitions left in the loop\n         * @param _playPos The current index in the pattern\n         */\n        PlayState(const bool _playing, const std::uint8_t _playStart, const std::uint8_t _playEnd, const std::uint8_t _playCount, const std::uint8_t _playPos) noexcept;\n\n        /**\n         * Equality operator\n         *\n         * @param other Object to compare to\n         * @return true if the objects are equal, false otherwise\n         */\n        [[nodiscard]] bool operator==(const PlayState& other) const noexcept;\n\n        /**\n         * Inequality operator\n         *\n         * @param other Object to compare to\n         * @return true if the objects are not equal, false otherwise\n         */\n        [[nodiscard]] bool operator!=(const PlayState& other) const noexcept;\n\n        /**\n         * Output operator\n         *\n         * @param os Output stream\n         * @param playState PlayState to output\n         */\n        friend std::ostream& operator<<(std::ostream& os, const PlayState& playState);\n    };\n}\n",
              "isBinary": false
            },
            "path": "include/PlayState.hpp"
          },
          {
            "name": "RGB.hpp",
            "type": "blob",
            "object": {
              "text": "/**\n * @file RGB.hpp\n * @brief Header file for blink1_lib::RGB\n */\n\n#pragma once\n\n#include <cstdint>\n#include <ostream>\n\nnamespace blink1_lib {\n\n    /**\n     * Represents a color\n     */\n    struct RGB {\n\n        /**\n         * Red component\n         */\n        std::uint8_t r{0};\n\n        /**\n         * Green component\n         */\n        std::uint8_t g{0};\n\n        /**\n         * Blue component\n         */\n        std::uint8_t b{0};\n\n        /**\n         * @param r Red value\n         * @param g Green value\n         * @param b Blue value\n         */\n        RGB(const std::uint8_t r, const std::uint8_t g, const std::uint8_t b) noexcept;\n\n        /**\n         * Default constructor\n         *\n         * Intializes all values to 0\n         */\n        RGB() noexcept = default;\n\n        /**\n         * Equality operator\n         *\n         * @param other Object to compare to\n         * @return true if the objects are equal, false otherwise\n         */\n        [[nodiscard]] bool operator==(const RGB& other) const noexcept;\n\n        /**\n         * Inequality operator\n         *\n         * @param other Object to compare to\n         * @return true if the objects are not equal, false otherwise\n         */\n        [[nodiscard]] bool operator!=(const RGB& other) const noexcept;\n\n        /**\n         * Output operator\n         *\n         * @param os Output stream\n         * @param rgb RGB object to output\n         */\n        friend std::ostream& operator<<(std::ostream& os, const RGB& rgb);\n    };\n}\n",
              "isBinary": false
            },
            "path": "include/RGB.hpp"
          },
          {
            "name": "RGBN.hpp",
            "type": "blob",
            "object": {
              "text": "/**\n * @file RGBN.hpp\n * @brief Header file for blink1_lib::RGBN\n */\n\n#pragma once\n\n#include <cstdint>\n#include <ostream>\n\nnamespace blink1_lib {\n\n    /**\n     * A datatype that combines an RGB value with an LED index\n     */\n    struct RGBN {\n        /**\n         * Red value\n         */\n        std::uint8_t r{0};\n\n        /**\n         * Green value\n         */\n        std::uint8_t g{0};\n\n        /**\n         * Blue value\n         */\n        std::uint8_t b{0};\n\n        /**\n         * LED index\n         */\n        std::uint8_t n{0};\n\n        /**\n         * @param r Red value\n         * @param g Green value\n         * @param b Blue value\n         * @param n LED index\n         */\n        RGBN(const std::uint8_t r, const std::uint8_t g, const std::uint8_t b, const std::uint8_t n) noexcept;\n\n        /**\n         * Default constructor\n         *\n         * Initializes all values to 0\n         */\n        RGBN() noexcept = default;\n\n        /**\n         * Equality operator\n         *\n         * @param other Object to compare to\n         * @return true if the objects are equal, false otherwise\n         */\n        [[nodiscard]] bool operator==(const RGBN& other) const noexcept;\n\n        /**\n         * Inequality operator\n         *\n         * @param other Object to compare to\n         * @return true if the objects are not equal, false otherwise\n         */\n        [[nodiscard]] bool operator!=(const RGBN& other) const noexcept;\n\n        /**\n         * Output operator\n         *\n         * @param os Output stream\n         * @param rgb RGBN object to output\n         */\n        friend std::ostream& operator<<(std::ostream& os, const RGBN& rgb);\n    };\n}\n",
              "isBinary": false
            },
            "path": "include/RGBN.hpp"
          },
          {
            "name": "blink-lib.hpp",
            "type": "blob",
            "object": {
              "text": "/**\n * @file blink-lib.hpp\n * @brief Header file for blink1-lib\n *\n * Including this file will give access to all classes within blink1-lib\n */\n#pragma once\n\n#include \"Blink1Device.hpp\"\n#include \"PatternLine.hpp\"\n#include \"PatternLineN.hpp\"\n#include \"RGB.hpp\"\n#include \"RGBN.hpp\"\n\n",
              "isBinary": false
            },
            "path": "include/blink-lib.hpp"
          }
        ]
      }
    }
  }
}