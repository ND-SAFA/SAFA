{
  "data": {
    "repository": {
      "object": {
        "entries": [
          {
            "name": "Blink1Device.cpp",
            "type": "blob",
            "object": {
              "text": "#include \"Blink1Device.hpp\"\n\n#include <thread>\n\nnamespace blink1_lib {\n    Blink1Device::Blink1Device() noexcept : device(blink1_open(), Blink1Device::destroyBlinkDevice) {}\n\n    Blink1Device::Blink1Device(const std::uint32_t id) noexcept : device(blink1_openById(id), Blink1Device::destroyBlinkDevice) {}\n\n    Blink1Device::Blink1Device(const std::string& stringInitializer, STRING_INIT_TYPE initType) noexcept : Blink1Device(stringInitializer.c_str(), initType) {}\n\n    Blink1Device::Blink1Device(const char* stringInitializer, STRING_INIT_TYPE initType) noexcept {\n        switch (initType) {\n            case STRING_INIT_TYPE::PATH:\n                device = std::unique_ptr<blink1_device, std::function<void(blink1_device*)>>(blink1_openByPath(stringInitializer), Blink1Device::destroyBlinkDevice);\n                break;\n            case STRING_INIT_TYPE::SERIAL:\n                device = std::unique_ptr<blink1_device, std::function<void(blink1_device*)>>(blink1_openBySerial(stringInitializer), Blink1Device::destroyBlinkDevice);\n                break;\n            default:\n                device = nullptr;\n                break;\n        }\n    }\n\n    Blink1Device::~Blink1Device() {\n        if (clearOnExit) {\n            setRGB(clearColor);\n        }\n    }\n\n    void Blink1Device::destroyBlinkDevice(blink1_device* device) noexcept {\n        blink1_close(device);\n    }\n\n    bool Blink1Device::good() const noexcept {\n        return device != nullptr;\n    }\n\n    Blink1Device::operator bool() const noexcept {\n        return good();\n    }\n\n    std::optional<int> Blink1Device::getVersion() const noexcept {\n        if (good()) {\n            return blink1_getVersion(device.get());\n        }\n        return std::nullopt;\n    }\n\n    bool Blink1Device::fadeToRGB(const std::uint16_t fadeMillis, const RGB& rgb) noexcept {\n        if (good()) {\n            auto retVal = blink1_fadeToRGB(device.get(), fadeMillis, rgb.r, rgb.g, rgb.b);\n            if (blocking && 0 <= retVal) {\n                std::this_thread::sleep_for(std::chrono::milliseconds(fadeMillis));\n            }\n            return 0 <= retVal;\n        }\n        return false;\n    }\n\n    bool Blink1Device::fadeToRGBN(const std::uint16_t fadeMillis, const RGBN& rgbn) noexcept {\n        if (good()) {\n            auto retVal = blink1_fadeToRGBN(device.get(), fadeMillis, rgbn.r, rgbn.g, rgbn.b, rgbn.n);\n            if (blocking && 0 <= retVal) {\n                std::this_thread::sleep_for(std::chrono::milliseconds(fadeMillis));\n            }\n            return 0 <= retVal;\n        }\n        return false;\n    }\n\n    bool Blink1Device::setRGB(const RGB& rgb) noexcept {\n        if (good()) {\n            return 0 <= blink1_setRGB(device.get(), rgb.r, rgb.g, rgb.b);\n        }\n        return false;\n    }\n\n    bool Blink1Device::setRGBN(const RGBN& rgbn) noexcept {\n        return fadeToRGBN(0, rgbn);\n    }\n\n    std::optional<PatternLine> Blink1Device::readRGBWithFade(const std::uint8_t ledn) const noexcept {\n        if (good()) {\n            PatternLine line;\n            const auto retVal = blink1_readRGB(device.get(), &line.fadeMillis, &line.rgb.r, &line.rgb.g, &line.rgb.b, ledn);\n            if (retVal >= 0) {\n                return line;\n            }\n        }\n        return std::nullopt;\n    }\n\n    std::optional<RGB> Blink1Device::readRGB(const std::uint8_t ledn) const noexcept {\n        const auto pLine = readRGBWithFade(ledn);\n        if (pLine) {\n            return pLine->rgb;\n        }\n        return std::nullopt;\n    }\n\n    bool Blink1Device::play(const std::uint8_t pos) noexcept {\n        if (good()) {\n            return 0 <= blink1_play(device.get(), 1, pos);\n        }\n        return false;\n    }\n\n    bool Blink1Device::playLoop(std::uint8_t startpos, std::uint8_t endpos, std::uint8_t count) noexcept {\n        if (good()) {\n            return 0 <= blink1_playloop(device.get(), 1, startpos, endpos, count);\n        }\n        return false;\n    }\n\n    bool Blink1Device::stop() noexcept {\n        if (good()) {\n            return 0 <= blink1_play(device.get(), 0, 0);\n        }\n        return false;\n    }\n\n    std::optional<PlayState> Blink1Device::readPlayState() const noexcept {\n        if (good()) {\n            PlayState state;\n            std::uint8_t playing = 0;\n            const auto retVal = blink1_readPlayState(device.get(), &playing, &state.playStart, &state.playEnd, &state.playCount, &state.playPos);\n            state.playing = (playing == 1);\n            if (retVal >= 0) {\n                return state;\n            }\n        }\n        return std::nullopt;\n    }\n\n    bool Blink1Device::writePatternLine(const PatternLine& line, const std::uint8_t pos) noexcept {\n        if (good()) {\n            return 0 <= blink1_writePatternLine(device.get(), line.fadeMillis, line.rgb.r, line.rgb.g, line.rgb.b, pos);\n        }\n        return false;\n    }\n\n    bool Blink1Device::writePatternLineN(const PatternLineN& line, const std::uint8_t pos) noexcept {\n        if (good()) {\n            const auto retVal1 = blink1_setLEDN(device.get(), line.rgbn.n);\n            const auto retVal2 = blink1_writePatternLine(device.get(), line.fadeMillis, line.rgbn.r, line.rgbn.g, line.rgbn.b, pos);\n            return retVal1 >= 0 && retVal2 >= 0;\n        }\n        return false;\n    }\n\n    std::optional<PatternLine> Blink1Device::readPatternLine(const std::uint8_t pos) const noexcept {\n        if (good()) {\n            PatternLine line;\n            int retVal = blink1_readPatternLine(device.get(), &line.fadeMillis, &line.rgb.r, &line.rgb.g, &line.rgb.b, pos);\n            if (retVal >= 0) {\n                return line;\n            }\n        }\n        return std::nullopt;\n    }\n\n    std::optional<PatternLineN> Blink1Device::readPatternLineN(const std::uint8_t pos) const noexcept {\n        if (good()) {\n            PatternLineN line;\n            int retVal = blink1_readPatternLineN(device.get(), &line.fadeMillis, &line.rgbn.r, &line.rgbn.g, &line.rgbn.b, &line.rgbn.n, pos);\n            if (retVal >= 0) {\n                return line;\n            }\n        }\n        return std::nullopt;\n    }\n\n    bool Blink1Device::savePattern() noexcept {\n        if (good()) {\n            return 0 <= blink1_savePattern(device.get());\n        }\n        return false;\n    }\n\n    void Blink1Device::enableDegamma() noexcept {\n        blink1_enableDegamma();\n    }\n\n    void Blink1Device::disableDegamma() noexcept {\n        blink1_disableDegamma();\n    }\n\n    int Blink1Device::vid() noexcept {\n        return blink1_vid();\n    }\n\n    int Blink1Device::pid() noexcept {\n        return blink1_pid();\n    }\n\n    std::optional<int> Blink1Device::getCacheIndex() const noexcept {\n        if (good()) {\n            int cacheIndex = blink1_getCacheIndexByDev(device.get());\n            if (cacheIndex != -1) {\n                return cacheIndex;\n            }\n        }\n        return std::nullopt;\n    }\n\n    std::optional<int> Blink1Device::clearCache() noexcept {\n        if (good()) {\n            int cacheIndex = blink1_clearCacheDev(device.get());\n            if (cacheIndex != -1) {\n                return cacheIndex;\n            }\n        }\n        return std::nullopt;\n    }\n\n    std::optional<std::string_view> Blink1Device::getSerial() const noexcept {\n        if (good()) {\n            const char* serial = blink1_getSerialForDev(device.get());\n            if (serial != nullptr) {\n                return serial;\n            }\n        }\n        return std::nullopt;\n    }\n\n    std::optional<bool> Blink1Device::isMk2() const noexcept {\n        if (good()) {\n            return 1 == blink1_isMk2(device.get());\n        }\n        return std::nullopt;\n    }\n\n    void Blink1Device::setBlocking(bool _blocking) noexcept {\n        blocking = _blocking;\n    }\n\n    void Blink1Device::setBlocking() noexcept {\n        setBlocking(true);\n    }\n\n    void Blink1Device::setNonBlocking() noexcept {\n        setBlocking(false);\n    }\n\n    bool Blink1Device::isBlocking() const noexcept {\n        return blocking;\n    }\n}\n",
              "isBinary": false
            },
            "path": "src/Blink1Device.cpp"
          },
          {
            "name": "Blink1TestingLibrary.cpp",
            "type": "blob",
            "object": {
              "text": "#include <vector>\n#include <algorithm>\n#include <map>\n\n#if __has_include(\"gtest/gtest.h\")\n    #include \"gtest/gtest.h\"\n#else\n    #include <iostream>\n    #include <sstream>\n    std::ostream& ADD_FAILURE() {\n        return std::cerr;\n    }\n    std::stringstream dumpStream;\n    std::ostream& EXPECT_TRUE(bool val) {\n        if (val) {\n            dumpStream.str(\"\");\n            return dumpStream;\n        } else {\n            return std::cerr;\n        }\n    }\n#endif\n\n#include \"blink1-lib.h\"\n\n#include \"RGB.hpp\"\n#include \"PlayState.hpp\"\n#include \"PatternLineN.hpp\"\n#include \"Blink1TestingLibrary.hpp\"\n\nusing namespace blink1_lib;\n\nstd::vector<blink1_device*> fake_blink1_lib::blink1_devices;\nstd::map<long, RGB> fake_blink1_lib::ledColors;\nstd::map<long, uint16_t> fake_blink1_lib::ledFadeMillis;\nstd::map<long, PatternLineN> fake_blink1_lib::patternLines;\nint fake_blink1_lib::cacheIndex = 0;\nstd::string fake_blink1_lib::serial;\nbool fake_blink1_lib::isMk2;\nuint8_t fake_blink1_lib::patternLineLEDN = 0;\nPlayState fake_blink1_lib::playState;\nint fake_blink1_lib::blink1Version = 0;\nbool fake_blink1_lib::successfulOperation = false;\nbool fake_blink1_lib::successfulInit = false;\nbool fake_blink1_lib::degammaEnabled = false;\nint fake_blink1_lib::vid = 0;\nint fake_blink1_lib::pid = 0;\n/*********************\n * METHODS FOR TESTS *\n *********************/\n\nvoid fake_blink1_lib::CLEAR_ALL() {\n    for (auto it = blink1_devices.begin(); it != blink1_devices.end(); ++it) {\n        blink1_device* device = *it;\n        it = blink1_devices.erase(it);\n        delete device;\n    }\n\n    ledColors.clear();\n    ledFadeMillis.clear();\n    patternLines.clear();\n\n    cacheIndex = 0;\n    serial = \"\";\n    isMk2 = false;\n    patternLineLEDN = 0;\n    playState = PlayState();\n    blink1Version = 0;\n    successfulOperation = false;\n    successfulInit = false;\n    degammaEnabled = false;\n    vid = 0;\n    pid = 0;\n}\n\nbool fake_blink1_lib::ALL_DEVICES_FREED() {\n    return blink1_devices.size() == 0;\n}\n\nvoid fake_blink1_lib::SET_BLINK1_VERSION(int version) {\n    blink1Version = version;\n}\n\nvoid fake_blink1_lib::SET_BLINK1_SUCCESSFUL_OPERATION(bool op) {\n    successfulOperation = op;\n}\n\nvoid fake_blink1_lib::SET_BLINK1_SUCCESSFUL_INIT(bool init) {\n    successfulInit = init;\n}\n\nvoid fake_blink1_lib::SET_BLINK1_VID(int _vid) {\n    vid = _vid;\n}\n\nvoid fake_blink1_lib::SET_BLINK1_PID(int _pid) {\n    pid = _pid;\n}\n\nvoid fake_blink1_lib::SET_CACHE_INDEX(int index) {\n    cacheIndex = index;\n}\n\nvoid fake_blink1_lib::SET_SERIAL(std::string _serial) {\n    serial = _serial;\n}\n\nvoid fake_blink1_lib::SET_IS_MK2(bool mk2) {\n    isMk2 = mk2;\n}\n\nbool fake_blink1_lib::SUCCESS(blink1_device* dev) {\n    return successfulOperation && dev != nullptr;\n}\n\nRGB fake_blink1_lib::GET_RGB(long n) {\n    if (ledColors.find(n) == ledColors.end()) {\n        ADD_FAILURE() << \"LED color \" << n << \" has not yet been initialized.\";\n        return RGB();\n    }\n    return ledColors.at(n);\n}\n\nvoid fake_blink1_lib::SET_RGB(RGB rgb, long n) {\n    ledColors[n] = rgb;\n}\n\nuint16_t fake_blink1_lib::GET_FADE_MILLIS(long n) {\n    if (ledFadeMillis.find(n) == ledFadeMillis.end()) {\n        ADD_FAILURE() << \"LED fade millis \" << n << \" has not yet been initialized.\";\n        return 0;\n    }\n    return ledFadeMillis.at(n);\n}\n\nvoid fake_blink1_lib::SET_FADE_MILLIS(uint16_t fadeMillis, long n) {\n    ledFadeMillis[n] = fadeMillis;\n}\n\nPatternLineN fake_blink1_lib::GET_PATTERN_LINE(long pos) {\n    if (patternLines.find(pos) == patternLines.end()) {\n        EXPECT_TRUE(false) << \"Pattern Line \" << pos << \" has not yet been initialized.\";\n        return PatternLineN();\n    }\n    return patternLines.at(pos);\n}\n\nvoid fake_blink1_lib::SET_PATTERN_LINE(PatternLineN line, long pos) {\n    patternLines[pos] = line;\n}\n\nPlayState fake_blink1_lib::GET_PLAY_STATE() {\n    return playState;\n}\n\nvoid fake_blink1_lib::SET_PLAY_STATE(PlayState state) {\n    playState = state;\n}\n\n/******************\n * MOCKED METHODS *\n ******************/\n\nblink1_device* blink1_open() {\n    if (fake_blink1_lib::successfulInit) {\n        blink1_device* newDevice = new blink1_device();\n        fake_blink1_lib::blink1_devices.push_back(newDevice);\n        return newDevice;\n    } else {\n        return nullptr;\n    }\n}\n\nblink1_device* blink1_openByPath([[maybe_unused]] const char* path) {\n    return blink1_open();\n}\n\nblink1_device* blink1_openBySerial([[maybe_unused]] const char* serial) {\n    return blink1_open();\n}\n\nblink1_device* blink1_openById([[maybe_unused]] uint32_t id) {\n    return blink1_open();\n}\n\nvoid blink1_close_internal(blink1_device* dev) {\n    auto loc = std::find(fake_blink1_lib::blink1_devices.begin(), fake_blink1_lib::blink1_devices.end(), dev);\n    if (loc != fake_blink1_lib::blink1_devices.end()) {\n        fake_blink1_lib::blink1_devices.erase(loc);\n    } else {\n        ADD_FAILURE() << \"Tried to delete device that was never allocated: \" << dev;\n    }\n\n    delete dev;\n}\n\nint blink1_getVersion(blink1_device* dev) {\n    auto loc = std::find(fake_blink1_lib::blink1_devices.begin(), fake_blink1_lib::blink1_devices.end(), dev);\n    if (loc != fake_blink1_lib::blink1_devices.end()) {\n        return fake_blink1_lib::blink1Version;\n    } else {\n        //TODO docs don't specify failure case, just that device must be initialized\n        ADD_FAILURE() << \"Getting version from uninitialized device.\";\n        return -1;\n    }\n}\n\n// This does LED 0 which actually sets all LEDs\n// Does LED 0 first to make sure that it gets created in the map\nint blink1_fadeToRGB(blink1_device* dev, uint16_t fadeMillis, uint8_t r, uint8_t g, uint8_t b) {\n    if (fake_blink1_lib::SUCCESS(dev)) {\n        fake_blink1_lib::ledFadeMillis[0] = fadeMillis;\n        fake_blink1_lib::ledColors[0] = RGB(r, g, b);\n\n        for (auto i = fake_blink1_lib::ledFadeMillis.begin(); i != fake_blink1_lib::ledFadeMillis.end(); ++i) {\n            i->second = fadeMillis;\n        }\n        for (auto i = fake_blink1_lib::ledColors.begin(); i != fake_blink1_lib::ledColors.end(); ++i) {\n            i->second = RGB(r, g, b);\n        }\n        return 0;\n    } else {\n        return -1;\n    }\n}\n\nint blink1_fadeToRGBN(blink1_device* dev, uint16_t fadeMillis, uint8_t r, uint8_t g, uint8_t b, uint8_t n) {\n    if (fake_blink1_lib::SUCCESS(dev)) {\n        fake_blink1_lib::ledFadeMillis[n] = fadeMillis;\n        fake_blink1_lib::ledColors[n] = RGB(r, g, b);\n        return 0;\n    } else {\n        return -1;\n    }\n}\n\nint blink1_setRGB(blink1_device* dev, uint8_t r, uint8_t g, uint8_t b) {\n    if (fake_blink1_lib::SUCCESS(dev)) {\n        fake_blink1_lib::ledColors[0] = RGB(r, g, b);\n        for (auto i = fake_blink1_lib::ledColors.begin(); i != fake_blink1_lib::ledColors.end(); ++i) {\n            i->second = RGB(r, g, b);\n        }\n        return 0;\n    } else {\n        return -1;\n    }\n}\n\nint blink1_readRGB(blink1_device* dev, uint16_t* fadeMillis, uint8_t* r, uint8_t* g, uint8_t* b, uint8_t ledn) {\n    if (fake_blink1_lib::SUCCESS(dev)) {\n        RGB ledRgb = fake_blink1_lib::GET_RGB(ledn);\n        *fadeMillis = fake_blink1_lib::GET_FADE_MILLIS(ledn);\n        *r = ledRgb.r;\n        *g = ledRgb.g;\n        *b = ledRgb.b;\n        return 0;\n    } else {\n        return -1;\n    }\n}\n\nint blink1_play(blink1_device* dev, uint8_t play, uint8_t pos) {\n    if (fake_blink1_lib::SUCCESS(dev)) {\n        fake_blink1_lib::playState.playing = (play == 1);\n        fake_blink1_lib::playState.playPos = pos;\n        fake_blink1_lib::playState.playEnd = pos;\n        return 0;\n    } else {\n        return -1;\n    }\n}\n\nint blink1_playloop(blink1_device* dev, uint8_t play, uint8_t startpos, uint8_t endpos, uint8_t count) {\n    if (fake_blink1_lib::SUCCESS(dev)) {\n        fake_blink1_lib::playState.playing = (play == 1);\n        fake_blink1_lib::playState.playStart = startpos;\n        fake_blink1_lib::playState.playEnd = endpos;\n        fake_blink1_lib::playState.playCount = count;\n        return 0;\n    } else {\n        return -1;\n    }\n}\n\nint blink1_readPlayState(blink1_device* dev, uint8_t* playing, uint8_t* playstart, uint8_t* playend, uint8_t* playcount, uint8_t* playpos) {\n    if (fake_blink1_lib::SUCCESS(dev)) {\n        *playing = fake_blink1_lib::playState.playing ? 1 : 0;\n        *playstart = fake_blink1_lib::playState.playStart;\n        *playend = fake_blink1_lib::playState.playEnd;\n        *playcount = fake_blink1_lib::playState.playCount;\n        *playpos = fake_blink1_lib::playState.playPos;\n        return 0;\n    } else {\n        return -1;\n    }\n}\n\nint blink1_writePatternLine(blink1_device* dev, uint16_t fadeMillis, uint8_t r, uint8_t g, uint8_t b, uint8_t pos) {\n    if (fake_blink1_lib::SUCCESS(dev)) {\n        fake_blink1_lib::patternLines[pos] = PatternLineN(r, g, b, fake_blink1_lib::patternLineLEDN, fadeMillis);\n        return 0;\n    } else {\n        return -1;\n    }\n}\n\nint blink1_readPatternLine(blink1_device* dev, uint16_t* fadeMillis, uint8_t* r, uint8_t* g, uint8_t* b, uint8_t pos) {\n    if (fake_blink1_lib::SUCCESS(dev)) {\n        PatternLineN line = fake_blink1_lib::GET_PATTERN_LINE(pos);\n        *r = line.rgbn.r;\n        *g = line.rgbn.g;\n        *b = line.rgbn.b;\n        *fadeMillis = line.fadeMillis;\n        return 0;\n    } else {\n        return -1;\n    }\n}\n\nint blink1_readPatternLineN(blink1_device* dev, uint16_t* fadeMillis, uint8_t* r, uint8_t* g, uint8_t* b, uint8_t* ledn, uint8_t pos) {\n    if (fake_blink1_lib::SUCCESS(dev)) {\n        PatternLineN line = fake_blink1_lib::GET_PATTERN_LINE(pos);\n        *r = line.rgbn.r;\n        *g = line.rgbn.g;\n        *b = line.rgbn.b;\n        *ledn = line.rgbn.n;\n        *fadeMillis = line.fadeMillis;\n        return 0;\n    } else {\n        return -1;\n    }\n}\n\nint blink1_savePattern(blink1_device* dev) {\n    if (fake_blink1_lib::SUCCESS(dev)) {\n        return 0;\n    } else {\n        return -1;\n    }\n}\n\nint blink1_setLEDN(blink1_device* dev, uint8_t ledn) {\n    if (fake_blink1_lib::SUCCESS(dev)) {\n        fake_blink1_lib::patternLineLEDN = ledn;\n        return 0;\n    } else {\n        return -1;\n    }\n}\n\nvoid blink1_enableDegamma() {\n    fake_blink1_lib::degammaEnabled = true;\n}\n\nvoid blink1_disableDegamma() {\n    fake_blink1_lib::degammaEnabled = false;\n}\n\nint blink1_vid() {\n    return fake_blink1_lib::vid;\n}\n\nint blink1_pid() {\n    return fake_blink1_lib::pid;\n}\n\nint blink1_getCacheIndexByDev(blink1_device* dev) {\n    if (fake_blink1_lib::SUCCESS(dev)) {\n        return fake_blink1_lib::cacheIndex;\n    } else {\n        return -1;\n    }\n}\n\nint blink1_clearCacheDev(blink1_device* dev) {\n    if (fake_blink1_lib::SUCCESS(dev)) {\n        return fake_blink1_lib::cacheIndex;\n    } else {\n        return -1;\n    }\n}\n\nconst char* blink1_getSerialForDev(blink1_device* dev) {\n    if (fake_blink1_lib::SUCCESS(dev)) {\n        return fake_blink1_lib::serial.c_str();\n    } else {\n        // TODO ????? - Docs don't specify what happens if it's invalid\n        return \"\";\n    }\n}\n\nint blink1_isMk2(blink1_device* dev) {\n    if (fake_blink1_lib::SUCCESS(dev)) {\n        return fake_blink1_lib::isMk2;\n    } else {\n        // TODO ????? - Docs don't specify what happens if it's invalid\n        return 0;\n    }\n}\n",
              "isBinary": false
            },
            "path": "src/Blink1TestingLibrary.cpp"
          },
          {
            "name": "PatternLine.cpp",
            "type": "blob",
            "object": {
              "text": "#include \"PatternLine.hpp\"\n\nnamespace blink1_lib {\n    PatternLine::PatternLine(const RGB& _rgb, const std::uint16_t _fadeMillis) noexcept : fadeMillis(_fadeMillis), rgb(_rgb) {}\n    PatternLine::PatternLine(const std::uint8_t _r, const std::uint8_t _g, const std::uint8_t _b, const std::uint16_t _fadeMillis) noexcept\n        : fadeMillis(_fadeMillis), rgb(_r, _g, _b) {}\n\n    bool PatternLine::operator==(const PatternLine& other) const noexcept {\n        return fadeMillis == other.fadeMillis && rgb == other.rgb;\n    }\n\n    bool PatternLine::operator!=(const PatternLine& other) const noexcept {\n        return !(*this == other);\n    }\n\n    std::ostream& operator<<(std::ostream& os, const PatternLine& patternLine) {\n        os << \"PatternLine{rgb=\" << patternLine.rgb << \", fadeMillis=\" << static_cast<unsigned>(patternLine.fadeMillis) << \"}\";\n        return os;\n    }\n}\n",
              "isBinary": false
            },
            "path": "src/PatternLine.cpp"
          },
          {
            "name": "PatternLineN.cpp",
            "type": "blob",
            "object": {
              "text": "#include \"PatternLineN.hpp\"\n\nnamespace blink1_lib {\n    PatternLineN::PatternLineN(const RGBN& _rgbn, const std::uint16_t _fadeMillis) noexcept : fadeMillis(_fadeMillis), rgbn(_rgbn) {}\n    PatternLineN::PatternLineN(const std::uint8_t _r, const std::uint8_t _g, const std::uint8_t _b, const std::uint8_t _n, const std::uint16_t _fadeMillis) noexcept\n        : fadeMillis(_fadeMillis), rgbn(_r, _g, _b, _n) {}\n\n    bool PatternLineN::operator==(const PatternLineN& other) const noexcept {\n        return fadeMillis == other.fadeMillis && rgbn == other.rgbn;\n    }\n\n    bool PatternLineN::operator!=(const PatternLineN& other) const noexcept {\n        return !(*this == other);\n    }\n\n    std::ostream& operator<<(std::ostream& os, const PatternLineN& patternLine) {\n        os << \"PatternLine{rgbn=\" << patternLine.rgbn << \", fadeMillis=\" << static_cast<unsigned>(patternLine.fadeMillis) << \"}\";\n        return os;\n    }\n}\n",
              "isBinary": false
            },
            "path": "src/PatternLineN.cpp"
          },
          {
            "name": "PlayState.cpp",
            "type": "blob",
            "object": {
              "text": "#include \"PlayState.hpp\"\n\nnamespace blink1_lib {\n    PlayState::PlayState(const bool _playing, const std::uint8_t _playStart, const std::uint8_t _playEnd, const std::uint8_t _playCount, const std::uint8_t _playPos) noexcept\n        : playing(_playing), playStart(_playStart), playEnd(_playEnd), playCount(_playCount), playPos(_playPos)\n        {}\n\n    bool PlayState::operator==(const PlayState& other) const noexcept {\n        return playing == other.playing\n            && playStart == other.playStart\n            && playEnd == other.playEnd\n            && playCount == other.playCount\n            && playPos == other.playPos;\n    }\n\n    bool PlayState::operator!=(const PlayState& other) const noexcept {\n        return !(*this == other);\n    }\n\n    std::ostream& operator<<(std::ostream& os, const PlayState& playState) {\n        os << \"PlayState{\"\n            << \"playing=\"     << (playState.playing ? \"true\" : \"false\")\n            << \", playStart=\" << static_cast<unsigned>(playState.playStart)\n            << \", playEnd=\"   << static_cast<unsigned>(playState.playEnd)\n            << \", playCount=\" << static_cast<unsigned>(playState.playCount)\n            << \", playPos=\"   << static_cast<unsigned>(playState.playPos)\n            << \"}\";\n        return os;\n    }\n}\n",
              "isBinary": false
            },
            "path": "src/PlayState.cpp"
          },
          {
            "name": "RGB.cpp",
            "type": "blob",
            "object": {
              "text": "#include \"RGB.hpp\"\n\nnamespace blink1_lib {\n    RGB::RGB(const std::uint8_t _r, const std::uint8_t _g, const std::uint8_t _b) noexcept : r(_r), g(_g), b(_b) {}\n\n    bool RGB::operator==(const RGB& other) const noexcept {\n        return r == other.r && g == other.g && b == other.b;\n    }\n\n    bool RGB::operator!=(const RGB& other) const noexcept {\n        return !(*this == other);\n    }\n\n    std::ostream& operator<<(std::ostream& os, const RGB& rgb) {\n        os << \"RGB{r=\" << static_cast<unsigned>(rgb.r)\n            << \", g=\" << static_cast<unsigned>(rgb.g)\n            << \", b=\" << static_cast<unsigned>(rgb.b) << \"}\";\n        return os;\n    }\n}\n",
              "isBinary": false
            },
            "path": "src/RGB.cpp"
          },
          {
            "name": "RGBN.cpp",
            "type": "blob",
            "object": {
              "text": "#include \"RGBN.hpp\"\n\nnamespace blink1_lib {\n    RGBN::RGBN(const std::uint8_t _r, const std::uint8_t _g, const std::uint8_t _b, const std::uint8_t _n) noexcept\n        : r(_r), g(_g), b(_b), n(_n) {}\n\n    bool RGBN::operator==(const RGBN& other) const noexcept {\n        return r == other.r && g == other.g && b == other.b && n == other.n;\n    }\n\n    bool RGBN::operator!=(const RGBN& other) const noexcept {\n        return !(*this == other);\n    }\n\n    std::ostream& operator<<(std::ostream& os, const RGBN& rgb) {\n        os << \"RGBN{r=\" << static_cast<unsigned>(rgb.r)\n            << \", g=\" << static_cast<unsigned>(rgb.g)\n            << \", b=\" << static_cast<unsigned>(rgb.b)\n            << \", n=\" << static_cast<unsigned>(rgb.n) << \"}\";\n        return os;\n    }\n}\n",
              "isBinary": false
            },
            "path": "src/RGBN.cpp"
          },
          {
            "name": "filename_with_a_comma,",
            "type": "blob",
            "object": {
              "text": "",
              "isBinary": false
            },
            "path": "src/filename_with_a_comma,"
          },
          {
            "name": "filename_with_a_brace{",
            "type": "blob",
            "object": {
              "text": "",
              "isBinary": false
            },
            "path": "src/filename_with_a_brace{"
          },
          {
            "name": "another_filename_with_a_comma,",
            "type": "blob",
            "object": {
              "text": "",
              "isBinary": false
            },
            "path": "src/another_filename_with_a_comma,"
          }
        ]
      }
    }
  }
}