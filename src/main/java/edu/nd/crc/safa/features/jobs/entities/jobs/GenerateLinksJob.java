package edu.nd.crc.safa.features.jobs.entities.jobs;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.stream.Collectors;

import edu.nd.crc.safa.features.commits.entities.app.ProjectCommitDefinition;
import edu.nd.crc.safa.features.common.ServiceProvider;
import edu.nd.crc.safa.features.delta.entities.db.ModificationType;
import edu.nd.crc.safa.features.generation.common.GenerationDataset;
import edu.nd.crc.safa.features.generation.tgen.entities.TraceGenerationRequest;
import edu.nd.crc.safa.features.generation.tgen.entities.TracingRequest;
import edu.nd.crc.safa.features.generation.tgen.services.LinkVisibilityService;
import edu.nd.crc.safa.features.generation.tgen.services.TraceGenerationService;
import edu.nd.crc.safa.features.jobs.entities.IJobStep;
import edu.nd.crc.safa.features.jobs.entities.db.JobDbEntity;
import edu.nd.crc.safa.features.jobs.logging.JobLogger;
import edu.nd.crc.safa.features.projects.entities.app.ProjectAppEntity;
import edu.nd.crc.safa.features.traces.ITraceGenerationController;
import edu.nd.crc.safa.features.traces.entities.app.TraceAppEntity;
import edu.nd.crc.safa.features.traces.entities.db.ApprovalStatus;
import edu.nd.crc.safa.features.traces.entities.db.TraceType;
import edu.nd.crc.safa.features.users.entities.db.SafaUser;
import edu.nd.crc.safa.features.versions.entities.ProjectVersion;

/**
 * Generates trace links between artifacts defined in request.
 */
public class GenerateLinksJob extends GenerationJob {
    private final SafaUser user;
    /**
     * The request to generate trace links.
     */
    private final TraceGenerationRequest traceGenerationRequest;
    /**
     * The project version to commit summaries and generated links to.
     */
    private final ProjectVersion projectVersion;
    /**
     * The traces generated by this job.
     */
    private List<TraceAppEntity> generatedTraces;
    /**
     * The entities to generate links for.
     */
    private ProjectAppEntity projectAppEntity;

    public GenerateLinksJob(JobDbEntity jobDbEntity,
                            ServiceProvider serviceProvider,
                            ProjectCommitDefinition projectCommitDefinition,
                            TraceGenerationRequest traceGenerationRequest,
                            SafaUser user) {
        super(jobDbEntity, serviceProvider, projectCommitDefinition);
        this.traceGenerationRequest = traceGenerationRequest;
        this.generatedTraces = new ArrayList<>();
        this.user = user;
        this.projectVersion = projectCommitDefinition.getCommitVersion();
    }

    /**
     * Returns the name of the job.
     *
     * @param traceGenerationRequest The trace generation request being performed by job.
     * @return Job Name.
     */
    public static String getJobName(TraceGenerationRequest traceGenerationRequest) {
        int nArtifactLevels = traceGenerationRequest
            .getRequests()
            .stream()
            .mapToInt(r -> r.getArtifactLevels().size()).sum();
        return String.format("Generating links between %s artifact levels.", nArtifactLevels);
    }

    @IJobStep(value = "Generating links", position = 3)
    public void generateLinks(JobLogger logger) {
        ProjectCommitDefinition projectCommitDefinition = getProjectCommitDefinition();

        for (TracingRequest tracingRequest : traceGenerationRequest.getRequests()) {
            logger.log("Running tracing request:Levels: %s", tracingRequest.getArtifactLevels());

            GenerationDataset generationDataset = TraceGenerationService.extractPayload(tracingRequest,
                projectAppEntity);
            generationDataset.setSummary(this.projectVersion.getProject().getSpecification());

            ITraceGenerationController controller = this.getServiceProvider().getTraceGenerationController();
            List<TraceAppEntity> tracePredictions = controller.generateLinks(generationDataset, this.getDbLogger());
            tracePredictions =
                tracePredictions.stream().filter(t -> t.getScore() >= LinkVisibilityService.MIN_THRESHOLD)
                    .collect(Collectors.toList());
            LinkVisibilityService.setLinksVisibility(tracePredictions);
            this.generatedTraces = tracePredictions;

            logger.log("Generated %d traces.", generatedTraces.size());

            // Step - Filter our trace links overriding manual or approved links
            HashMap<String, List<String>> traceHashMap = new HashMap<>();

            ProjectVersion projectVersion = projectCommitDefinition.getCommitVersion();
            this.getServiceProvider()
                .getTraceService()
                .getAppEntities(projectVersion, user, t -> t.getApprovalStatus() == ApprovalStatus.APPROVED
                    || t.getTraceType() == TraceType.MANUAL)
                .forEach(t -> {
                    if (traceHashMap.containsKey(t.getSourceName())) {
                        traceHashMap.get(t.getSourceName()).add(t.getTargetName());
                    } else {
                        ArrayList<String> targets = new ArrayList<>();
                        targets.add(t.getTargetName());
                        traceHashMap.put(t.getSourceName(), targets);
                    }
                });

            List<TraceAppEntity> filteredGeneratedLinks = this.generatedTraces
                .stream()
                .filter(t -> !traceHashMap.containsKey(t.getSourceName())
                    || !traceHashMap.get(t.getSourceName()).contains(t.getTargetName())).collect(Collectors.toList());

            logger.log("Filtered down to %d traces that will be committed.", filteredGeneratedLinks.size());

            projectCommitDefinition.addTraces(ModificationType.ADDED, filteredGeneratedLinks);
            logger.log("\n================\n");
        }

        logger.log("Total links generated: %d", projectCommitDefinition.getTraces().getSize());
    }
}
