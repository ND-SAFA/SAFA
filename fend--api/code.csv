id,content
babel.config.js,"module.exports = {
  presets: [""@vue/cli-plugin-babel/preset""],
};
"
vue.config.js,"// eslint-disable-next-line @typescript-eslint/no-var-requires
const fs = require(""fs"");

module.exports = {
  configureWebpack: {
    resolve: {
      fallback: {
        fs: false,
      },
    },
  },
  transpileDependencies: [""quasar""],
  pluginOptions: {
    electronBuilder: {
      nodeIntegration: true,
    },
    quasar: {
      importStrategy: ""kebab"",
      rtlSupport: false,
    },
  },
  lintOnSave: true,
  pwa: {
    iconPaths: {
      favicon16: ""favicon.ico"",
      favicon32: ""favicon.ico"",
    },
  },
  devServer: fs.existsSync(""./certs/localhost.safa.ai.pem"")
    ? {
        server: {
          type: ""https"",
          options: {
            key: fs.readFileSync(""./certs/localhost.safa.ai-key.pem""),
            cert: fs.readFileSync(""./certs/localhost.safa.ai.pem""),
          },
        },
        host: ""localhost.safa.ai"",
        port: 8080,
      }
    : {},
};
"
.eslintrc.js,"module.exports = {
  root: true,
  globals: {
    defineProps: ""readonly"",
    defineEmits: ""readonly"",
  },
  env: {
    node: true,
  },
  extends: [
    ""eslint:recommended"",
    ""@vue/typescript/recommended"",
    ""plugin:vue/vue3-recommended"",
    ""@vue/prettier"",
    ""@vue/eslint-config-typescript/recommended"",
    // ""plugin:import/errors"",
    ""plugin:import/warnings"",
  ],
  parserOptions: {
    ecmaVersion: 2020,
  },
  rules: {
    ""no-console"": process.env.NODE_ENV === ""production"" ? ""warn"" : ""off"",
    ""no-debugger"": process.env.NODE_ENV === ""production"" ? ""warn"" : ""off"",
    ""max-lines"": [""warn"", 300],
    ""vue/no-mutating-props"": 0,
    ""vue/script-setup-uses-vars"": ""error"",
    ""vue/multi-word-component-names"": 0,
    ""import/order"": [
      ""warn"",
      {
        groups: [
          ""builtin"",
          ""external"",
          ""type"",
          ""internal"",
          ""parent"",
          ""sibling"",
          ""index"",
          ""object"",
        ],
        pathGroups: [
          {
            pattern: ""@/types"",
            group: ""type"",
          },
          {
            pattern: ""@/util"",
            group: ""internal"",
            position: ""before"",
          },
          {
            pattern: ""@/hooks"",
            group: ""internal"",
            position: ""before"",
          },
          {
            pattern: ""@/router"",
            group: ""internal"",
            position: ""before"",
          },
          {
            pattern: ""@/api"",
            group: ""internal"",
            position: ""before"",
          },
          {
            pattern: ""@/cytoscape"",
            group: ""internal"",
            position: ""before"",
          },
          {
            pattern: ""@/components"",
            group: ""internal"",
            position: ""after"",
          },
          {
            pattern: ""@/views"",
            group: ""internal"",
            position: ""after"",
          },
          {
            pattern: ""@/**"",
            group: ""internal"",
          },
        ],
      },
    ],
  },
  overrides: [
    {
      files: [
        ""**/__tests__/*.{j,t}s?(x)"",
        ""**/tests/unit/**/*.spec.{j,t}s?(x)"",
      ],
      env: {
        mocha: true,
      },
    },
  ],
};
"
cypress.config.ts,"import { defineConfig } from ""cypress"";

export default defineConfig({
  projectId: ""5kk96a"",
  videoUploadOnPasses: false,
  chromeWebSecurity: false,
  e2e: {
    baseUrl: ""https://localhost.safa.ai:8080"",
    experimentalInteractiveRunEvents: true,
    env: {
      // Get with `cy.env(""key"")`
      validUser: {
        email: `test-${Math.random()}@test.com`,
        password: ""123"",
      },
      invalidUser: {
        email: `test-invalid-${Math.random()}@test.com`,
        password: ""super-invalid-password"",
      },
      editUser: {
        email: `test-edit-${Math.random()}@test.com`,
        password: ""123"",
        newPassword: ""newPassword"",
      },
      createUser: {
        email: `test-create-${Math.random()}@test.com`,
        password: ""123"",
      },
      deleteUser: {
        email: `test-delete-${Math.random()}@test.com`,
        password: ""123"",
      },
      inviteUser: {
        email: `test-invite-${Math.random()}@test.com`,
        invalidEmail: `test-invite-${Math.random()}@test.com`,
        password: ""123"",
      },
    },
  },
  clientCertificates: [
    {
      url: ""https://localhost.safa.ai/"",
      ca: [""certs/localhost.safa.ai.pem""],
      certs: [
        {
          key: ""certs/localhost.safa.ai-key.pem"",
          cert: ""certs/localhost.safa.ai.pem"",
        },
      ],
    },
  ],
});
"
cypress/types/cypress.d.ts,"/* eslint-disable max-lines */

/**
 * The position of an element within a list.
 */
type ElementPosition = ""first"" | ""last"";

/**
 * Represents the fields that can be filled in to create an artifact.
 */
interface ArtifactFields {
  name?: string;
  type?: string;
  body?: string;
  parent?: string;
}

/**
 * Represents the fields that can be filled in to create a document.
 */
interface DocumentFields {
  name?: string;
  type?: string;
  includeTypes?: string;
  artifacts?: string;
  includeChildTypes?: string;
  childArtifacts?: string;
}

/**
 * Represents fields that can be filled in to create an attribute.
 */
interface AttributeFields {
  key?: string;
  label?: string;
  min?: string;
  max?: string;
}

/**
 * Represents fields that can be filled in to create an attribute layout.
 */
interface AttributeLayoutFields {
  name?: string;
  type?: string;
}

declare namespace Cypress {
  interface Chainable<Subject> {
    // Database Cleanup

    /**
     * Chains together requests that return data.
     * @param cb - The request options that return data.
     * @return Chainable with request data.
     */
    chainRequest<T>(
      cb: (data: Subject) => Partial<RequestOptions>
    ): Chainable<Response<T>>;

    /**
     * Gets an api token.
     */
    dbToken(): Chainable<void>;

    /**
     * Removes all stored jobs.
     */
    dbResetJobs(): Chainable<void>;

    /**
     * Removes all stored projects.
     */
    dbResetProjects(): Chainable<void>;

    /**
     * Deletes all additional project versions, and creates a new version.
     */
    dbResetVersions(): Chainable<void>;

    /**
     * Removes all stored documents on the most recent project.
     */
    dbResetDocuments(): Chainable<void>;

    /**
     * Removes specified user from database.
     *
     * @param email - The user's email.
     * @param password - The user's password.
     */
    dbDeleteUser(email: string, password: string): Chainable<void>;

    /**
     * Generates all the users that are needed for the tests.
     */
    dbGenerateUsers(): Chainable<void>;

    /**
     * Deletes all the created users after test run.
     */
    dbDeleteGeneratedUsers(): Chainable<void>;

    // Should Commands

    /**
     * Asserts that the current location matches the given route.
     *
     * @param route - Thee route that should match the location.
     */
    locationShouldEqual(route: string): Chainable<void>;

    // Base Commands

    /**
     * Expands the viewport to a preset size.
     */
    expandViewport(size?: ""m"" | ""l""): Chainable<void>;

    /**
     * Gets an element based on the `data-cy` selector.
     *
     * @param dataCy - The testing selector to find.
     * @param elementPosition - Whether to return first or last element of query.
     * @param timeout - The timeout to optionally wait for.
     * @return The elements that match the given selector.
     */
    getCy(
      dataCy: string,
      elementPosition?: ElementPosition,
      timeout?: number
    ): Chainable<JQuery<HTMLElement>>;

    /**
     * Returns whether an element exists.
     * Should not be used in tests, only in before-each cleanup calls.
     *
     * @param dataCy - The testing selector to find.
     * @return Whether the element exists.
     */
    doesExist(dataCy: string): Chainable<boolean>;

    /**
     * Sets the value of an input field.
     *
     * @param dataCy - The testing selector of the input being set.
     * @param inputValue - The value to set.
     * @param clear - If true, the input will be cleared first.
     * @param last - If true, the last element will be selected.
     */
    inputText(
      dataCy: string,
      inputValue: string,
      clear?: boolean,
      last?: boolean
    ): Chainable<void>;

    /**
     * Clicks a button.
     *
     * @param dataCy - The testing selector of the button to click.
     * @param elementPosition - The specific element to grab, if there are multiple.
     * @param force - If true, the click is forced.
     */
    clickButton(
      dataCy: string,
      elementPosition?: ElementPosition,
      force?: boolean
    ): Chainable<void>;

    /**
     * Finds last button with given name within it and clicks it.
     * @param name - Name of button.
     */
    clickButtonWithName(name: string): Chainable<void>;

    /**
     * Clicks option with given name in first select menu found.
     * @param dataCy - The select input to open.
     * @param optionName - Name of option to click.
     */
    clickSelectOption(dataCy: string, optionName: string): Chainable<void>;

    /**
     * Clicks option with given name in first menu found.
     * @param optionName - Name of option to click.
     */
    clickMenuOption(optionName: string): Chainable<void>;

    /**
     * Uploads files.
     *
     * @param dataCy - The testing selector of the file upload input.
     * @param filePaths - The paths to the files to upload.
     */
    uploadFiles(dataCy: string, ...filePaths: string[]): Chainable<void>;

    /**
     * Clicks to switch to a different tab.
     *
     * @param tabLabel - The label of the tab to click.
     */
    switchTab(tabLabel: string): Chainable<void>;

    /**
     * Runs a callback on all rows of a table.
     *
     * @param dataCy - The testing selector of the table.
     * @param fn - A callback run on each row of the table.
     * @param waitForLoad - Defaults to true. Waits for the table to stop loading.
     */
    withinTableRows(
      dataCy: string,
      fn: (tr: Chainable<JQuery<HTMLElement>>) => void,
      waitForLoad?: boolean
    ): Chainable<void>;

    // Authentication Commands

    /**
     * Creates a new account on start page.
     * If the account already exists, it will be deleted and recreated.
     *
     * @param email - The email to create the account with.
     * @param password - The password to create the account with.
     */
    createNewAccount(email: string, password: string): Chainable<void>;

    /**
     * Logs into the app with the given credentials.
     *
     * @param email - The email to log in with.
     * @param password - The password to log in with.
     */
    login(email: string, password: string): Chainable<void>;

    /**
     * Logs into a specific page with the given credentials.
     *
     * @param email - The email to log in with.
     * @param password - The password to log in with.
     * @param route - The route to navigate to.
     * @param query - Any query parameters to include.
     */
    loginToPage(
      email: string,
      password: string,
      route: string,
      query?: Record<string, string>
    ): Chainable<void>;

    /**
     * Logs out of the app.
     */
    logout(): Chainable<void>;

    // Project Creation

    /**
     * Clears the DB of existing projects and jobs.
     * Logs into the create project page and creates an empty project.
     * The user will remain logged in on the artifact view page.
     */
    initEmptyProject(): Chainable<void>;

    /**
     * Clears the DB of existing projects and jobs.
     * Logs into the create project page and creates a bulk project.
     * The user will remain logged in on the job status page.
     *
     * @param waitForComplete - Defaults to true. Whether to wait for the creation job to complete.
     * @param generateData - Defaults to false. Whether to generate data for the project.
     */
    initProject(
      waitForComplete?: boolean,
      generateData?: boolean
    ): Chainable<void>;

    /**
     * Clears the DB of existing project versions, and creates 1 new revision version.
     * Loads the newly created project version.
     * The user will remain logged in on the artifact view page.
     *
     * @param waitForComplete - Defaults to true. Whether to wait for the artifact tree to display nodes.
     */
    initProjectVersion(waitForComplete?: boolean): Chainable<void>;

    /**
     * Setting the project name and description within the project creator.
     *
     * @param type - The type of project identifier to set.
     */
    setProjectIdentifier(type: ""bulk"" | ""standard"" | ""modal""): Chainable<void>;

    /**
     * Opens the last file panel after waiting for it to close when files are parsed.
     */
    openPanelAfterClose(): Chainable<void>;

    /**
     * Creates artifacts - inputs description and uploads file.
     *
     * @param name - The name of the artifact typeto create.
     * @param file - The file that belongs to the artifact.
     * @param next - If true, proceeds to the next step.
     */
    createArtifactPanel(
      name: string,
      file: string,
      next?: boolean
    ): Chainable<void>;

    /**
     * Creates trace matrix - selects source or target then selects artifact.
     *
     * @param sourceType - The first type artifact you want to select in the source (ex. requirement).
     * @param targetType - The second type of artifact you want to select for target (ex. hazard).
     * @param file - The file that belongs to the trace link (ex. hazard2hazard).
     *               If none, is set, this will not be uploaded, and the stepper will not continue.
     * @param next - If true, proceeds to the next step.
     */
    createTraceMatrix(
      sourceType: string,
      targetType: string,
      file?: string,
      next?: boolean
    ): Chainable<void>;

    /**
     * Creates artifacts & a trace matrix for requirements and hazards.
     *
     * @param createTraces - If true, traces will be created between the artifact types.
     * @param next - If true, proceeds to the final step.
     */
    createReqToHazardFiles(
      createTraces?: boolean,
      next?: boolean
    ): Chainable<void>;

    /**
     * Navigates to the settings page and upload flat files tab.
     */
    openUploadFiles(): Chainable<void>;

    /**
     * Waits for the most recent job to complete.
     */
    waitForJobLoad(): Chainable<void>;

    // Project Selection

    /**
     * Opens the project selector page.
     */
    openProjectSelector(): Chainable<void>;

    /**
     * Must have the project selector open.
     * On the project step: Selects the current project, continuing to the version step.
     * On the version step: Selects the current version, continuing to the project page.
     *
     * @param select - If set, the first project or version will be selected before continuing.
     */
    projectSelectorContinue(select?: ""project"" | ""version""): Chainable<void>;

    /**
     * Must have the project selector open to the version step.
     * Creates a new version of the given type.
     */
    createNewVersion(type: ""major"" | ""minor"" | ""revision""): Chainable<void>;

    // Project Settings

    /**
     * Opens the project settings page.
     */
    openProjectSettings(): Chainable<void>;

    // Project Membership

    /**
     * Adds New member into a project
     * Must be in project settings.
     * @param name - Input email of new member.
     * @param projectRole - Input project role such as ""owner"", ""Editor"", ""Viewer"", ""Admin""
     */
    projectAddNewMember(name: string, projectRole: string): Chainable<void>;

    // Artifacts

    /**
     * Fills inputs in the artifact panel.
     * The artifact name, type, and body will be filled with preset values if not set.
     * The panel must already be open.
     *
     * @param props - The artifact fields to set.
     */
    fillArtifactFields(props: ArtifactFields): Chainable<void>;

    /**
     * Creates a new artifact from the artifact fab button.
     *
     * @param props - The artifact fields to set.
     * @param save - Defaults to false. Whether to save the artifact or keep the panel open.
     * @param close - Defaults to false. Whether to close the artifact panel after creation.
     */
    createNewArtifact(
      props: ArtifactFields,
      save?: boolean,
      close?: boolean
    ): Chainable<void>;

    // Trace Links

    /**
     * Fills in inputs within the trace link panel.
     * The panel must already be open.
     *
     * @param sourceName - The name of the source artifact.
     * @param targetName - The name of the target artifact.
     */
    fillTraceLinkFields(
      sourceName?: string,
      targetName?: string
    ): Chainable<void>;

    /**
     * Creates a new trace link from the artifact fab button.
     *
     * @param sourceName - The name of the source artifact.
     * @param targetName - The name of the target artifact.
     * @param save - Defaults to false. Whether to save the trace link or keep the panel open.
     */
    createNewTraceLink(
      sourceName?: string,
      targetName?: string,
      save?: boolean
    ): Chainable<void>;

    // Artifact Tree

    /**
     * Get a node on the graph by name
     *
     * @param name - The name of the node to find.
     */
    getNode(name: string): Chainable<JQuery<HTMLElement>>;

    /**
     * Gets nodes on the graph.
     *
     * @param selected - If true, only the selected node is returned.
     */
    getNodes(selected?: boolean): Chainable<JQuery<HTMLElement>>;

    /**
     * Waits for the artifact tree to load.
     *
     * @param waitForNodes - If true, this will wait for nodes to be painted on the graph.
     */
    waitForProjectLoad(waitForNodes?: boolean): Chainable<void>;

    /**
     * Centers the graph.
     */
    centerGraph(): Chainable<void>;

    /**
     * Enables basic search when in artifact view.
     */
    enableBasicSearch(): Chainable<void>;

    /**
     * Selects an artifact on the graph.
     *
     * @param name - The artifact name to select.
     */
    selectArtifact(name: string): Chainable<void>;

    // Artifact Table

    /**
     * Switches to table view.
     */
    switchToTableView(tab?: ""artifact"" | ""trace"" | ""approval""): Chainable<void>;

    /**
     * Sorts the artifact and trace matrix tables.
     *
     * @param sort - The type of sort to apply.
     */
    sortArtifactTable(sort: ""none"" | ""name"" | ""type""): Chainable<void>;

    /**
     * Groups the artifact and trace matrix tables.
     *
     * @param group - The type of group to apply.
     */
    groupArtifactTable(group: ""none"" | ""name"" | ""type""): Chainable<void>;

    /**
     * Filters the rows and columns of the trace matrix table.
     *
     * @param row - The row type to filter by.
     * @param col - The column type to filter by.
     */
    filterTraceMatrixTable(row: string, col: string): Chainable<void>;

    // TIM View

    /**
     * Switches to TIM view.
     */
    switchToTimView(): Chainable<void>;

    // Project Documents

    /**
     * Opens the document selector.
     */
    openDocumentSelector(): Chainable<void>;

    /**
     * Opens the document creator.
     */
    openDocumentCreator(): Chainable<void>;

    /**
     * Opens the document editor for the document with the given name.
     *
     * @param name - TRhe document to open.
     */
    openDocumentEditor(name: string): Chainable<void>;

    /**
     * Fills the document fields in the panel.
     * The document panel must be open.
     *
     * @param props - The document fields to set.
     *                The name will be added if not set.
     */
    fillDocumentFields(props: DocumentFields): Chainable<void>;

    /**
     * Creates a new document.
     *
     * @param props - The document fields to set.
     *                The name will be added if not set.
     * @param save. Defaults to false. Whether to save the document or leave the panel open.
     */
    createDocument(props: DocumentFields, save?: boolean): Chainable<void>;

    // Trace Approval

    /**
     * Sorts the trace approval table.
     *
     * @param sort - The type of sort to apply.
     */
    sortTraceApproval(sort: ""none"" | ""name"" | ""approval""): Chainable<void>;

    /**
     * Groups the trace approval table.
     *
     * @param group - The type of group to apply.
     */
    groupTraceApproval(group: ""none"" | ""type"" | ""status""): Chainable<void>;

    /**
     * Filters the trace approval table.
     *
     * @param filter - The type of filter to apply.
     */
    filterTraceApproval(
      filter: ""all"" | ""approved"" | ""declined""
    ): Chainable<void>;

    // Custom Attributes

    /**
     * Fills inputs in the custom attribute panel.
     *
     * @param props - The attribute fields to set.
     */
    fillCustomAttributeFields(props: AttributeFields): Chainable<void>;

    /**
     * Creates a new custom attribute.
     * The custom attribute panel must be open.
     *
     * @param props - The attribute fields to set.
     */
    createCustomAttribute(props: AttributeFields): Chainable<void>;

    /**
     * Fills inputs in the custom attribute layout panel.
     * The custom attribute panel must be open and a custom attribute must be made
     * before this is called.
     *
     * @param props - The custom layout fields to set.
     */
    fillCustomLayoutFields(props: AttributeLayoutFields): Chainable<void>;

    /**
     * Creates a new custom Layout.
     * The custom attribute panel must be open and a custom attribute must be made
     * before this is called.
     *
     * @param props - The custom layout fields to set.
     */
    createCustomLayout(props: AttributeLayoutFields): Chainable<void>;
  }
}
"
cypress/support/artifactTableCommands.ts,"import { DataCy } from ""@/fixtures"";

Cypress.Commands.add(""switchToTableView"", (tab) => {
  cy.clickButton(DataCy.navTableButton);

  if (tab === ""trace"") {
    cy.switchTab(""Trace Links"");
  } else if (tab === ""approval"") {
    cy.switchTab(""Trace Approval"");
  }
});

Cypress.Commands.add(""sortArtifactTable"", (sort) => {
  if (sort === ""name"") {
    cy.clickButton(DataCy.artifactTableSortByInput).clickMenuOption(""name"");
  } else if (sort === ""type"") {
    cy.clickButton(DataCy.artifactTableSortByInput).clickMenuOption(""type"");
  } else {
    cy.clickButton(DataCy.artifactTableSortByInput).type(""{backspace}{esc}"");
  }
});

Cypress.Commands.add(""groupArtifactTable"", (group) => {
  if (group === ""name"") {
    cy.clickButton(DataCy.artifactTableGroupByInput).clickMenuOption(""name"");
  } else if (group === ""type"") {
    cy.clickButton(DataCy.artifactTableGroupByInput).clickMenuOption(""type"");
  } else {
    cy.clickButton(DataCy.artifactTableGroupByInput).type(""{backspace}{esc}"");
  }
});

Cypress.Commands.add(""filterTraceMatrixTable"", (row, col) => {
  cy.clickButton(DataCy.traceMatrixTableRowTypeInput).type(
    `${row}{downArrow}{enter}{esc}`
  );

  cy.clickButton(DataCy.traceMatrixTableColTypeInput).type(
    `${col}{downArrow}{enter}{esc}`
  );
});
"
cypress/support/projectSelectionCommands.ts,"import { DataCy, Routes } from ""@/fixtures"";

Cypress.Commands.add(""openProjectSelector"", () => {
  cy.visit(Routes.MY_PROJECTS).locationShouldEqual(Routes.MY_PROJECTS);
});

Cypress.Commands.add(""openUploadFiles"", () => {
  cy.clickButtonWithName(""Settings"").switchTab(""Data Upload"");
});

Cypress.Commands.add(""projectSelectorContinue"", (select) => {
  if (select === ""project"") {
    cy.withinTableRows(DataCy.selectionProjectList, (tr) => {
      tr.eq(1).click();
    });
  } else if (select === ""version"") {
    cy.withinTableRows(DataCy.selectionVersionList, (tr) => {
      tr.eq(1).click();
    });
  } else {
    cy.clickButton(DataCy.stepperContinueButton);
  }
});

Cypress.Commands.add(""createNewVersion"", (type) => {
  const selectors: Record<typeof type, string> = {
    major: DataCy.versionCreateMajorButton,
    minor: DataCy.versionCreateMinorButton,
    revision: DataCy.versionCreateRevisionButton,
  };

  cy.clickButton(DataCy.selectorAddButton, ""last"");

  cy.getCy(DataCy.versionCreateModal).within(() => {
    cy.clickButton(selectors[type]);
  });
});
"
cypress/support/timTreeCommands.ts,"import { DataCy } from ""@/fixtures"";

Cypress.Commands.add(""switchToTimView"", () => {
  cy.clickButton(DataCy.navTimButton);
});
"
cypress/support/authenticationCommands.ts,"import { DataCy, Routes } from ""@/fixtures"";

Cypress.Commands.add(""login"", (email, password) => {
  cy.inputText(DataCy.emailInput, email, true)
    .inputText(DataCy.passwordInput, password, true)
    .clickButton(DataCy.loginButton);
});

Cypress.Commands.add(""loginToPage"", (email, password, route, query = {}) => {
  const queryString =
    Object.keys(query).length > 0
      ? ""?"" + new URLSearchParams(query).toString()
      : """";

  cy.visit(route + queryString)
    .login(email, password)
    .locationShouldEqual(route);
});

Cypress.Commands.add(""logout"", () => {
  cy.wait(1000)
    .clickButton(DataCy.accountPage)
    .locationShouldEqual(Routes.ACCOUNT)
    .clickButton(DataCy.logoutButton);
});

Cypress.Commands.add(""createNewAccount"", (email, password) => {
  cy.dbDeleteUser(email, password);

  cy.visit(Routes.CREATE_ACCOUNT)
    .inputText(DataCy.newAccountEmailInput, email)
    .inputText(DataCy.newAccountPasswordInput, password)
    .clickButton(DataCy.createAccountButton);
});
"
cypress/support/artifactTreeCommands.ts,"import { DataCy } from ""@/fixtures"";

Cypress.Commands.add(""getNode"", (name) => {
  return cy.get(`[data-cy-name=""${name}""]`);
});

Cypress.Commands.add(""getNodes"", (selected) => {
  if (selected) {
    return cy.getCy(DataCy.treeSelectedNode);
  } else {
    return cy
      .getCy(DataCy.treeNode, undefined, 10000)
      .should(""be.visible"")
      .filter("":visible"");
  }
});

Cypress.Commands.add(""waitForProjectLoad"", (waitForNodes = true) => {
  cy.getCy(DataCy.appLoading).should(""not.exist"");

  if (waitForNodes) {
    cy.getNodes().should(""be.visible"");
  }
});

Cypress.Commands.add(""centerGraph"", () => {
  // Wait for graph to center.
  cy.clickButton(DataCy.navGraphCenterButton).wait(200);
});

Cypress.Commands.add(""enableBasicSearch"", () => {
  cy.clickButton(DataCy.artifactSearchModeInput).clickMenuOption(
    ""currently displayed""
  );
});

Cypress.Commands.add(""selectArtifact"", (name) => {
  cy.enableBasicSearch();
  cy.inputText(DataCy.artifactSearchNavInput, name).clickButton(
    DataCy.artifactSearchItem,
    ""first""
  );
});
"
cypress/support/traceLinkGenerationCommands.ts,"import { DataCy } from ""@/fixtures"";

Cypress.Commands.add(""sortTraceApproval"", (sort) => {
  if (sort === ""name"") {
    cy.clickButton(DataCy.traceLinkTableSortByInput).clickMenuOption(""name"");
  } else if (sort === ""approval"") {
    cy.clickButton(DataCy.traceLinkTableSortByInput).clickMenuOption(
      ""approval""
    );
  } else {
    cy.clickButton(DataCy.traceLinkTableSortByInput).type(""{backspace}{esc}"");
  }
});

Cypress.Commands.add(""groupTraceApproval"", (group) => {
  if (group === ""type"") {
    cy.clickButton(DataCy.traceLinkTableGroupByInput).clickMenuOption(""type"");
  } else if (group === ""status"") {
    cy.clickButton(DataCy.traceLinkTableGroupByInput).clickMenuOption(""status"");
  } else {
    cy.clickButton(DataCy.traceLinkTableGroupByInput).type(""{backspace}{esc}"");
  }
});

Cypress.Commands.add(""filterTraceApproval"", (filter) => {
  if (filter === ""approved"") {
    cy.clickButton(DataCy.traceLinkTableApprovalInput).type(
      ""{backspace}approved{downArrow}{enter}""
    );
  } else if (filter === ""declined"") {
    cy.clickButton(DataCy.traceLinkTableApprovalInput).type(
      ""{backspace}declined{downArrow}{enter}""
    );
  } else {
    cy.clickButton(DataCy.traceLinkTableApprovalInput).type(""{backspace}{esc}"");
  }
});
"
cypress/support/projectSettingCommands.ts,"import { DataCy } from ""@/fixtures"";

Cypress.Commands.add(""openProjectSettings"", () => {
  cy.clickButton(DataCy.navSettingsButton);
});

Cypress.Commands.add(""projectAddNewMember"", (name, projectRole) => {
  cy.clickButton(DataCy.selectorAddButton);

  cy.inputText(DataCy.projectSettingsAddEmail, name);

  cy.clickButton(DataCy.projectSettingsAddRole).clickButtonWithName(
    projectRole
  );

  cy.clickButton(DataCy.projectSettingsAddToProject);
});
"
cypress/support/shouldCommands.ts,"Cypress.Commands.add(""locationShouldEqual"", (route) => {
  cy.location(""pathname"", { timeout: 10000 }).should(""equal"", route);
});
"
cypress/support/artifactCommands.ts,"import { DataCy } from ""@/fixtures"";

Cypress.Commands.add(""fillArtifactFields"", ({ name, type, body, parent }) => {
  if (name === undefined) name = `New ${Math.random()}`;
  if (type === undefined) type = ""Design{downArrow}{enter}"";
  if (body === undefined) body = ""New Artifact"";

  cy.inputText(DataCy.artifactSaveNameInput, name)
    .inputText(DataCy.artifactSaveBodyInput, body)
    .inputText(DataCy.artifactSaveTypeInput, type);

  if (parent) {
    cy.inputText(DataCy.artifactSaveParentInput, parent);
  }
});

Cypress.Commands.add(""createNewArtifact"", (props, save, close) => {
  cy.clickButton(DataCy.artifactFabToggle)
    .clickButton(DataCy.artifactFabCreateArtifact)
    .fillArtifactFields(props);

  if (!save) return;

  cy.clickButton(DataCy.artifactSaveSubmitButton);

  if (!close) return;

  cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
  cy.clickButton(DataCy.selectedPanelCloseButton);
});
"
cypress/support/e2e.ts,"import ""./baseCommands"";
import ""./dbCommands"";
import ""./shouldCommands"";
import ""./authenticationCommands"";
import ""./projectCreatorCommands"";
import ""./projectSelectionCommands"";
import ""./artifactCommands"";
import ""./traceLinkCommands"";
import ""./artifactTreeCommands"";
import ""./artifactTableCommands"";
import ""./timTreeCommands"";
import ""./projectDocumentCommands"";
import ""./projectSettingCommands"";
import ""./traceLinkGenerationCommands"";
import ""./customAttributesCommands"";

/**
 * Ignore the following error:
 * - ResizeObserver loop limit exceeded
 * - Cannot read properties of _
 */
Cypress.on(""uncaught:exception"", (err) => {
  if (
    err.message.includes(""ResizeObserver loop"") ||
    err.message.includes(""Cannot read properties of"") ||
    err.message.includes(""Cannot destructure property"") ||
    err.message.includes(""Session has timed out"") ||
    err.message.includes(""Unexpected end of JSON"")
  ) {
    // ignore the error
    return false;
  }
});

/**
 * Generate users before running tests.
 */
before(() => {
  cy.log(""Generating users..."");
  cy.dbGenerateUsers();
});

/**
 * Delete users after running tests.
 */
after(() => {
  cy.log(""Cleaning up users..."");
  cy.dbDeleteGeneratedUsers();
});
"
cypress/support/traceLinkCommands.ts,"import { DataCy } from ""@/fixtures"";

Cypress.Commands.add(""fillTraceLinkFields"", (source = """", target = """") => {
  cy.inputText(
    DataCy.traceSaveSourceInput,
    `${source}{downArrow}{enter}{esc}`
  ).inputText(DataCy.traceSaveTargetInput, `${target}{downArrow}{enter}{esc}`);
});

Cypress.Commands.add(""createNewTraceLink"", (source = """", target = """", save) => {
  cy.clickButton(DataCy.artifactFabToggle)
    .clickButton(DataCy.artifactFabCreateTrace)
    .fillTraceLinkFields(source, target);

  if (!save) return;

  cy.clickButton(DataCy.traceSaveSubmitButton);
});
"
cypress/support/baseCommands.ts,"import ""cypress-file-upload"";

Cypress.Commands.add(""expandViewport"", (size) => {
  if (size === ""l"") {
    cy.viewport(1024 * 2, 768 * 2);
  } else {
    cy.viewport(1024, 768);
  }
});

Cypress.Commands.add(""getCy"", (dataCy, elementPosition, timeout) => {
  const elements = cy.get(`[data-cy=""${dataCy}""]`, { timeout });

  if (elementPosition === ""first"") {
    return elements.first({ timeout });
  } else if (elementPosition === ""last"") {
    return elements.last({ timeout });
  } else {
    return elements;
  }
});

Cypress.Commands.add(""doesExist"", (dataCy) => {
  return cy.get(""body"").then((body) => {
    return body.find(`[data-cy=""${dataCy}""]`).length > 0;
  });
});

Cypress.Commands.add(""inputText"", (dataCy, inputValue, clear, last) => {
  const el = last
    ? cy.getCy(dataCy, ""last"")
    : cy.getCy(dataCy).filter("":visible"");

  if (clear) {
    el.clear();
  }

  if (inputValue.length === 0) return;

  el.type(inputValue);
});

Cypress.Commands.add(
  ""clickButton"",
  (dataCy, elementPosition = ""first"", force = false) => {
    cy.getCy(dataCy, elementPosition).click({ force });
  }
);

Cypress.Commands.add(""clickButtonWithName"", (name) => {
  cy.contains(name, { matchCase: false }).last().click();
});

Cypress.Commands.add(""clickSelectOption"", (dataCy, optionName) => {
  cy.getCy(dataCy).parent().click();
  cy.get("".v-menu__content"")
    .filter("":visible"")
    .contains(optionName, { matchCase: false })
    .click();
  cy.get("".v-menu__content"").should(""not.be.visible"");
});

Cypress.Commands.add(""clickMenuOption"", (optionName) => {
  cy.get(`[role=""listbox""]`)
    .contains(optionName, { matchCase: false })
    .first()
    .click();
});

Cypress.Commands.add(""uploadFiles"", (dataCy, ...filePaths) => {
  cy.getCy(dataCy, ""last"").attachFile(filePaths);
});

Cypress.Commands.add(""switchTab"", (tabLabel) => {
  cy.get("".q-tabs"").within(() => {
    cy.contains(""div"", tabLabel).click();
  });
});

Cypress.Commands.add(""withinTableRows"", (dataCy, fn, waitForLoad = true) => {
  cy.getCy(dataCy)
    .should(""be.visible"")
    .within(() => {
      if (waitForLoad) {
        cy.get("".q-linear-progress__model"").should(""not.exist"");
      }

      fn(cy.get(""tr""));
    });
});
"
cypress/support/projectCreatorCommands.ts,"import {
  DataCy,
  miniProjectFiles,
  genProjectFiles,
  Routes,
  simpleProjectFilesMap,
  testProject,
} from ""@/fixtures"";

const validUser = Cypress.env(""validUser"");

Cypress.Commands.add(""initEmptyProject"", () => {
  cy.dbResetJobs().dbResetProjects();

  cy.visit(Routes.PROJECT_CREATOR + ""?tab=bulk"")
    .login(validUser.email, validUser.password)
    .locationShouldEqual(Routes.PROJECT_CREATOR);

  cy.setProjectIdentifier(""bulk"")
    .clickButton(DataCy.creationEmptyToggle)
    .clickButton(DataCy.creationUploadButton);
});

Cypress.Commands.add(""initProject"", (waitForComplete = true, generateData) => {
  cy.dbResetJobs().dbResetProjects();

  cy.visit(Routes.PROJECT_CREATOR + ""?tab=bulk"")
    .login(validUser.email, validUser.password)
    .locationShouldEqual(Routes.PROJECT_CREATOR);

  cy.setProjectIdentifier(""bulk"")
    .uploadFiles(
      DataCy.creationBulkFilesInput,
      ...(generateData ? genProjectFiles : miniProjectFiles)
    )
    .clickButton(DataCy.creationUploadButton);

  if (!waitForComplete) return;

  cy.waitForJobLoad();
});

Cypress.Commands.add(""initProjectVersion"", (waitForComplete = true) => {
  cy.dbResetVersions();

  cy.visit(Routes.MY_PROJECTS)
    .login(validUser.email, validUser.password)
    .locationShouldEqual(Routes.MY_PROJECTS);

  cy.expandViewport()
    .projectSelectorContinue(""project"")
    .projectSelectorContinue(""version"")
    .locationShouldEqual(Routes.ARTIFACT);

  cy.getCy(DataCy.appLoading).should(""not.exist"");
  cy.clickButton(DataCy.navTreeButton);

  cy.waitForProjectLoad(waitForComplete);
});

Cypress.Commands.add(""setProjectIdentifier"", (type) => {
  if (type === ""standard"") {
    cy.getCy(DataCy.creationStandardNameInput).type(testProject.name);
    cy.getCy(DataCy.creationStandardDescriptionInput).type(
      testProject.description
    );
    cy.clickButton(DataCy.stepperContinueButton);
  } else if (type === ""modal"") {
    cy.getCy(DataCy.projectEditNameInput).type(testProject.name);
    cy.getCy(DataCy.projectEditDescriptionInput).type(testProject.description);
  } else {
    cy.getCy(DataCy.creationBulkNameInput).type(testProject.name);
    cy.getCy(DataCy.creationBulkDescriptionInput).type(testProject.description);
  }
});

Cypress.Commands.add(""openPanelAfterClose"", () => {
  cy.wait(300).clickButton(DataCy.creationFilePanel, ""last"");
});

Cypress.Commands.add(""createArtifactPanel"", (name, file, next) => {
  cy.inputText(DataCy.creationTypeInput, name, false, true);
  cy.uploadFiles(DataCy.creationStandardFilesInput, file);

  if (next) {
    cy.clickButton(DataCy.stepperContinueButton);
  }
});

Cypress.Commands.add(""createTraceMatrix"", (source, target, file, next) => {
  cy.clickButton(DataCy.creationTraceSourceInput).clickButtonWithName(source);
  cy.clickButton(DataCy.creationTraceTargetInput).clickButtonWithName(target);

  if (file) {
    cy.uploadFiles(DataCy.creationStandardFilesInput, file);
  }

  if (next) {
    cy.clickButton(DataCy.stepperContinueButton);
  }
});

Cypress.Commands.add(""createReqToHazardFiles"", (createTraces, next) => {
  cy.setProjectIdentifier(""standard"");
  cy.createArtifactPanel(""requirement"", simpleProjectFilesMap.requirement);
  cy.clickButtonWithName(""New Artifact Type"");
  cy.createArtifactPanel(""hazard"", simpleProjectFilesMap.hazard, true);

  if (createTraces) {
    cy.createTraceMatrix(
      ""requirement"",
      ""hazard"",
      simpleProjectFilesMap.requirement2hazard,
      next
    );
  }
});

Cypress.Commands.add(""waitForJobLoad"", () => {
  cy.wrap(null, { timeout: 10000 }).then(() => {
    cy.getCy(DataCy.jobOpenButton, ""first"", 10000).should(""not.be.disabled"");
  });
});
"
cypress/support/customAttributesCommands.ts,"import { DataCy } from ""@/fixtures"";

Cypress.Commands.add(""fillCustomAttributeFields"", (props) => {
  cy.clickButton(DataCy.addAttributeButton);
  cy.inputText(DataCy.attributeKeyInput, props.key);
  cy.inputText(DataCy.attributeLabelInput, props.label);
  cy.inputText(DataCy.attributeMinInput, props.min);
  cy.inputText(DataCy.attributeMaxInput, props.max);
});

Cypress.Commands.add(""createCustomAttribute"", (props) => {
  cy.fillCustomAttributeFields(props).clickButton(DataCy.attributeSaveButton);
});

Cypress.Commands.add(""fillCustomLayoutFields"", (props) => {
  cy.clickButton(DataCy.attributeLayoutAddButton).clickButton(
    DataCy.attributeTableItemPlusButton
  );

  cy.inputText(DataCy.attributeLayoutNameInput, props.name);
  cy.inputText(DataCy.attributeLayoutTypeInput, props.type);
});

Cypress.Commands.add(""createCustomLayout"", (props) => {
  cy.fillCustomLayoutFields(props).clickButton(
    DataCy.attributeLayoutSaveButton
  );
});
"
cypress/support/projectDocumentCommands.ts,"import { DataCy } from ""@/fixtures"";

Cypress.Commands.add(""openDocumentSelector"", () => {
  cy.clickButton(DataCy.documentSelectButton, undefined, true);
});

Cypress.Commands.add(""openDocumentCreator"", () => {
  cy.openDocumentSelector().clickButton(DataCy.documentCreateButton);
});

Cypress.Commands.add(""openDocumentEditor"", (name) => {
  cy.openDocumentSelector()
    .get(`[data-cy-name=""${name}""]`)
    .within(() => {
      cy.clickButton(DataCy.documentEditButton);
    });
});

Cypress.Commands.add(
  ""fillDocumentFields"",
  ({
    name,
    type,
    includeTypes,
    artifacts,
    includeChildTypes,
    childArtifacts,
  }) => {
    if (name === undefined) name = `New ${Math.random()}`;

    cy.clickButton(DataCy.documentIncludeChildrenToggle);
    cy.inputText(DataCy.documentNameInput, name);

    if (type) {
      cy.clickButton(
        DataCy.documentTypeInput,
        undefined,
        true
      ).clickButtonWithName(type);
    }
    if (includeTypes) {
      cy.inputText(DataCy.documentIncludeTypesInput, `${includeTypes}{esc}`);
    }
    if (artifacts) {
      cy.inputText(DataCy.documentArtifactsInput, `${artifacts}{esc}`);
    }
    if (includeChildTypes) {
      cy.inputText(DataCy.documentChildTypesInput, `${includeChildTypes}{esc}`);
    }
    if (childArtifacts) {
      cy.inputText(
        DataCy.documentChildArtifactsInput,
        `${childArtifacts}{esc}`
      );
    }
  }
);

Cypress.Commands.add(""createDocument"", (props, save) => {
  cy.openDocumentCreator().fillDocumentFields(props);

  if (!save) return;

  cy.clickButton(DataCy.documentSaveButton);
});
"
cypress/support/dbCommands.ts,"import { Routes } from ""@/fixtures"";

const apiUrl = ""https://dev-api.safa.ai"";

Cypress.on(""window:before:load"", (window) => {
  // Disable the cookie banner.
  window.document.cookie = `wpcc=dismiss`;
});

Cypress.Commands.add(
  ""chainRequest"",
  {
    prevSubject: true,
  },
  (subject: Cypress.Response<any>, cb) => {
    return cy.request(cb(subject));
  }
);

Cypress.Commands.add(""dbToken"", () => {
  const validUser = Cypress.env(""validUser"");

  cy.request(""POST"", `${apiUrl}/login`, validUser);
});

Cypress.Commands.add(""dbResetJobs"", () => {
  cy.dbToken()
    .then(() => {
      cy.request<{ id: string }[]>({
        method: ""GET"",
        url: `${apiUrl}/jobs`,
      }).then(({ body: jobs }) =>
        jobs.forEach((job) =>
          cy.request({
            method: ""DELETE"",
            url: `${apiUrl}/jobs/${job.id}`,
          })
        )
      );
    })
    .clearAllCookies();
});

Cypress.Commands.add(""dbResetProjects"", () => {
  cy.dbToken()
    .then(() => {
      cy.request<{ projectId: string }[]>({
        method: ""GET"",
        url: `${apiUrl}/projects`,
      }).then(({ body: projects }) =>
        projects.forEach(({ projectId }) =>
          cy.request({
            method: ""DELETE"",
            url: `${apiUrl}/projects/${projectId}`,
          })
        )
      );
    })
    .clearAllCookies();
});

Cypress.Commands.add(""dbResetDocuments"", () => {
  cy.dbToken()
    .then(() => {
      cy.request<{ projectId: string }[]>({
        method: ""GET"",
        url: `${apiUrl}/projects`,
      })
        .chainRequest<{ versionId: string }>(({ body: projects }) => ({
          method: ""GET"",
          url: `${apiUrl}/projects/${projects[0].projectId}/versions/current`,
        }))
        .chainRequest<{ documents: { documentId: string }[] }>(
          ({ body: { versionId } }) => ({
            method: ""GET"",
            url: `${apiUrl}/projects/versions/${versionId}`,
          })
        )
        .then(({ body: { documents } }) =>
          documents.forEach(({ documentId }) =>
            cy.request({
              method: ""DELETE"",
              url: `${apiUrl}/projects/documents/${documentId}`,
            })
          )
        );
    })
    .clearAllCookies();
});

Cypress.Commands.add(""dbResetVersions"", () => {
  cy.dbToken()
    .then(() => {
      cy.request<{ projectId: string }[]>({
        method: ""GET"",
        url: `${apiUrl}/projects`,
      }).then(({ body: projects }) => {
        const projectId = projects[0].projectId;
        cy.request<{ versionId: string }[]>({
          method: ""GET"",
          url: `${apiUrl}/projects/${projectId}/versions`,
        }).then(({ body: versions }) => {
          versions.slice(0, -1).forEach(({ versionId }) =>
            cy.request({
              method: ""DELETE"",
              url: `${apiUrl}/projects/versions/${versionId}`,
            })
          );
          cy.request({
            method: ""POST"",
            url: `${apiUrl}/projects/${projectId}/versions/revision`,
          });
        });
      });
    })
    .clearAllCookies();
});

Cypress.Commands.add(""dbDeleteUser"", (email, password) => {
  cy.request({
    method: ""POST"",
    url: `${apiUrl}/login`,
    failOnStatusCode: false,
    body: { email, password },
  }).then(() => {
    cy.request({
      method: ""POST"",
      url: `${apiUrl}/accounts/delete`,
      body: { password },
      failOnStatusCode: false,
    });
  });
});

Cypress.Commands.add(""dbGenerateUsers"", () => {
  const { validUser, editUser, deleteUser, inviteUser } = Cypress.env();

  for (const user of [validUser, editUser, deleteUser, inviteUser]) {
    cy.request<{ token: string }>({
      failOnStatusCode: false,
      method: ""POST"",
      url: `${apiUrl}/accounts/create`,
      body: { email: user.email, password: user.password },
    });
  }
});

Cypress.Commands.add(""dbDeleteGeneratedUsers"", () => {
  const { validUser, editUser, deleteUser, inviteUser } = Cypress.env();

  for (const user of [validUser, editUser, deleteUser, inviteUser]) {
    cy.dbDeleteUser(user.email, user.password);
  }
});
"
cypress/fixtures/index.ts,"export * from ""./data"";
export * from ""./constants"";
"
cypress/fixtures/constants/routes.ts,"/**
 * Enumerates the possible routes within the app.
 */
export enum Routes {
  LOGIN_ACCOUNT = ""/login"",
  CREATE_ACCOUNT = ""/create-account"",
  FORGOT_PASSWORD = ""/forgot"",
  RESET_PASSWORD = ""/reset"",
  HOME = ""/"",
  PROJECT_CREATOR = ""/create"",
  MY_PROJECTS = ""/open"",
  ARTIFACT = ""/project"",
  PROJECT_SETTINGS = ""/settings"",
  TRACE_LINK = ""/links"",
  UPLOAD_STATUS = ""/uploads"",
  ACCOUNT = ""/account"",
  ERROR = ""/error"",
}
"
cypress/fixtures/constants/project.ts,"export const testProject = {
  name: ""Test Project"",
  description: ""A project created during testing"",
};
"
cypress/fixtures/constants/dataCy.ts,"/**
 * Represents all data cy selectors used in the app.
 */
export enum DataCy {
  // General

  appLoading = ""app-loading"",

  // Navigation - Project Graph

  navGraphCenterButton = ""button-nav-graph-center"",
  navGraphFilterButton = ""button-nav-graph-filter"",
  navGraphFilterOption = ""button-checkmark-menu-item"",
  navTreeButton = ""button-nav-tree"",
  navTableButton = ""button-nav-table"",
  navDeltaButton = ""button-nav-delta"",
  navTimButton = ""button-nav-tim"",
  sidebarCloseButton = ""button-sidebar-close"",
  navUndoButton = ""button-nav-undo"",
  navRedoButton = ""button-nav-redo"",
  navLoadUpdatesButton = ""button-nav-load-update"",

  // Navigation - Webpage
  navCreateProjectButton = ""button-nav-Create Project"",
  navOpenProjectButton = ""button-nav-Open Project"",
  navArtifactViewButton = ""button-nav-Project View"",
  navSettingsButton = ""button-nav-Settings"",

  // Steppers

  stepperContinueButton = ""button-stepper-continue"",
  stepperBackButton = ""button-stepper-back"",

  // Selector Tables

  selectorAddButton = ""button-selector-add"",
  selectorEditButton = ""button-selector-edit"",
  selectorDeleteButton = ""button-selector-delete"",
  selectorSearchInput = ""input-selector-search"",

  // Modals

  modalTitle = ""modal-title"",
  modalCloseButton = ""button-close"",
  confirmModalButton = ""button-confirm-modal"",

  // Account Creation

  newAccountEmailInput = ""input-new-email"",
  newAccountPasswordInput = ""input-new-password"",
  createAccountPageButton = ""button-create-account-redirect"",
  createAccountButton = ""button-create-account"",
  createAccountLoginButton = ""button-create-account-login"",

  // Authentication

  isLoggedIn = ""is-logged-in"",
  emailInput = ""input-email"",
  passwordInput = ""input-password"",
  loginButton = ""button-login"",
  logoutButton = ""button-account-logout"",

  // Account Editing

  accountPage = ""icon-account"",
  passwordCurrentInput = ""input-current-password"",
  passwordNewInput = ""input-new-password"",
  passwordChangeButton = ""button-update-password"",
  accountDeletePasswordInput = ""input-delete-password"",
  accountDeleteButton = ""button-delete-my-account"",

  // Snackbar

  snackbarInfo = ""snackbar-info"",
  snackbarSuccess = ""snackbar-success"",
  snackbarWarning = ""snackbar-warning"",
  snackbarUpdate = ""snackbar-update"",
  snackbarError = ""snackbar-error"",
  snackbarCloseButton = ""button-snackbar-close"",

  // Project Creation

  creationBulkNameInput = ""input-project-name-bulk"",
  creationBulkDescriptionInput = ""input-project-description-bulk"",
  creationBulkFilesInput = ""input-files-bulk"",
  creationEmptyToggle = ""toggle-create-empty-project"",
  creationTimToggle = ""toggle-tim-manage"",
  creationTimArtifactsInput = ""input-tim-artifacts"",
  creationTimTracesInput = ""input-tim-traces"",

  creationStandardNameInput = ""input-project-name-standard"",
  creationStandardDescriptionInput = ""input-project-description-standard"",
  creationStandardFilesInput = ""input-files-panel"",
  creationCreatePanelButton = ""button-create-panel"",
  creationTypeInput = ""input-artifact-type"",
  creationTypeButton = ""button-artifact-type"",
  creationArtifactDeleteButton = ""button-delete-panel"",
  creationEntitiesButton = ""button-file-entities"",
  creationIgnoreErrorsButton = ""button-ignore-errors"",
  creationDeletePanel = ""button-delete-panel"",
  creationFilePanel = ""panel-files"",
  creationUploadButton = ""button-create-project"",
  creationTraceSourceInput = ""input-source-type"",
  creationTraceTargetInput = ""input-target-type"",
  creationTraceCreateButton = ""button-create-trace-matrix"",

  // Jobs

  jobTable = ""job-table"",
  jobStatus = ""job-status"",
  jobProgress = ""job-progress"",
  jobPanel = ""job-panel"",
  jobDeleteButton = ""button-delete-job"",
  jobOpenButton = ""button-open-job"",
  jobLogButton = ""button-job-log"",
  jobLogText = ""text-job-log"",

  // Project Selection

  selectionProjectList = ""table-project"",
  selectionVersionList = ""table-version"",
  selectionSearch = ""input-selector-search"",
  selectionReload = ""button-selector-reload"",

  projectEditModal = ""modal-project-edit"",
  projectEditNameInput = ""input-project-name-modal"",
  projectEditDescriptionInput = ""input-project-description-modal"",
  projectEditSaveButton = ""button-project-save"",

  projectDeleteModal = ""modal-project-delete"",
  projectDeleteNameInput = ""input-project-delete-name"",
  projectDeleteConfirmButton = ""button-project-delete"",

  versionCreateModal = ""modal-version-create"",
  versionCreateMajorButton = ""button-create-major-version"",
  versionCreateMinorButton = ""button-create-minor-version"",
  versionCreateRevisionButton = ""button-create-revision-version"",

  versionUploadFilesInput = ""input-files-version"",
  versionUploadFilesButton = ""button-upload-files"",

  // Artifact View

  artifactFabToggle = ""button-fab-toggle"",
  artifactFabCreateArtifact = ""button-fab-create-artifact"",
  artifactFabCreateTrace = ""button-fab-create-trace"",
  artifactFabDrawTrace = ""button-fab-draw-trace"",

  artifactSaveNameInput = ""input-artifact-name"",
  artifactSaveTypeInput = ""input-artifact-type"",
  artifactSaveBodyInput = ""input-artifact-body"",
  artifactSaveParentInput = ""input-artifact-parent"",
  artifactSaveSubmitButton = ""button-artifact-save"",

  traceSaveSourceInput = ""button-trace-save-source"",
  traceSaveTargetInput = ""button-trace-save-target"",
  traceSaveDirectionsPanel = ""panel-trace-directions"",
  traceSaveDirectionsChip = ""chip-type-direction"",
  traceSaveSubmitButton = ""button-trace-save"",

  traceUnreviewButton = ""button-trace-unreview"",
  traceApproveButton = ""button-trace-approve"",
  traceDeclineButton = ""button-trace-decline"",
  traceDeleteButton = ""button-trace-delete"",

  // Selection Panel

  selectedPanelCloseButton = ""button-close-details"",
  selectedPanelName = ""text-selected-name"",
  selectedPanelType = ""text-selected-type"",
  selectedPanelBody = ""text-selected-body"",
  selectedPanelBodyButton = ""button-artifact-body"",
  selectedPanelEditButton = ""button-artifact-edit"",
  selectedPanelDeleteButton = ""button-artifact-delete"",
  selectedPanelAttributePrefix = ""text-attribute-"",
  selectedPanelAttributeInputPrefix = ""input-attribute-"",

  selectedPanelParents = ""list-selected-parents"",
  selectedPanelParentItem = ""list-selected-parent-item"",
  selectedPanelParentLinkButton = ""button-selected-parent-link"",
  selectedPanelChildren = ""list-selected-children"",
  selectedPanelChildItem = ""list-selected-child-item"",
  selectedPanelChildLinkButton = ""button-selected-child-link"",

  selectedPanelTraceSource = ""panel-trace-link-source"",
  selectedPanelTraceTarget = ""panel-trace-link-target"",

  // Artifact Tree

  artifactTree = ""view-artifact-tree"",
  treeNode = ""tree-node"",
  treeNodeName = ""tree-node-name"",
  treeNodeType = ""tree-node-type"",
  treeSelectedNode = ""tree-node-selected"",

  // Artifact Search

  artifactSearchModeInput = ""input-nav-search-mode"",
  artifactSearchNavInput = ""input-nav-artifact-search"",
  artifactSearchCount = ""text-artifact-search-count"",
  artifactSearchItem = ""text-artifact-search-item"",

  // Type Options

  typeOptionsIconButton = ""button-type-options-icon"",
  artifactTypePanel = ""panel-artifact-type"",
  artifactTypeSavePanel = ""panel-save-artifact-type"",
  artifactLevelOptions = ""panel-artifact-type-options"",

  // Project settings

  projectSettingsDownloadButton = ""button-settings-download"",
  projectSettingsEditButton = ""button-settings-edit"",
  projectSettingsDeleteButton = ""button-settings-delete"",

  projectSettingsAddEmail = ""input-settings-user-email"",
  projectSettingsAddRole = ""input-settings-user-role"",
  projectSettingsAddToProject = ""button-add-user-to-project"",
  projectSettingsEditUserButton = ""button-selector-edit"",
  projectSettingsDeleteUserButton = ""button-selector-delete"",
  projectSettingsTable = ""generic-selector-table"",

  // Project Documents

  documentSelectButton = ""button-document-select-open"",
  documentCreateButton = ""button-document-select-create"",
  documentItemButton = ""button-document-select-item"",
  documentEditButton = ""button-document-select-edit"",
  documentNameInput = ""input-document-name"",
  documentTypeInput = ""input-document-type"",
  documentIncludeTypesInput = ""input-document-include-types"",
  documentArtifactsInput = ""input-document-artifacts"",
  documentIncludeChildrenToggle = ""button-document-include-children"",
  documentChildTypesInput = ""input-document-include-child-types"",
  documentChildArtifactsInput = ""input-document-child-artifacts"",
  documentDeleteButton = ""button-document-delete"",
  documentSaveTypesButton = ""button-save-types"",
  documentSaveArtifactsButton = ""button-save-artifacts"",
  documentSaveButton = ""button-document-save"",

  // Artifact Table

  artifactTable = ""view-artifact-table"",
  artifactTableRowName = ""artifact-table-row-name"",

  artifactTableSortByInput = ""artifact-table-sort-by"",
  artifactTableGroupByInput = ""artifact-table-group-by"",

  artifactTableGroup = ""artifact-table-group"",
  artifactTableGroupType = ""artifact-table-group-type"",
  artifactTableGroupValue = ""artifact-table-group-value"",

  artifactTableListItems = ""button-checkmark-menu-item"",
  artifactTableColumnHeader = ""artifact-table-column-header"",
  artifactTableDeleteArtifactButton = ""button-artifact-delete-icon"",

  artifactTableArtifactWarning = ""artifact-table-artifact-warning"",
  artifactTableArtifactWarningLabel = ""artifact-table-panel-warnings-title"",
  artifactTableEditArtifactRowButton = ""button-artifact-edit-icon"",

  // Trace Matrix Table

  traceMatrixTable = ""view-trace-matrix-table"",

  traceMatrixTableRowTypeInput = ""input-trace-table-row-types"",
  traceMatrixTableColTypeInput = ""input-trace-table-col-types"",

  // Trace Link Generation

  traceLinkTable = ""table-trace-approval"",
  traceLinkTableSortByInput = ""artifact-table-sort-by"",
  traceLinkTableGroupByInput = ""artifact-table-group-by"",
  traceLinkTableApprovalInput = ""input-approval-type"",

  // Project Version
  projectSavingIndicator = ""project-saving-indicator"",

  // Custom Attributes
  addAttributeButton = ""button-add-attribute"",
  attributeKeyInput = ""input-attribute-key"",
  attributeLabelInput = ""input-attribute-label"",
  attributeTypeInput = ""input-attribute-type"",
  attributeOptionsInput = ""input-attribute-options"",
  attributeMinInput = ""input-attribute-min"",
  attributeMaxInput = ""input-attribute-max"",
  attributeDeleteButton = ""button-delete-attribute"",
  attributeSaveButton = ""button-save-attribute"",
  attributeTableItem = ""generic-list-item"",

  attributeTableItemPlusButton = ""button-add-attribute-to-layout"",
  attributeLayoutAddButton = ""button-attribute-layout-add"",
  attributeLayoutNameInput = ""input-attribute-layout-name"",
  attributeLayoutTypeInput = ""input-attribute-layout-artifact-types"",
  attributeLayoutSaveButton = ""button-attribute-layout-save"",
  attributeLayoutDeleteAttributeButton = ""button-attribute-layout-delete-attribute"",
  attributeLayoutDeleteButton = ""button-attribute-layout-delete"",
  attributeLayoutConfirmDeleteButton = ""button-confirm-modal"",

  // Graph Menu
  rightClickAddArtifact = ""button-add-artifact"",
  rightClickAddTrace = ""button-add-trace"",
  rightClickToggleSubtree = ""button-toggle-subtree"",
}
"
cypress/fixtures/constants/index.ts,"export * from ""./project"";
export * from ""./dataCy"";
export * from ""./routes"";
export * from ""./customAttributes"";
"
cypress/fixtures/constants/customAttributes.ts,"export const customAttribute = {
  key: ""testKey"",
  label: ""Test Label"",
  min: ""0"",
  max: ""1000"",
};

export const customLayout = {
  name: ""Test Layout"",
  type: ""{downArrow}{enter}"",
};
"
cypress/fixtures/data/index.ts,"export * from ""./simpleProject"";
export * from ""./miniProject"";
export * from ""./genProject"";
export * from ""./testFiles"";
"
cypress/fixtures/data/genProject/fileMap.ts,"import files from ""./files.json"";

/**
 * A mapping from file name to each of the simple files.
 */
export default {
  tim: files[0],
  design: files[1],
  design2design: files[2],
  design2requirements: files[3],
  requirement: files[4],
  requirement2requirement: files[5],
};
"
cypress/fixtures/data/genProject/index.ts,"export { default as genProjectFiles } from ""./files.json"";
export { default as genProjectFilesMap } from ""./fileMap"";
"
cypress/fixtures/data/testFiles/fileMap.ts,"import files from ""./files.json"";

/**
 * A mapping from file name to each of the simple files.
 */
export default {
  emptyDesign: files[0],
  emptyDesign2Design: files[1],
};
"
cypress/fixtures/data/testFiles/index.ts,"export { default as testFileMap } from ""./fileMap"";
export { default as testFiles } from ""./files.json"";
"
cypress/fixtures/data/simpleProject/fileMap.ts,"import files from ""./files.json"";

/**
 * A mapping from file name to each of the simple files.
 */
export default {
  tim: files[0],
  design: files[1],
  design2design: files[2],
  design2requirements: files[3],
  environmentalassumptions: files[4],
  environmentalassumptions2hazard: files[5],
  hazard: files[6],
  hazard2hazard: files[7],
  requirement: files[8],
  requirement2hazard: files[9],
  requirement2requirement: files[10],
};
"
cypress/fixtures/data/simpleProject/index.ts,"export { default as simpleProjectFiles } from ""./files.json"";
export { default as simpleProjectFilesMap } from ""./fileMap"";
"
cypress/fixtures/data/miniProject/fileMap.ts,"import files from ""./files.json"";

/**
 * A mapping from file name to each of the simple files.
 */
export default {
  tim: files[0],
  design: files[1],
  design2design: files[2],
  design2requirements: files[3],
  requirement: files[4],
  requirement2requirement: files[5],
};
"
cypress/fixtures/data/miniProject/index.ts,"export { default as miniProjectFiles } from ""./files.json"";
export { default as miniProjectFilesMap } from ""./fileMap"";
"
cypress/e2e/visualization/projectTIM/timTreeView.cy.ts,"describe(""TIM Tree View"", () => {
  before(() => {
    cy.initProject();
  });

  beforeEach(() => {
    cy.initProjectVersion().switchToTimView();
  });

  describe(""I can see the TIM tree of a document"", () => {
    it(""Shows all TIM artifact types"", () => {
      cy.getNode(""Design"")
        .should(""be.visible"")
        .within(() => {
          cy.contains(""14 Artifacts"");
        });

      cy.getNode(""Requirement"")
        .should(""be.visible"")
        .within(() => {
          cy.contains(""5 Artifacts"");
        });
    });
  });
});
"
cypress/e2e/visualization/projectDocuments/documents.cy.ts,"import { DataCy } from ""@/fixtures"";

describe(""Documents"", () => {
  before(() => {
    cy.initProject();
  });

  beforeEach(() => {
    cy.dbResetDocuments().initProjectVersion().expandViewport();
  });

  describe(""I can create a new document from artifacts or their types"", () => {
    it(""Cant create a document without a name"", () => {
      cy.createDocument({ name: """" });

      cy.getCy(DataCy.documentSaveButton).should(""be.disabled"");
    });

    it(""Cant create a document with an existing name"", () => {
      const name = ""New Document"";

      // Create a new document.
      cy.createDocument({ name, artifacts: ""F5{downArrow}{enter}"" }, true)
        .getCy(DataCy.snackbarSuccess)
        .should(""be.visible"");

      // Assert that the document cant be named default.
      cy.createDocument({ name: ""All Artifacts"" })
        .getCy(DataCy.documentSaveButton)
        .should(""be.disabled"");

      // Assert that the document cannot have the same name as another.
      cy.inputText(DataCy.documentNameInput, name, true)
        .getCy(DataCy.documentSaveButton)
        .should(""be.disabled"");
    });

    it(""Creates a document from artifacts"", () => {
      cy.createDocument(
        {
          artifacts: ""{downArrow}{enter}{downArrow}{enter}"",
        },
        true
      );

      cy.getCy(DataCy.snackbarSuccess)
        .should(""be.visible"")
        .waitForProjectLoad();
      cy.getNodes().should(""have.length"", 2);
    });

    it(""Creates a document from artifact types"", () => {
      cy.createDocument(
        {
          includeTypes: ""Req{downArrow}{enter}"",
        },
        true
      );

      cy.getCy(DataCy.snackbarSuccess)
        .should(""be.visible"")
        .waitForProjectLoad();
      cy.getNodes().should(""have.length"", 5);
    });
  });

  describe(""I can create a document from a parent artifact and a list of child artifact types"", () => {
    it(""Creates a document with the tree of a parent"", () => {
      cy.createDocument(
        {
          artifacts: ""F5{downArrow}{enter}"",
          includeChildTypes: ""Des{downArrow}{enter}"",
        },
        true
      );

      cy.getCy(DataCy.snackbarSuccess)
        .should(""be.visible"")
        .waitForProjectLoad();
      cy.getNodes().should(""have.length"", 3);
    });
  });

  describe(""I can create a table document"", () => {
    it(""Creates a document and shows the table"", () => {
      cy.createDocument(
        {
          type: ""FMEA"",
          includeTypes: ""Req{downArrow}{enter}"",
        },
        true
      );

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.getCy(DataCy.artifactTable).should(""be.visible"");
    });
  });

  describe(""I can edit a document"", () => {
    it(""Adds new artifacts to a document"", () => {
      const name = `New ${Math.random()}`;

      cy.createDocument(
        {
          name,
          artifacts: ""F5{downArrow}{enter}"",
        },
        true
      );

      cy.getCy(DataCy.snackbarSuccess)
        .should(""be.visible"")
        .waitForProjectLoad();
      cy.getNodes().should(""have.length"", 1);

      cy.openDocumentEditor(name)
        .fillDocumentFields({
          includeChildTypes: ""Des{downArrow}{enter}"",
        })
        .clickButton(DataCy.documentSaveButton);

      cy.getCy(DataCy.snackbarSuccess)
        .should(""be.visible"")
        .waitForProjectLoad();
      cy.getNodes().should(""have.length"", 3);
    });
  });

  describe(""I can delete a document"", () => {
    it(""Deletes a document"", () => {
      const name = `New ${Math.random()}`;

      cy.createDocument(
        {
          name,
          artifacts: ""F5{downArrow}{enter}"",
        },
        true
      );

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.getNodes().should(""have.length"", 1);

      cy.openDocumentEditor(name)
        .clickButton(DataCy.documentDeleteButton)
        .clickButton(DataCy.confirmModalButton);

      cy.getCy(DataCy.snackbarSuccess)
        .should(""be.visible"")
        .waitForProjectLoad();
      cy.getNodes().should(""have.length.above"", 1);
    });
  });

  describe(""I can switch between project documents"", () => {
    it(""Switches to a new document, then back to the default"", () => {
      cy.createDocument(
        {
          artifacts: ""F5{downArrow}{enter}"",
        },
        true
      );

      cy.getCy(DataCy.snackbarSuccess)
        .should(""be.visible"")
        .waitForProjectLoad();
      cy.getNodes().should(""have.length"", 1);

      cy.openDocumentSelector().clickButtonWithName(""All Artifacts"");

      cy.waitForProjectLoad();
      cy.getNodes().should(""have.length.above"", 1);
    });
  });
});
"
cypress/e2e/visualization/artifactTable/traceMatrixView.cy.ts,"import { DataCy } from ""@/fixtures"";

describe(""Trace Matrix Table View"", () => {
  before(() => {
    cy.initProject();
  });

  beforeEach(() => {
    cy.initProjectVersion().switchToTableView(""trace"");
  });

  describe(""I can view artifacts in a trace matrix table"", () => {
    it(""Shows artifacts in a trace matrix"", () => {
      cy.withinTableRows(DataCy.traceMatrixTable, (tr) => {
        // Header row, 2 group rows, 19 artifacts x 2 rows each.
        tr.should(""have.length"", 1 + 2 + 19 * 2);

        // Name, Type, 19 artifacts.
        cy.get(""th"").should(""have.length"", 1 + 1 + 19);
      });
    });
  });

  describe(""I can filter the trace matrix table rows and columns by artifact type"", () => {
    it(""Filters for requirements to designs"", () => {
      cy.filterTraceMatrixTable(""req"", ""des"");

      cy.withinTableRows(DataCy.traceMatrixTable, (tr) => {
        // Header row, 2 virtual scroll, 5 requirement artifacts x 2 rows each, 1 footer.
        tr.should(""have.length"", 1 + 2 + 5 * 2);

        // Name, Type, 14 design artifacts.
        cy.get(""th"").should(""have.length"", 1 + 1 + 14);
      });
    });
  });

  describe(""I can select an artifact to view more details"", () => {
    it(""Selects an artifact that is clicked"", () => {
      const artifactName = ""D1"";

      cy.withinTableRows(DataCy.traceMatrixTable, () => {
        cy.get("".q-tr"").contains(artifactName).click();
      });

      cy.getCy(DataCy.selectedPanelName).should(""contain"", artifactName);
    });
  });

  describe(""I can select a trace link to view more details"", () => {
    it(""Selects a trace link that is clicked"", () => {
      const sourceName = ""D1"";
      const targetName = ""F5"";

      cy.filterTraceMatrixTable(""des"", ""req"");

      cy.withinTableRows(DataCy.traceMatrixTable, () => {
        cy.get("".q-tr"").contains(targetName).click();
      });

      cy.getCy(DataCy.selectedPanelTraceTarget).should(""contain"", targetName);
      cy.getCy(DataCy.selectedPanelTraceSource).should(""contain"", sourceName);
    });
  });
});
"
cypress/e2e/visualization/artifactTable/artifactTableView.cy.ts,"import { DataCy } from ""@/fixtures"";

describe(""Artifact Table View"", () => {
  before(() => {
    cy.initProject();
  });

  beforeEach(() => {
    cy.initProjectVersion().switchToTableView();
  });

  describe(""I can view artifacts in a table"", () => {
    it(""Shows artifacts in a table"", () => {
      cy.withinTableRows(DataCy.artifactTable, (tr) => {
        // 1 Header row, 2 group rows, 19 artifacts x 2 rows each.
        tr.should(""have.length"", 1 + 2 + 19 * 2);

        tr.eq(3).should(""contain.text"", ""D1"");
      });
    });
  });

  describe(""I can sort artifacts by their attributes"", () => {
    it(""Sorts artifacts by type"", () => {
      cy.sortArtifactTable(""type"").groupArtifactTable(""none"");

      cy.withinTableRows(DataCy.artifactTable, (tr) => {
        tr.then(($els) => {
          // 1 Header row, 14 design artifacts, 5 requirement artifacts x 2 rows each.
          const designRowCount = 1 + 14 * 2;
          const $designs = $els.slice(1, designRowCount);
          const $reqs = $els.slice(designRowCount, designRowCount + 5 * 2);

          cy.wrap($designs).each(($el, idx) => {
            if (idx % 2 === 0) return;

            cy.wrap($el).should(""contain"", ""Design"");
          });
          cy.wrap($reqs).each(($el, idx) => {
            if (idx % 2 === 0) return;
            cy.wrap($el).should(""contain"", ""Requirement"");
          });
        });
      });
    });
  });

  describe(""I can group artifacts by their attributes"", () => {
    it(""Groups artifacts by name"", () => {
      cy.sortArtifactTable(""name"").groupArtifactTable(""name"");

      cy.getCy(DataCy.artifactTableGroup)
        .first()
        .within(() => {
          cy.getCy(DataCy.artifactTableGroupType).should(""contain"", ""Name:"");
          cy.getCy(DataCy.artifactTableGroupValue).should(""contain"", ""D1"");
        });
    });
  });

  describe(""I can select an artifact to view more details"", () => {
    it(""Selects an artifact that is clicked"", () => {
      cy.withinTableRows(DataCy.artifactTable, (tr) => {
        tr.contains(""D1"").click();
      });

      cy.getCy(DataCy.selectedPanelName).should(""contain"", ""D1"");
    });
  });
});
"
cypress/e2e/visualization/artifactTree/artifactTreeNodesAndEdges.cy.ts,"import { DataCy } from ""@/fixtures"";

describe(""Artifact Tree Nodes & Edges"", () => {
  before(() => {
    cy.initProject();
  });

  beforeEach(() => {
    cy.initProjectVersion();
  });

  describe(""I can select an artifact to view more details"", () => {
    it(""Selects an artifact that is clicked"", () => {
      cy.centerGraph();

      cy.getNodes().first().click();

      // Affirm node is selected.
      cy.getNodes(true).should(""be.visible"");
      cy.getCy(DataCy.selectedPanelName).should(""be.visible"");
    });
  });

  describe.skip(""I can select a trace link to view more details"", () => {
    it(""Selects a trace link that is clicked"", () => {
      cy.centerGraph();

      cy.getNode(""F6"").then(($el1) => {
        cy.getNode(""D3"").then(($el2) => {
          cy.get(""body"").click(
            Math.abs($el1.position().top - $el2.position().top),
            Math.abs($el1.position().left - $el2.position().left)
          );
        });
      });

      // Affirm edge is selected.
      cy.getCy(DataCy.selectedPanelName).should(""be.visible"");
    });
  });
});
"
cypress/e2e/visualization/artifactTree/artifactTreeWindow.cy.ts,"import { DataCy, Routes } from ""@/fixtures"";

describe(""Artifact Tree Window"", () => {
  before(() => {
    cy.initProject();
  });

  beforeEach(() => {
    cy.initProjectVersion();
  });

  describe(""I can re-center the graph"", () => {
    it(""Makes all nodes centered and visible"", () => {
      cy.centerGraph();
      cy.getNodes().should(""have.length"", 19);
    });
  });

  describe(""I can see the graph interactions load on initial page load"", () => {
    it(""Loads the graph and is responsive"", () => {
      // Assert that right clicking works to know that the graph is responsive.
      cy.centerGraph()
        .getNodes()
        .first()
        .rightclick()
        .getCy(DataCy.rightClickAddArtifact)
        .should(""be.visible"");
    });
  });

  describe(""I can see the graph interactions load on page change"", () => {
    it(""Loads the graph and is responsive"", () => {
      // Visit another page.
      cy.clickButtonWithName(""Create Project"").locationShouldEqual(
        Routes.PROJECT_CREATOR
      );

      // Return to the project page.
      cy.go(""back"")
        .locationShouldEqual(Routes.ARTIFACT)
        .waitForProjectLoad(true);

      // Assert that right clicking works to know that the graph is responsive.
      cy.centerGraph()
        .getNodes()
        .first()
        .rightclick()
        .getCy(DataCy.rightClickAddArtifact)
        .should(""be.visible"");
    });
  });

  describe(""I can see the graph interactions load on artifact view change"", () => {
    it(""Loads the graph and is responsive"", () => {
      // Toggle back and forth to the artifact table.
      cy.clickButton(DataCy.navTableButton)
        .clickButton(DataCy.navTreeButton)
        .getCy(DataCy.appLoading)
        .should(""not.exist"");

      // Assert that right clicking works to know that the graph is responsive.
      cy.centerGraph()
        .getNodes()
        .first()
        .rightclick()
        .getCy(DataCy.rightClickAddArtifact)
        .should(""be.visible"");
    });
  });

  describe.skip(""I can filter the visibility of artifacts by type"", () => {
    it(""Fades out filtered artifacts"", () => {
      cy.clickButton(DataCy.navGraphFilterButton);

      cy.getCy(DataCy.navGraphFilterOption)
        .filter("":visible"")
        .each((el) => cy.wrap(el).click());

      cy.centerGraph().getNodes().should(""have.css"", ""opacity"", ""0.3"");
    });
  });
});
"
cypress/e2e/visualization/artifactTree/artifactSubtree.cy.ts,"import { DataCy } from ""@/fixtures"";

describe(""Artifact Subtree"", () => {
  before(() => {
    cy.initProject();
  });

  beforeEach(() => {
    cy.initProjectVersion();
  });

  describe(""I can highlight an artifacts subtree"", () => {
    it(""Highlights the selected subtree"", () => {
      cy.selectArtifact(""F11"");

      // Selected node is visible.
      cy.getNodes(true)
        .should(""be.visible"")
        .should(""not.have.css"", ""opacity"", ""0.3"");

      // Subtree nodes are visible.
      cy.getNode(""F9"").should(""not.have.css"", ""opacity"", ""0.3"");
      cy.getNode(""F15"").should(""not.have.css"", ""opacity"", ""0.3"");
      cy.getNode(""F17"").should(""not.have.css"", ""opacity"", ""0.3"");

      // Unrelated node is faded.
      cy.getNode(""D5"").should(""have.css"", ""opacity"", ""0.3"");
    });
  });

  describe(""I can hide an artifacts subtree"", () => {
    it(""Hides the subtree below an artifact"", () => {
      cy.centerGraph();

      // Assert that child node exists.
      cy.getNode(""F17"").should(""be.visible"");

      // Open the right click menu on the selected node, click to hide subtree.
      cy.getNode(""F11"").click().clickButton(DataCy.rightClickToggleSubtree);

      // Assert that subtree is hidden.
      cy.getNode(""F17"").should(""not.be.visible"");
    });
  });

  describe(""I can show an artifacts subtree"", () => {
    it(""Shows the subtree below an artifact"", () => {
      cy.centerGraph();

      // Open the right click menu on the selected node, click to hide subtree.
      cy.getNode(""F11"").click().clickButton(DataCy.rightClickToggleSubtree);

      // Assert that subtree is hidden.
      cy.getNode(""F17"").should(""not.be.visible"");

      // Open the right click menu on the selected node, click to show subtree.
      cy.getNode(""F11"")
        .rightclick()
        .getCy(DataCy.rightClickToggleSubtree)
        .should(""be.visible"")
        .then(($el) => $el.click());

      // Assert that subtree is visible.
      cy.getNode(""F17"").should(""be.visible"");
    });
  });

  describe(""I can see how many children are hidden below a parent artifact"", () => {
    it(""Shows the number of hidden children"", () => {
      cy.centerGraph();

      // Open the right click menu on the selected node, click to hide subtree.
      cy.getNode(""F11"").click().clickButton(DataCy.rightClickToggleSubtree);

      // Assert that hidden children has correct count.
      cy.getNode(""F11"").should(""have.attr"", ""data-cy-children"", ""6"");
    });
  });
});
"
cypress/e2e/security/authentication/accountCreation.cy.ts,"import { DataCy, Routes } from ""@/fixtures"";

const { createUser, validUser } = Cypress.env();

describe(""Account Creation"", () => {
  beforeEach(() => {
    cy.visit(Routes.LOGIN_ACCOUNT);
  });

  describe(""I can create an account with an unused email"", () => {
    it(""Creates an account successfully"", () => {
      cy.clickButton(DataCy.createAccountPageButton).locationShouldEqual(
        Routes.CREATE_ACCOUNT
      );

      cy.inputText(DataCy.newAccountEmailInput, createUser.email)
        .inputText(DataCy.newAccountPasswordInput, createUser.password)
        .clickButton(DataCy.createAccountButton);

      cy.contains(""p"", ""Your account has been successfully created."").should(
        ""be.visible""
      );

      cy.dbDeleteUser(createUser.email, createUser.password);
    });
  });

  describe(""I cant create an account with an email that has already been used"", () => {
    it(""Disables account creation"", () => {
      cy.clickButton(DataCy.createAccountPageButton).locationShouldEqual(
        Routes.CREATE_ACCOUNT
      );

      cy.inputText(DataCy.newAccountEmailInput, validUser.email)
        .inputText(DataCy.newAccountPasswordInput, validUser.password)
        .clickButton(DataCy.createAccountButton);

      cy.contains(""Unable to create an account"").should(""be.visible"");
    });
  });
});
"
cypress/e2e/security/authentication/accountEditing.cy.ts,"import { Routes, DataCy } from ""@/fixtures"";

const { invalidUser, editUser, deleteUser } = Cypress.env();

describe(""Account Editing"", () => {
  describe(""I can edit my password while logged in"", () => {
    beforeEach(() => {
      cy.loginToPage(editUser.email, editUser.password, Routes.ACCOUNT);
    });

    it(""Should not be able to change my password without an old and new password set"", () => {
      cy.getCy(DataCy.passwordChangeButton).should(""be.disabled"");
    });

    it(""Should not be able to change my password with an invalid current password"", () => {
      cy.inputText(DataCy.passwordCurrentInput, invalidUser.password)
        .inputText(DataCy.passwordNewInput, editUser.newPassword)
        .clickButton(DataCy.passwordChangeButton);

      cy.getCy(DataCy.snackbarError).should(""be.visible"");

      // Test that the password was not changed.
      cy.logout();
      cy.login(editUser.email, editUser.newPassword);
      cy.locationShouldEqual(Routes.LOGIN_ACCOUNT);
      cy.contains(""Invalid username or password"");
    });

    it(""Should be able to change my password with the correct current password"", () => {
      // Set the password to a new value.
      cy.inputText(DataCy.passwordCurrentInput, editUser.password)
        .inputText(DataCy.passwordNewInput, editUser.newPassword)
        .clickButton(DataCy.passwordChangeButton);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");

      // Test that the password was changed.
      cy.logout()
        .visit(Routes.ACCOUNT)
        .login(editUser.email, editUser.newPassword)
        .locationShouldEqual(Routes.ACCOUNT);

      // Revert the password value.
      cy.inputText(DataCy.passwordCurrentInput, editUser.newPassword)
        .inputText(DataCy.passwordNewInput, editUser.password)
        .clickButton(DataCy.passwordChangeButton);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
    });
  });

  describe(""I can delete my account"", () => {
    it(""Cannot delete my account with an invalid password"", () => {
      cy.loginToPage(editUser.email, editUser.password, Routes.ACCOUNT);

      cy.inputText(DataCy.accountDeletePasswordInput, invalidUser.password)
        .clickButton(DataCy.accountDeleteButton)
        .clickButton(DataCy.confirmModalButton);

      cy.getCy(DataCy.snackbarError).should(""be.visible"");
      cy.logout()
        .login(editUser.email, editUser.password)
        .should(""not.contain"", ""Invalid username or password"");
    });

    it(""Successfully deletes my account"", () => {
      cy.createNewAccount(deleteUser.email, deleteUser.password);

      cy.visit(Routes.ACCOUNT);

      cy.inputText(DataCy.accountDeletePasswordInput, deleteUser.password)
        .clickButton(DataCy.accountDeleteButton)
        .clickButton(DataCy.confirmModalButton);

      cy.locationShouldEqual(Routes.LOGIN_ACCOUNT);

      // Try to login with the deleted account.
      cy.login(deleteUser.email, deleteUser.password);
      cy.contains(""Invalid username or password"");
    });
  });
});
"
cypress/e2e/security/authentication/accountLogin.cy.ts,"import { DataCy, Routes } from ""@/fixtures"";

const { invalidUser, validUser } = Cypress.env();

describe(""Account Login"", () => {
  beforeEach(() => {
    cy.visit(Routes.LOGIN_ACCOUNT);
  });

  describe(""I cannot enter credentials without both an email and password"", () => {
    it(""Disables login"", () => {
      cy.inputText(DataCy.emailInput, validUser.email);

      cy.getCy(DataCy.loginButton).should(""be.disabled"");
    });
  });

  describe(""I cant log in with invalid credentials"", () => {
    it(""Fails to log in"", () => {
      cy.inputText(DataCy.emailInput, invalidUser.email).inputText(
        DataCy.passwordInput,
        invalidUser.password
      );

      cy.getCy(DataCy.isLoggedIn).should(""not.exist"");
    });
  });

  describe(""I can log in with valid credentials"", () => {
    it(""Logs in successfully"", () => {
      cy.login(validUser.email, validUser.password);

      cy.getCy(DataCy.isLoggedIn).should(""exist"");
    });
  });

  describe(""I can log out"", () => {
    it(""Logs out successfully"", () => {
      cy.login(validUser.email, validUser.password).logout();

      cy.getCy(DataCy.loginButton).should(""exist"");

      cy.visit(Routes.ACCOUNT);

      cy.getCy(DataCy.loginButton).should(""exist"");
    });
  });

  // describe.skip(""When I log out, all stored project information is cleared"", () => {});
});
"
cypress/e2e/dataImportAndExport/projectSelection/projectVersionList.cy.ts,"import { DataCy, Routes } from ""@/fixtures"";

const validUser = Cypress.env(""validUser"");

describe(""Project Version List"", () => {
  before(() => {
    cy.initProject().clearAllCookies();
  });

  beforeEach(() => {
    cy.expandViewport().loginToPage(
      validUser.email,
      validUser.password,
      Routes.MY_PROJECTS
    );
  });

  describe(""I can select and load a version of the project"", () => {
    it(""Cannot continue if a version is not selected"", () => {
      cy.projectSelectorContinue(""project"");

      cy.getCy(DataCy.stepperContinueButton).should(""be.disabled"");
    });

    it(""Selects and loads a project and version"", () => {
      cy.projectSelectorContinue(""project"").projectSelectorContinue(""version"");

      cy.getCy(DataCy.appLoading).should(""not.exist"");
      cy.clickButton(DataCy.navTreeButton);
      cy.waitForProjectLoad(true);
    });
  });
});
"
cypress/e2e/dataImportAndExport/projectSelection/projectList.cy.ts,"import { DataCy, Routes, testProject } from ""@/fixtures"";

const validUser = Cypress.env(""validUser"");

describe(""Project List"", () => {
  before(() => {
    cy.initEmptyProject().clearAllCookies();
  });

  beforeEach(() => {
    cy.viewport(1080, 1080);
    cy.loginToPage(validUser.email, validUser.password, Routes.MY_PROJECTS);
  });

  describe(""I can search for projects by name"", () => {
    it(""Filters for projects that match my search"", () => {
      cy.inputText(DataCy.selectionSearch, testProject.name);

      cy.withinTableRows(DataCy.selectionProjectList, (tr) =>
        tr.should(""contain.text"", testProject.name)
      );
    });

    it(""Displays no projects when none match"", () => {
      cy.inputText(DataCy.selectionSearch, ""$"".repeat(20));

      cy.withinTableRows(DataCy.selectionProjectList, (tr) => {
        tr.should(""have.length"", 1);
      });
    });
  });

  describe(""I can select a project to see its versions"", () => {
    it(""Selects a project and continues to the version step"", () => {
      cy.projectSelectorContinue(""project"");

      cy.getCy(DataCy.stepperBackButton).should(""not.be.disabled"");
    });

    it(""Cannot continue without a project selected"", () => {
      cy.getCy(DataCy.stepperContinueButton).should(""be.disabled"");
    });
  });
});
"
cypress/e2e/dataImportAndExport/projectCreation/standardProjectCreation.cy.ts,"import {
  DataCy,
  Routes,
  simpleProjectFilesMap,
  testFileMap,
  testProject,
} from ""@/fixtures"";

const validUser = Cypress.env(""validUser"");

describe(""Standard Project Creation"", () => {
  beforeEach(() => {
    cy.dbResetJobs().dbResetProjects();

    cy.loginToPage(validUser.email, validUser.password, Routes.PROJECT_CREATOR);
  });

  describe(""Project Artifact Uploading"", () => {
    it(""Cannot create a project without a name"", () => {
      cy.inputText(
        DataCy.creationStandardDescriptionInput,
        testProject.description
      );

      cy.getCy(DataCy.stepperContinueButton).should(""be.disabled"");
    });

    describe(""I can create sets of artifacts by type"", () => {
      it(""Cannot create a new panel with an empty name"", () => {
        // Step - Inputs Project name and description
        cy.setProjectIdentifier(""standard"");

        cy.getCy(DataCy.stepperContinueButton).should(""be.disabled"");
      });

      it(""Can create a new panel of artifacts"", () => {
        cy.setProjectIdentifier(""standard"").createArtifactPanel(
          ""hazard"",
          simpleProjectFilesMap.hazard
        );

        cy.getCy(DataCy.creationFilePanel).should(""be.visible"");
      });
    });

    describe(""I can delete artifacts"", () => {
      it(""Can delete artifacts"", () => {
        cy.setProjectIdentifier(""standard"").createArtifactPanel(
          ""hazard"",
          simpleProjectFilesMap.hazard
        );

        cy.openPanelAfterClose().clickButton(
          DataCy.creationArtifactDeleteButton,
          ""first"",
          true
        );

        cy.getCy(DataCy.creationFilePanel).should(""not.exist"");
      });
    });

    describe(""I can preview the list of artifacts loaded from a file"", () => {
      it(""Displays buttons for all of the artifacts in the file"", () => {
        cy.setProjectIdentifier(""standard"").createArtifactPanel(
          ""hazard"",
          simpleProjectFilesMap.hazard
        );

        cy.getCy(DataCy.creationDeletePanel).should(""not.be.visible"");

        cy.openPanelAfterClose()
          .clickButtonWithName(""Parsed Entities"")
          .getCy(DataCy.creationEntitiesButton)
          .should(""have.length"", 5);
      });
    });

    describe(""I can upload a file containing the artifacts I want to create"", () => {
      it(""Can continue after uploading artifacts"", () => {
        cy.setProjectIdentifier(""standard"").createArtifactPanel(
          ""hazard"",
          simpleProjectFilesMap.hazard
        );

        cy.getCy(DataCy.stepperContinueButton).should(""not.be.disabled"");
      });

      it(""Can continue with bad file if errors are ignored"", () => {
        cy.setProjectIdentifier(""standard"").createArtifactPanel(
          ""requirement"",
          simpleProjectFilesMap.requirement2requirement
        );

        cy.clickButton(DataCy.creationIgnoreErrorsButton, undefined);

        cy.getCy(DataCy.stepperContinueButton).should(""not.be.disabled"");
      });
    });
  });

  describe(""Project Trace Link Uploading"", () => {
    describe(""I can create sets of trace links between two artifact types"", () => {
      it(""Can create a new panel of trace links"", () => {
        cy.createReqToHazardFiles().createTraceMatrix(""requirement"", ""hazard"");

        cy.getCy(DataCy.creationFilePanel).should(""be.visible"");
      });

      it(""Cannot create a new panel without selecting two artifact types"", () => {
        cy.createReqToHazardFiles();

        cy.getCy(DataCy.stepperContinueButton).should(""be.disabled"");
      });
    });

    describe(""I can delete a set of trace links"", () => {
      it(""Can delete a set of trace links"", () => {
        cy.createReqToHazardFiles(true);

        cy.getCy(DataCy.creationDeletePanel)
          .should(""not.be.visible"")
          .openPanelAfterClose();
        cy.clickButton(DataCy.creationDeletePanel);

        cy.contains(""requirement to hazard"").should(""not.exist"");
      });
    });

    describe(""I can preview the list of trace links loaded from a file"", () => {
      it(""Displays buttons for all of the trace links in the file"", () => {
        cy.createReqToHazardFiles(true);

        cy.getCy(DataCy.creationDeletePanel).should(""not.be.visible"");

        cy.openPanelAfterClose()
          .clickButtonWithName(""Parsed Entities"")
          .getCy(DataCy.creationEntitiesButton)
          .should(""have.length"", 5);
      });
    });

    describe(""I can upload a file containing the trace links I want to create"", () => {
      it(""Can continue with no trace links"", () => {
        cy.setProjectIdentifier(""standard"");

        cy.createArtifactPanel(
          ""Empty Design"",
          testFileMap.emptyDesign2Design
        ).clickButton(DataCy.creationIgnoreErrorsButton, undefined);

        cy.createArtifactPanel(""Empty design"", testFileMap.emptyDesign, true);

        cy.createTraceMatrix(
          ""design"",
          ""design"",
          testFileMap.emptyDesign2Design
        );

        cy.getCy(DataCy.stepperContinueButton).should(""not.be.disabled"");
      });

      it(""Can continue after uploading trace links"", () => {
        cy.createReqToHazardFiles(true);

        cy.getCy(DataCy.stepperContinueButton).should(""not.be.disabled"");
      });

      it(""Can continue with a bad file if errors are ignored"", () => {
        cy.createReqToHazardFiles().createTraceMatrix(""hazard"", ""requirement"");

        cy.getCy(DataCy.stepperContinueButton).should(""be.disabled"");

        cy.uploadFiles(
          DataCy.creationStandardFilesInput,
          simpleProjectFilesMap.tim
        );

        cy.clickButton(DataCy.creationIgnoreErrorsButton, ""last"");

        cy.getCy(DataCy.stepperContinueButton).should(""not.be.disabled"");
      });
    });

    describe(""I can generate trace links between artifacts"", () => {
      it(""Can continue with trace links set to be generated"", () => {
        cy.createReqToHazardFiles().createTraceMatrix(""requirement"", ""hazard"");

        cy.openPanelAfterClose();

        cy.clickButtonWithName(""Generate Trace Links"");

        cy.getCy(DataCy.stepperContinueButton).should(""not.be.disabled"");
      });
    });
  });

  describe.skip(""TIM Preview"", () => {
    describe(""I can view the TIM of a project being created"", () => {
      it(""Displays all nodes on the graph"", () => {
        cy.createReqToHazardFiles(true, true);

        cy.getCy(""tim-node"")
          .should(""be.visible"")
          .within(() => {
            cy.contains(""requirement"").should(""be.visible"");
            cy.contains(""hazard"").should(""be.visible"");
            cy.contains(""5 Nodes"").should(""be.visible"");
          });
      });
    });
  });

  describe(""I can manually create a Project"", () => {
    it(""Can create a project with valid data"", () => {
      cy.createReqToHazardFiles(true, true).clickButton(
        DataCy.stepperContinueButton
      );

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.waitForJobLoad();
    });
  });
});
"
cypress/e2e/dataImportAndExport/projectCreation/bulkProjectCreation.cy.ts,"import {
  simpleProjectFiles,
  simpleProjectFilesMap,
  DataCy,
  testProject,
  Routes,
} from ""@/fixtures"";

const validUser = Cypress.env(""validUser"");

describe(""Bulk Project Creation"", () => {
  before(() => {
    cy.dbResetJobs().dbResetProjects();
  });

  beforeEach(() => {
    cy.viewport(1920, 1080);
    cy.loginToPage(
      validUser.email,
      validUser.password,
      Routes.PROJECT_CREATOR,
      { tab: ""bulk"" }
    );
  });

  describe(""I cannot create a project without a name"", () => {
    it(""Cant create a project without a name"", () => {
      cy.inputText(
        DataCy.creationBulkDescriptionInput,
        testProject.name
      ).uploadFiles(DataCy.creationBulkFilesInput, simpleProjectFilesMap.tim);

      cy.getCy(DataCy.creationUploadButton).should(""be.disabled"");
    });
  });

  describe(""I can create an empty project"", () => {
    it(""Can create an empty project on the bulk upload tab"", () => {
      cy.setProjectIdentifier(""bulk"");

      cy.getCy(DataCy.creationUploadButton).should(""be.disabled"");

      cy.clickButton(DataCy.creationEmptyToggle).clickButton(
        DataCy.creationUploadButton
      );

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
    });

    it(""Can create an empty project in the project selector"", () => {
      cy.openProjectSelector().clickButton(DataCy.selectorAddButton);

      cy.setProjectIdentifier(""modal"")
        .clickButton(DataCy.creationEmptyToggle)
        .clickButton(DataCy.creationUploadButton);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
    });
  });

  describe(""I can generate a TIM configuration file"", () => {
    it(""Generates a missing TIM file"", () => {
      cy.setProjectIdentifier(""bulk"").uploadFiles(
        DataCy.creationBulkFilesInput,
        ...simpleProjectFiles.filter((name) => !name.includes(""tim""))
      );

      cy.getCy(DataCy.creationUploadButton).should(""be.disabled"");

      cy.clickButton(DataCy.creationTimToggle);

      cy.getCy(DataCy.creationTimToggle).within(() =>
        cy
          .getCy(DataCy.creationTimArtifactsInput)
          .parent()
          .click()
          .type(""design{downArrow}{enter}"")
      );

      cy.getCy(DataCy.creationUploadButton).should(""not.be.disabled"");
    });
  });

  describe(""I can create a project from flat files"", () => {
    it(""Can create a valid project"", () => {
      cy.setProjectIdentifier(""bulk"")
        .uploadFiles(DataCy.creationBulkFilesInput, ...simpleProjectFiles)
        .clickButton(DataCy.creationUploadButton);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
    });
  });
});
"
cypress/e2e/dataImportAndExport/projectCreation/jobSubmission.cy.ts,"import { DataCy } from ""@/fixtures"";

describe(""Job Submission"", () => {
  beforeEach(() => {
    cy.viewport(1080, 1080);
    cy.initProject(false);
  });

  describe(""I can create a job"", () => {
    it(""Shows the current job is completed"", () => {
      cy.waitForJobLoad();
    });
  });

  describe(""I can see the jobs I created"", () => {
    it(""Shows a list of imported projects"", () => {
      cy.clickButtonWithName(""Project Uploads"");
      cy.waitForJobLoad();

      cy.withinTableRows(
        DataCy.jobTable,
        (tr) => {
          tr.should(""have.length.above"", 1);
        },
        false
      );
    });
  });

  describe(""I can delete a logged job"", () => {
    it.only(""Deletes a project from the list"", () => {
      cy.waitForJobLoad();

      cy.clickButton(DataCy.jobDeleteButton);

      cy.withinTableRows(
        DataCy.jobTable,
        (tr) => {
          tr.should(""have.length"", 1);
        },
        false
      );

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
    });
  });
});
"
cypress/e2e/dataImportAndExport/projectCreation/jobStatus.cy.ts,"import { DataCy, Routes } from ""@/fixtures"";

describe(""Job Status"", () => {
  beforeEach(() => {
    cy.viewport(1080, 1080);
    cy.initProject(false);
    cy.locationShouldEqual(Routes.UPLOAD_STATUS);
  });

  afterEach(() => {
    cy.waitForJobLoad();
  });

  describe(""I can see the current status and progress of a job"", () => {
    it(""Shows in progress jobs"", () => {
      cy.contains(""Project Uploads"");
      cy.getCy(DataCy.jobStatus, ""first"").should(""contain.text"", ""In Progress"");
    });

    it(""Shows completed jobs"", () => {
      cy.getCy(DataCy.jobStatus, ""first"", 10000).should(
        ""contain.text"",
        ""Completed""
      );
    });
  });

  describe(""I can see real-time job updates"", () => {
    it(""Shows the progress updating"", () => {
      cy.getCy(DataCy.jobOpenButton, ""first"", 10000).should(""be.disabled"");
      cy.getCy(DataCy.jobOpenButton, ""first"", 10000).should(""not.be.disabled"");
    });
  });

  describe(""I can see the logs occurring during my job"", () => {
    it(""Shows the job logs"", () => {
      cy.clickButton(DataCy.jobLogButton, ""first"");

      cy.getCy(DataCy.jobLogText).should(""be.visible"");
    });
  });
});
"
cypress/e2e/projectManagement/artifactCustomAttributes/customAttributesLayout.cy.ts,"import { DataCy, customAttribute, customLayout } from ""@/fixtures"";

describe(""Custom Attributes Layout"", () => {
  beforeEach(() => {
    cy.initProject().initProjectVersion();

    // Visit custom attributes tab.
    cy.clickButton(DataCy.navSettingsButton).switchTab(""Custom Attributes"");

    // Create a custom attribute and layout.
    cy.createCustomAttribute(customAttribute)
      .createCustomLayout(customLayout)
      .wait(1000); // Wait to switch to the new layout tab.
  });

  describe(""I can add a new attribute layout"", () => {
    it(""Adds a new custom attribute and creates a layout for it"", () => {
      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.clickButtonWithName(customLayout.name)
        .should(""be.visible"")
        .and(""contain"", customLayout.name);
    });
  });

  describe(""I can edit an attribute layout"", () => {
    it(""Creates a custom attribute and layout and edits the layout"", () => {
      cy.inputText(
        DataCy.attributeLayoutNameInput,
        ""Edited Layout"",
        true
      ).clickButton(DataCy.attributeLayoutSaveButton);

      // Verify that the layout was edited.
      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.clickButtonWithName(""Edited Layout"")
        .should(""be.visible"")
        .and(""contain"", ""Edited Layout"");
    });
  });

  describe(""I can delete an attribute layout"", () => {
    it(""Creates a custom attribute and layout and deletes the layout"", () => {
      cy.clickButton(DataCy.attributeLayoutDeleteButton).clickButton(
        DataCy.attributeLayoutConfirmDeleteButton
      );

      // Verify that the layout was deleted
      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
    });
  });

  describe(""I can see different layouts of custom attributes based on an artifact's type"", () => {
    it(""Verifies that the layout is applied only to the artifact of the correct type"", () => {
      cy.clickButton(DataCy.navArtifactViewButton).clickButton(
        DataCy.navTableButton
      );

      // The default layout applies to designs.
      cy.clickButtonWithName(""D1"");

      cy.getCy(
        DataCy.selectedPanelAttributePrefix + customAttribute.key
      ).should(""exist"");

      // The default layout does not apply to requirements.
      cy.clickButtonWithName(""F10"");

      cy.getCy(
        DataCy.selectedPanelAttributePrefix + customAttribute.key
      ).should(""not.exist"");
    });
  });
});
"
cypress/e2e/projectManagement/artifactCustomAttributes/customAttributesValues.cy.ts,"import { DataCy, customAttribute, customLayout } from ""@/fixtures"";

describe(""Custom Attributes Values"", () => {
  beforeEach(() => {
    cy.initProject().initProjectVersion();

    // Visit custom attributes tab.
    cy.clickButton(DataCy.navSettingsButton).switchTab(""Custom Attributes"");

    // Create an attribute and layout.
    cy.createCustomAttribute(customAttribute).createCustomLayout({
      ...customLayout,
      type: ""{enter}"",
    });

    // View a node on the graph.
    cy.clickButton(DataCy.navArtifactViewButton)
      .clickButton(DataCy.navTableButton)
      .clickButtonWithName(""F10"");
  });

  describe(""I can see custom attributes values on artifacts"", () => {
    it(""Views a custom attribute on an artifact"", () => {
      cy.getCy(
        DataCy.selectedPanelAttributePrefix + customAttribute.key
      ).should(""exist"");
    });
  });

  describe(""I can edit custom attribute values on artifacts"", () => {
    it(""Edits a custom attribute from an artifact"", () => {
      const testValue = ""Test Value"";

      cy.clickButton(DataCy.selectedPanelEditButton);

      cy.inputText(
        DataCy.selectedPanelAttributeInputPrefix + customAttribute.key,
        testValue,
        false,
        true
      );

      cy.clickButton(DataCy.artifactSaveSubmitButton);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.getCy(
        DataCy.selectedPanelAttributePrefix + customAttribute.key
      ).should(""contain.text"", testValue);
    });
  });

  // describe.skip(""I can import artifact custom attribute from CSV or JSON"", () => {
  //   it(""Imports custom attributes from CSV and verifies that elements are present"", () => {});
  //   it(""Imports custom attributes from JSON and verifies that elements are present"", () => {});
  // });
  //
  // describe.skip(""I can export artifact custom attribute to CSV or JSON"", () => {
  //   it(""Creates custom attributes and exports them to CSV"", () => {});
  //   it(""Creates custom attributes and exports them to JSON"", () => {});
  // });
});
"
cypress/e2e/projectManagement/artifactCustomAttributes/customAttributes.cy.ts,"import { DataCy, customAttribute } from ""@/fixtures"";
describe(""Custom Attributes"", () => {
  beforeEach(() => {
    cy.initProject().initProjectVersion();

    // Visit custom attributes tab.
    cy.clickButton(DataCy.navSettingsButton).switchTab(""Custom Attributes"");
  });

  describe(""I can add a custom attribute to my project"", () => {
    it(""Adds a custom attribute to the project"", () => {
      cy.createCustomAttribute(customAttribute);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.getCy(DataCy.attributeTableItem).should(""be.visible"");
    });
  });

  describe(""I can edit a custom attribute on my project"", () => {
    it(""Creates a custom attribute and edits it"", () => {
      cy.createCustomAttribute(customAttribute);

      cy.clickButtonWithName(customAttribute.label)
        .inputText(DataCy.attributeLabelInput, ""New Label"", true)
        .clickButton(DataCy.attributeSaveButton);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.getCy(DataCy.attributeTableItem).should(""contain"", ""New Label"");
    });
  });

  describe(""I can delete a custom attribute on my project"", () => {
    it(""Creates a custom attribute and deletes it"", () => {
      cy.createCustomAttribute(customAttribute);

      cy.clickButtonWithName(customAttribute.label)
        .clickButton(DataCy.attributeDeleteButton)
        .clickButton(DataCy.confirmModalButton);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.getCy(DataCy.attributeTableItem).should(""not.exist"");
    });
  });

  // describe.skip(""I can generate FMEA attributes for traced artifact children"", () => {});

  describe(""I cannot change the key or data type of a custom attribute"", () => {
    it(""Creates a custom attribute and checks that the key and data type are disabled"", () => {
      cy.createCustomAttribute(customAttribute);

      cy.clickButtonWithName(customAttribute.label);

      cy.getCy(DataCy.attributeKeyInput).should(""be.disabled"");

      // Workaround for Quasar select input being designed weirdly.
      cy.getCy(DataCy.attributeTypeInput)
        .parent()
        .parent()
        .parent()
        .parent()
        .should(""have.class"", ""q-field--disabled"");
    });
  });
});
"
cypress/e2e/projectManagement/projectArtifactTypes/artifactTypes.cy.ts,"import { DataCy } from ""@/fixtures"";

describe(""Artifact Types"", () => {
  before(() => {
    cy.initProject();
  });

  beforeEach(() => {
    cy.initProjectVersion();
  });

  describe(""I can add a new artifact type when creating a new artifact"", () => {
    it(""Creates an artifact with a new type"", () => {
      const type = ""New Type"";

      cy.createNewArtifact({ type: `${type}{enter}` }, true);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.getCy(DataCy.selectedPanelType).should(""contain"", type);

      cy.clickButton(DataCy.selectedPanelCloseButton).switchToTimView();

      cy.getNode(type).should(""be.visible"");

      cy.switchToTimView();

      cy.getNode(type).should(""be.visible"");
    });
  });

  describe(""I can change the icon of an artifact type"", () => {
    it(""Changes the icon of a type"", () => {
      const type = ""Design"";

      cy.switchToTimView();

      cy.getNode(type).click();
      cy.clickButtonWithName(""Edit Type"");

      cy.getCy(DataCy.typeOptionsIconButton).within(() => {
        cy.get(""button"").last().click();
      });

      cy.getCy(DataCy.artifactTypeSavePanel).within(() => {
        cy.get(""i"").last().should(""have.class"", ""mdi-book-open"");
      });
    });
  });
});
"
cypress/e2e/projectManagement/projectArtifactTypes/artifactTypeDirections.cy.ts,"import { DataCy } from ""@/fixtures"";

describe(""Artifact Type Directions"", () => {
  before(() => {
    cy.initProject();
  });

  beforeEach(() => {
    cy.initProjectVersion();
  });

  describe(""I cannot create trace links between types in both directions"", () => {
    it(""Cannot create links from an artifact to itself"", () => {
      cy.createNewTraceLink()
        .getCy(DataCy.traceSaveSubmitButton)
        .should(""be.disabled"");
    });

    it(""Cannot create an existing link"", () => {
      cy.createNewTraceLink(""F15"", ""F9"")
        .getCy(DataCy.traceSaveSubmitButton)
        .should(""be.disabled"");
    });

    it(""Cannot create a link in an invalid direction"", () => {
      cy.createNewTraceLink(""F5"", ""D9"")
        .getCy(DataCy.traceSaveSubmitButton)
        .should(""be.disabled"");
    });
  });

  describe(""I can remove a rule on what types of artifacts a trace link is allowed between"", () => {
    it.only(""Can create a link after removing the rule blocking it"", () => {
      cy.clickButton(DataCy.artifactFabToggle).clickButton(
        DataCy.artifactFabCreateTrace
      );

      cy.inputText(DataCy.traceSaveSourceInput, `F5{downArrow}{enter}`);

      // Show hidden types.
      cy.clickButton(DataCy.traceSaveTargetInput)
        .getCy(""button-filter-type"")
        .filter("":visible"")
        .filter("".nav-mode-selected"")
        .each(($el) => $el.click());

      cy.inputText(DataCy.traceSaveTargetInput, `D9{downArrow}{enter}{esc}`);

      cy.getCy(DataCy.traceSaveSubmitButton).should(""be.disabled"");

      // Delete the first link direction.
      cy.clickButton(DataCy.traceSaveDirectionsPanel);

      cy.getCy(DataCy.traceSaveDirectionsChip).each((el) => {
        cy.wrap(el).within(() => {
          cy.get(""i"").click({ multiple: true });
        });
      });

      cy.getCy(DataCy.traceSaveSubmitButton).should(""be.enabled"");
    });
  });
});
"
cypress/e2e/projectManagement/projectMembership/projectMembersDisplay.cy.ts,"import { DataCy } from ""@/fixtures"";

const inviteUser = Cypress.env(""inviteUser"");

describe(""Project Members Display"", () => {
  before(() => {
    cy.initEmptyProject().initProjectVersion(false).openProjectSettings();

    cy.projectAddNewMember(inviteUser.email, ""Admin"");
  });

  beforeEach(() => {
    cy.initProjectVersion(false);
    cy.getCy(DataCy.appLoading).should(""not.exist"");
    cy.openProjectSettings();
  });

  describe(""I can search through a projects members"", () => {
    it(""Can search for a specific member"", () => {
      cy.getCy(DataCy.selectorSearchInput).first().type(inviteUser.email);

      cy.withinTableRows(DataCy.projectSettingsTable, (tr) => {
        tr.contains(inviteUser.email).should(""have.length"", 1);
      });
    });
  });

  describe(""I can see a projects members"", () => {
    it(""Can display all project members"", () => {
      cy.withinTableRows(DataCy.projectSettingsTable, (tr) => {
        // 1 header, 2 members.
        tr.should(""have.length"", 1 + 2);
      });
    });
  });
});
"
cypress/e2e/projectManagement/projectMembership/projectMembers.cy.ts,"import { DataCy } from ""@/fixtures"";

const inviteUser = Cypress.env(""inviteUser"");

describe(""Project Members"", () => {
  beforeEach(() => {
    cy.initEmptyProject().initProjectVersion(false).openProjectSettings();
  });

  describe(""As an owner, I can add a new member to a project"", () => {
    it(""Can't add an invalid member"", () => {
      cy.projectAddNewMember(inviteUser.invalidEmail, ""Viewer"");

      cy.getCy(DataCy.snackbarError).should(""be.visible"");
    });

    it(""Can add a new member to the project"", () => {
      cy.projectAddNewMember(inviteUser.email, ""Viewer"");

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
    });
  });

  describe(""As an owner, I can edit a project members permissions"", () => {
    it(""Can edit the permissions of a project member"", () => {
      cy.projectAddNewMember(inviteUser.email, ""Viewer"");

      cy.clickButton(DataCy.projectSettingsEditUserButton, ""last"");

      cy.clickButton(DataCy.projectSettingsAddRole).clickButtonWithName(
        ""Admin""
      );

      cy.clickButton(DataCy.projectSettingsAddToProject);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
    });
  });

  describe(""As an owner, I can remove a member from a project"", () => {
    it(""Can remove a member from a project"", () => {
      cy.projectAddNewMember(inviteUser.email, ""Viewer"");

      cy.clickButton(
        DataCy.projectSettingsDeleteUserButton,
        ""last""
      ).clickButton(DataCy.confirmModalButton);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
    });
  });
});
"
cypress/e2e/projectManagement/projectVersioning/projects.cy.ts,"import { DataCy, Routes, testProject } from ""@/fixtures"";

describe(""Projects"", () => {
  beforeEach(() => {
    cy.initEmptyProject();

    cy.expandViewport()
      .visit(Routes.MY_PROJECTS)
      .locationShouldEqual(Routes.MY_PROJECTS);
  });

  describe(""As an admin, I can edit a project's name and description"", () => {
    const editedName = "" - Edited"";

    it(""Edits a project from the selector"", () => {
      cy.clickButton(DataCy.selectorEditButton, ""first"");

      cy.getCy(DataCy.projectEditModal).within(() =>
        cy
          .getCy(DataCy.projectEditNameInput)
          .type(editedName)
          .clickButton(DataCy.projectEditSaveButton)
      );

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.contains(editedName).should(""be.visible"");
    });

    it(""Edits a project from the settings"", () => {
      cy.projectSelectorContinue(""project"").projectSelectorContinue(""version"");

      cy.getCy(DataCy.appLoading).should(""not.exist"");

      cy.clickButton(DataCy.navSettingsButton).clickButton(
        DataCy.projectSettingsEditButton
      );

      cy.getCy(DataCy.projectEditModal).within(() =>
        cy
          .getCy(DataCy.projectEditNameInput)
          .type(editedName)
          .clickButton(DataCy.projectEditSaveButton)
      );

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.contains(editedName).should(""be.visible"");
    });
  });

  describe(""As an owner, I can delete a project"", () => {
    it(""Deletes a project from the selector"", () => {
      cy.clickButton(DataCy.selectorDeleteButton, ""first"");

      cy.getCy(DataCy.projectDeleteModal).within(() => {
        cy.getCy(DataCy.modalTitle)
          .invoke(""text"")
          .then(() =>
            cy.inputText(DataCy.projectDeleteNameInput, testProject.name)
          );

        cy.clickButton(DataCy.projectDeleteConfirmButton);
      });

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
    });

    it(""Deletes a project from the settings"", () => {
      cy.projectSelectorContinue(""project"").projectSelectorContinue(""version"");

      cy.getCy(DataCy.appLoading).should(""not.exist"");

      cy.clickButton(DataCy.navSettingsButton).clickButton(
        DataCy.projectSettingsDeleteButton
      );

      cy.getCy(DataCy.projectDeleteModal).within(() => {
        cy.getCy(DataCy.modalTitle)
          .invoke(""text"")
          .then(() =>
            cy.inputText(DataCy.projectDeleteNameInput, testProject.name)
          );

        cy.clickButton(DataCy.projectDeleteConfirmButton);
      });

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
    });
  });
});
"
cypress/e2e/projectManagement/projectVersioning/changeCommits.cy.ts,"import { DataCy } from ""@/fixtures"";

describe(""Change Commits"", () => {
  before(() => {
    cy.initProject();
  });

  beforeEach(() => {
    cy.initProjectVersion();
  });

  describe(""I can create a commit to change project entities"", () => {
    it(""Commits an artifact"", () => {
      const name = ""Test Commit Artifact"";

      cy.getCy(DataCy.navUndoButton).should(""be.disabled"");

      cy.createNewArtifact({ name }, true, true);

      cy.getNode(name).should(""be.visible"");
      cy.getCy(DataCy.navUndoButton).should(""not.be.disabled"");
    });
  });

  describe(""I can undo a committed change"", () => {
    it(""Undoes a created artifact"", () => {
      const name = ""Test Undo Artifact"";

      cy.createNewArtifact({ name }, true, true);

      cy.getNode(name).should(""be.visible"");
      cy.getCy(DataCy.navUndoButton).should(""not.be.disabled"");

      cy.clickButton(DataCy.navUndoButton);

      cy.getNode(name).should(""not.exist"");
      cy.getCy(DataCy.navUndoButton).should(""be.disabled"");
    });

    it(""Undoes edits to an artifact"", () => {
      const name = ""Test Undo Artifact"";
      const changedName = ""Test Changed Artifact"";

      cy.createNewArtifact({ name }, true, true);
      cy.clickButton(DataCy.snackbarCloseButton);

      cy.centerGraph()
        .getNode(name)
        .click()
        .clickButton(DataCy.selectedPanelEditButton);

      cy.inputText(DataCy.artifactSaveNameInput, changedName, true).clickButton(
        DataCy.artifactSaveSubmitButton
      );

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");

      cy.clickButton(DataCy.selectedPanelCloseButton);

      cy.wait(1000).clickButton(DataCy.navUndoButton);

      cy.getNode(name).should(""exist"");
    });

    it.skip(""Undoes changes to a trace link"", () => {
      cy.switchToTableView(""approval"");

      cy.withinTableRows(DataCy.traceLinkTable, (tr) => {
        tr.filter("":visible"").should(""have.length"", 10);
        tr.clickButton(DataCy.traceApproveButton, ""first"");
      });

      cy.withinTableRows(DataCy.traceLinkTable, (tr) => {
        tr.filter("":visible"").should(""have.length"", 9);
      });

      cy.getCy(DataCy.navUndoButton).should(""not.be.disabled"");

      cy.clickButton(DataCy.navUndoButton);

      cy.withinTableRows(DataCy.traceLinkTable, (tr) => {
        tr.filter("":visible"").should(""have.length"", 10);
      });
    });

    it.skip(""Restores deleted trace links on a deleted artifact"", () => {
      cy.on(""uncaught:exception"", () => false);

      const existingName = ""D5"";
      const parentName = ""F6"";

      cy.getNode(existingName).click();

      cy.clickButton(DataCy.selectedPanelDeleteButton).clickButton(
        DataCy.confirmModalButton
      );

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.getNode(existingName).should(""not.exist"");
      cy.getCy(DataCy.navUndoButton).should(""not.be.disabled"");

      cy.clickButton(DataCy.navUndoButton);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");

      cy.centerGraph().getNode(parentName).click();
      cy.getCy(DataCy.selectedPanelChildItem)
        .should(""have.length"", 6)
        .and(""contain.text"", existingName);
    });
  });

  describe(""I can redo a committed change"", () => {
    it(""Reverts a deleted artifact"", () => {
      const name = ""Test Redo Artifact"";

      cy.createNewArtifact({ name }, true, true);

      cy.getNode(name).should(""be.visible"");

      cy.clickButton(DataCy.navUndoButton);

      cy.getNode(name).should(""not.exist"");
      cy.getCy(DataCy.navRedoButton).should(""not.be.disabled"");

      cy.clickButton(DataCy.navRedoButton);

      cy.getNode(name).should(""be.visible"");
      cy.getCy(DataCy.navRedoButton).should(""be.disabled"");
    });
  });
});
"
cypress/e2e/projectManagement/projectVersioning/projectVersions.cy.ts,"import { DataCy, miniProjectFiles, Routes } from ""@/fixtures"";

const validUser = Cypress.env(""validUser"");

describe(""Project Versions"", () => {
  before(() => {
    cy.initEmptyProject();
  });

  beforeEach(() => {
    cy.dbResetVersions();

    cy.visit(Routes.MY_PROJECTS)
      .login(validUser.email, validUser.password)
      .locationShouldEqual(Routes.MY_PROJECTS)
      .expandViewport();
  });

  describe(""I can create a new major, minor, or revision version"", () => {
    it(""Can create a new major version"", () => {
      cy.projectSelectorContinue(""project"").createNewVersion(""major"");

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
    });

    it(""Can create a new minor version"", () => {
      cy.projectSelectorContinue(""project"").createNewVersion(""minor"");

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
    });

    it(""Can create a new revision version"", () => {
      cy.projectSelectorContinue(""project"").createNewVersion(""revision"");

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
    });
  });

  describe(""I can delete a project version"", () => {
    it(""Deletes a version"", () => {
      cy.projectSelectorContinue(""project"");

      cy.getCy(DataCy.selectionVersionList).within(() => {
        cy.clickButton(DataCy.selectorDeleteButton);
      });

      cy.clickButton(DataCy.confirmModalButton);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
    });
  });

  describe(""I can upload new flat files to a project version"", () => {
    it(""Uploads files to the current version"", () => {
      cy.projectSelectorContinue(""project"").projectSelectorContinue(""version"");

      cy.getCy(DataCy.appLoading).should(""not.exist"");
      cy.openUploadFiles();

      cy.uploadFiles(
        DataCy.versionUploadFilesInput,
        ...miniProjectFiles
      ).clickButton(DataCy.versionUploadFilesButton);

      cy.getCy(DataCy.jobStatus, ""first"", 10000).should(
        ""contain.text"",
        ""Completed""
      );
    });
  });
});
"
cypress/e2e/projectManagement/projectArtifacts/artifactDisplay.cy.ts,"import { DataCy } from ""@/fixtures"";

describe(""Artifact Display"", () => {
  before(() => {
    cy.initProject();
  });

  beforeEach(() => {
    cy.initProjectVersion();
  });

  describe(""I can see an artifacts type, name, and body"", () => {
    it(""Shows the artifact content of a selected artifact"", () => {
      const artifactType = ""Design"";
      const artifact = {
        name: ""New"",
        type: `${artifactType}{downArrow}{enter}`,
        body: ""A New Artifact"",
      };

      cy.createNewArtifact(artifact, true);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.getCy(DataCy.selectedPanelName).should(""contain"", artifact.name);
      cy.getCy(DataCy.selectedPanelType).should(""contain"", artifactType);
      cy.getCy(DataCy.selectedPanelBody).should(""contain"", artifact.body);
      cy.getNodes(true).within(() => {
        cy.getCy(DataCy.treeNodeName).should(""contain"", artifact.name);
        cy.getCy(DataCy.treeNodeType).should(""contain"", artifactType);
      });
    });
  });

  describe(""I can see an artifacts parent and child artifacts"", () => {
    it(""I can see and select listed parent artifacts"", () => {
      const parent = ""D11"";

      cy.createNewArtifact(
        {
          parent: `${parent}{downArrow}{enter}`,
        },
        true
      );

      // Affirm created artifact is selected.
      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.getCy(DataCy.selectedPanelParents).should(""be.visible"");

      // Affirm parents are shown, and click first parent's link.
      cy.getCy(DataCy.selectedPanelParentItem)
        .should(""have.length"", 1)
        .first()
        .should(""contain"", parent)
        .within(() => {
          cy.clickButton(DataCy.selectedPanelParentLinkButton);
        });

      // Affirm link is visible and close.
      cy.getCy(DataCy.selectedPanelTraceSource).should(""be.visible"").click();

      // Affirm viewing parent artifact.
      cy.getCy(DataCy.selectedPanelParentItem)
        .first()
        .click()
        .getCy(DataCy.selectedPanelName)
        .should(""contain"", parent)
        .getCy(DataCy.treeSelectedNode)
        .within(() => {
          cy.getCy(DataCy.treeNodeName).should(""contain"", parent);
        });
    });

    it(""I can see and select listed child artifacts"", () => {
      const child = ""New Artifact"";
      const parent = ""F21"";

      cy.createNewArtifact(
        {
          name: child,
          parent: `${parent}{downArrow}{enter}`,
        },
        true
      );

      // Affirm created artifact is selected, and select parent.
      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.getCy(DataCy.selectedPanelParents)
        .should(""be.visible"")
        .getCy(DataCy.selectedPanelParentItem)
        .first()
        .click();

      // Affirm children are shown, and click first child's link.
      cy.getCy(DataCy.selectedPanelChildren).should(""be.visible"");
      cy.getCy(DataCy.selectedPanelChildItem)
        .should(""have.length"", 1)
        .first()
        .should(""contain"", child)
        .within(() => {
          cy.clickButton(DataCy.selectedPanelChildLinkButton);
        });

      // Affirm link is visible and close.
      cy.getCy(DataCy.selectedPanelTraceTarget).should(""be.visible"").click();

      // Affirm viewing created child artifact.
      cy.getCy(DataCy.selectedPanelChildItem)
        .first()
        .click()
        .getCy(DataCy.selectedPanelName)
        .should(""contain"", child)
        .getCy(DataCy.treeSelectedNode)
        .within(() => {
          cy.getCy(DataCy.treeNodeName).should(""contain"", child);
        });
    });
  });
});
"
cypress/e2e/projectManagement/projectArtifacts/artifacts.cy.ts,"import { DataCy } from ""@/fixtures"";

describe(""Artifacts"", () => {
  before(() => {
    cy.initEmptyProject();
  });

  beforeEach(() => {
    cy.initProjectVersion(false);
  });

  describe(""I can create a new artifact"", () => {
    it(""Cannot create an artifact without a name, type, or body"", () => {
      cy.createNewArtifact({ name: """" });

      cy.getCy(DataCy.artifactSaveSubmitButton).should(""be.disabled"");

      cy.inputText(DataCy.artifactSaveNameInput, `New ${Math.random()}`);
      cy.inputText(DataCy.artifactSaveBodyInput, """", true);

      cy.getCy(DataCy.artifactSaveSubmitButton).should(""be.disabled"");

      cy.inputText(DataCy.artifactSaveBodyInput, ""New Artifact"");
      cy.inputText(DataCy.artifactSaveTypeInput, ""{backspace}"");

      cy.getCy(DataCy.artifactSaveSubmitButton).should(""be.disabled"");

      cy.inputText(DataCy.artifactSaveTypeInput, ""Design{downArrow}{enter}"");

      cy.getCy(DataCy.artifactSaveSubmitButton).should(""be.enabled"");
    });

    it(""Creates a simple new artifact"", () => {
      const name = `New ${Math.random()}`;

      cy.createNewArtifact({ name }, true);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.getNodes(true).should(""be.visible"");
      cy.getCy(DataCy.selectedPanelName).should(""contain"", name);
    });

    it(""Cannot create a new artifact with the same name"", () => {
      const name = `New ${Math.random()}`;

      cy.createNewArtifact({ name }, true, true).createNewArtifact({ name });

      cy.contains(""This name is already used, please select another."");
      cy.getCy(DataCy.artifactSaveSubmitButton).should(""be.disabled"");
    });

    it(""Creates a new artifact from the right click menu"", () => {
      const name = `New ${Math.random()}`;

      cy.get(""canvas"")
        .first()
        .then(($el) =>
          cy.wrap($el).rightclick($el.width() / 2, $el.height() / 2)
        );

      cy.getCy(DataCy.rightClickAddArtifact)
        .should(""be.visible"")
        .then(($el) => $el.click());

      cy.fillArtifactFields({ name }).clickButton(
        DataCy.artifactSaveSubmitButton
      );

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.getNodes(true).should(""be.visible"");
      cy.getCy(DataCy.selectedPanelName).should(""contain"", name);
    });

    it(""Adds an artifact as a child of another artifact"", () => {
      cy.createNewArtifact({}, true, true).createNewArtifact(
        { parent: ""{downArrow}{enter}"" },
        true
      );

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.getCy(DataCy.selectedPanelName).should(""be.visible"");

      cy.getCy(DataCy.selectedPanelParents).should(""be.visible"");
      cy.getCy(DataCy.selectedPanelParentItem)
        .should(""be.visible"")
        .should(""have.length"", 1);
    });
  });

  describe(""I can delete an artifact"", () => {
    it(""Deletes a new artifact"", () => {
      cy.createNewArtifact({}, true);

      cy.clickButton(DataCy.selectedPanelDeleteButton).clickButton(
        DataCy.confirmModalButton
      );

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.getCy(DataCy.selectedPanelName).should(""not.exist"");
      cy.getNodes(true).should(""not.exist"");
    });
  });

  describe(""I can edit an artifact"", () => {
    it(""Edits an artifact's name"", () => {
      const name = `New ${Math.random()}`;
      const editedName = `New ${Math.random()}`;

      cy.createNewArtifact({ name }, true);

      cy.clickButton(DataCy.selectedPanelEditButton);

      cy.getCy(DataCy.artifactSaveNameInput).should(""have.value"", name).clear();

      cy.inputText(DataCy.artifactSaveNameInput, editedName);
      cy.clickButton(DataCy.artifactSaveSubmitButton);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.getNodes(true).should(""be.visible"");
      cy.getCy(DataCy.selectedPanelName).should(""contain.text"", editedName);
    });
  });
});
"
cypress/e2e/projectManagement/projectArtifacts/artifactSearch.cy.ts,"import { DataCy } from ""@/fixtures"";

describe(""Artifact Search"", () => {
  before(() => {
    cy.initProject();
  });

  beforeEach(() => {
    cy.initProjectVersion();
  });

  describe(""I can search through current artifacts"", () => {
    it(""Searches for an artifact in the nav bar"", () => {
      cy.selectArtifact(""F21"");

      cy.getNodes(true).should(""be.visible"");
      cy.getCy(DataCy.selectedPanelName).should(""contain"", ""F21"");
    });
  });

  describe(""I can see how many artifact match my search"", () => {
    it(""Displays the count of matching artifacts in the nav bar"", () => {
      cy.enableBasicSearch().inputText(DataCy.artifactSearchNavInput, ""F21"");

      cy.getCy(DataCy.artifactSearchItem).should(""have.length"", 1);
      cy.getCy(DataCy.artifactSearchCount).should(""contain"", 1);

      cy.inputText(DataCy.artifactSearchNavInput, ""Design"", true);

      cy.getCy(DataCy.artifactSearchItem).should(""have.length"", 14);
      cy.getCy(DataCy.artifactSearchCount).should(""contain"", 14);
    });
  });
});
"
cypress/e2e/projectManagement/projectTraceLinks/traceLinks.cy.ts,"import { DataCy } from ""@/fixtures"";

describe(""Trace Links"", () => {
  before(() => {
    cy.initProject();
  });

  beforeEach(() => {
    cy.initProjectVersion();
  });

  describe(""I can create a new trace link"", () => {
    it(""Creates a new trace link"", () => {
      cy.createNewTraceLink(""D3"", ""F5"", true);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
    });
  });

  describe(""I can delete a trace link"", () => {
    it(""Deletes a trace link"", () => {
      cy.createNewArtifact(
        {
          parent: ""{downArrow}{enter}"",
        },
        true
      );

      cy.getCy(DataCy.selectedPanelParents).should(""be.visible"");
      cy.getCy(DataCy.selectedPanelParentItem)
        .first()
        .within(() => {
          cy.clickButton(DataCy.selectedPanelParentLinkButton);
        });

      cy.clickButton(DataCy.traceDeleteButton).clickButton(
        DataCy.confirmModalButton
      );

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");
      cy.getCy(DataCy.selectedPanelParents).should(""not.exist"");
    });
  });
});
"
cypress/e2e/dataGeneration/traceLinkPrediction/traceLinkApproval.cy.ts,"import { DataCy } from ""@/fixtures"";

// 1 header row, 2 virtual scrolls, no traces.
const emptyMatchRowCount = 1 + 2;

// 1 header row, 2 virtual scrolls, 1 group row, 1 trace x 2 rows each.
const singleMatchRowCount = 1 + 2 + 1 + 2;

describe.skip(""Trace Link Approval"", () => {
  before(() => {
    cy.initProject(true, true);
  });

  beforeEach(() => {
    cy.initProjectVersion().switchToTableView(""approval"");
  });

  describe(""I can approve an un-reviewed or declined trace link"", () => {
    it(""Can approve a trace link and check that it is approved"", () => {
      cy.clickButton(DataCy.traceApproveButton);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");

      cy.filterTraceApproval(""approved"");

      cy.withinTableRows(
        DataCy.traceLinkTable,
        (tr) => {
          tr.should(""have.length"", singleMatchRowCount);
        },
        false
      );
    });

    it(""Can approve a declined trace link and check that it is approved"", () => {
      cy.clickButton(DataCy.traceDeclineButton)
        .filterTraceApproval(""declined"")
        .clickButton(DataCy.traceApproveButton);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");

      cy.filterTraceApproval(""approved"");

      cy.withinTableRows(
        DataCy.traceLinkTable,
        (tr) => {
          tr.should(""have.length"", singleMatchRowCount);
        },
        false
      );
    });
  });

  describe(""I can decline an un-reviewed or approved trace link"", () => {
    it(""Can decline a trace link and check that it is declined"", () => {
      cy.clickButton(DataCy.traceDeclineButton);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");

      cy.filterTraceApproval(""declined"");

      cy.withinTableRows(
        DataCy.traceLinkTable,
        (tr) => {
          tr.should(""have.length"", singleMatchRowCount);
        },
        false
      );
    });

    it(""Can decline an approved trace link and check that it is declined"", () => {
      cy.clickButton(DataCy.traceApproveButton)
        .filterTraceApproval(""approved"")
        .clickButton(DataCy.traceDeclineButton);

      cy.getCy(DataCy.snackbarSuccess).should(""be.visible"");

      cy.filterTraceApproval(""declined"");

      cy.withinTableRows(
        DataCy.traceLinkTable,
        (tr) => {
          tr.should(""have.length"", singleMatchRowCount);
        },
        false
      );
    });
  });

  describe(""I can un-review an approved or declined trace link"", () => {
    it(""Can un-review an approved trace link"", () => {
      cy.clickButton(DataCy.traceApproveButton)
        .filterTraceApproval(""approved"")
        .clickButton(DataCy.traceUnreviewButton);

      cy.withinTableRows(
        DataCy.traceLinkTable,
        (tr) => {
          tr.should(""have.length"", emptyMatchRowCount);
        },
        false
      );
    });

    it(""Can un-review a declined trace link"", () => {
      cy.clickButton(DataCy.traceDeclineButton)
        .filterTraceApproval(""declined"")
        .clickButton(DataCy.traceUnreviewButton);

      cy.withinTableRows(
        DataCy.traceLinkTable,
        (tr) => {
          tr.should(""have.length"", emptyMatchRowCount);
        },
        false
      );
    });
  });
});
"
cypress/e2e/dataGeneration/traceLinkPrediction/traceLinkApprovalDisplay.cy.ts,"import { DataCy } from ""@/fixtures"";

describe.skip(""Trace Link Approval Display"", () => {
  before(() => {
    cy.initProject(true, true);
  });

  beforeEach(() => {
    cy.initProjectVersion().switchToTableView(""approval"");
  });

  describe(""I can see approved, declined, and un-reviewed trace links"", () => {
    it(""Displays all generated links"", () => {
      cy.filterTraceApproval(""all"")
        .sortTraceApproval(""none"")
        .groupTraceApproval(""none"");

      cy.withinTableRows(
        DataCy.traceLinkTable,
        (tr) => {
          // 1 Header row, 2 virtual scrolls, 7 links x 2 rows per each
          tr.should(""have.length"", 1 + 2 + 7 * 2);
        },
        false
      );
    });
  });

  describe(""I can sort trace links by their fields"", () => {
    it(""Can sort by name"", () => {
      cy.filterTraceApproval(""all"")
        .sortTraceApproval(""name"")
        .groupTraceApproval(""none"");

      // Should have D9 first and D5 second in order of name (descending)
      cy.withinTableRows(
        DataCy.traceLinkTable,
        (tr) => {
          tr.contains(""D9"").should(""have.length"", 1);
          tr.contains(""D9"")
            .parent()
            .parent()
            .next()
            .next()
            .contains(""D5"")
            .should(""have.length"", 1);
        },
        false
      );
    });
  });

  describe(""I can group trace links by their fields"", () => {
    it(""Can group by type"", () => {
      cy.filterTraceApproval(""all"")
        .sortTraceApproval(""none"")
        .groupTraceApproval(""type"");

      cy.withinTableRows(
        DataCy.traceLinkTable,
        (tr) => {
          tr.contains(""Source type:"").parent().contains(""Design"");
        },
        false
      );
    });

    it(""Can group by approval status"", () => {
      cy.filterTraceApproval(""all"")
        .sortTraceApproval(""none"")
        .groupTraceApproval(""status"");

      cy.withinTableRows(
        DataCy.traceLinkTable,
        (tr) => {
          tr.contains(""Approval status:"").parent().contains(""Unreviewed"");
        },
        false
      );
    });
  });

  describe(""I can see the counts of grouped trace links"", () => {
    it(""Can see the counts of grouped trace links"", () => {
      cy.filterTraceApproval(""all"")
        .sortTraceApproval(""none"")
        .groupTraceApproval(""status"");

      cy.withinTableRows(
        DataCy.traceLinkTable,
        (tr) => {
          tr.contains(""Approval status:"").parent().contains(""7"");
        },
        false
      );
    });
  });
});
"
src/main.ts,"import { createApp } from ""vue"";

import ""@mdi/font/css/materialdesignicons.css"";
import ""vue3-drr-grid-layout/dist/style.css"";

import { Quasar } from ""quasar"";
import VueHighlightJS from ""vue3-highlightjs"";
import Markdown from ""vue3-markdown-it"";
import { router } from ""@/router"";
import { pinia, gridLayout, codeDiff, quasarOptions } from ""@/plugins"";
import App from ""@/App.vue"";

const app = createApp(App);

app
  .use(pinia)
  .use(router)
  .use(gridLayout)
  .use(codeDiff)
  .use(VueHighlightJS)
  .use(Markdown)
  .use(Quasar, quasarOptions);

app.mount(""#app"");

export default app;
"
src/background.ts,"""use strict"";

import { app, protocol, BrowserWindow } from ""electron"";
import { createProtocol } from ""vue-cli-plugin-electron-builder/lib"";
import installExtension, { VUEJS_DEVTOOLS } from ""electron-devtools-installer"";

const isDevelopment = process.env.NODE_ENV !== ""production"";

// Scheme must be registered before the app is ready
protocol.registerSchemesAsPrivileged([
  { scheme: ""app"", privileges: { secure: true, standard: true } },
]);

async function createWindow() {
  // Create the browser window.
  const win = new BrowserWindow({
    width: 800,
    height: 600,
    webPreferences: {
      // Use pluginOptions.nodeIntegration, leave this alone
      // See nklayman.github.io/vue-cli-plugin-electron-builder/guide/security.html#node-integration for more info
      nodeIntegration: process.env
        .ELECTRON_NODE_INTEGRATION as unknown as boolean,
      contextIsolation: !(process.env
        .ELECTRON_NODE_INTEGRATION as unknown) as boolean,
    },
  });

  if (process.env.WEBPACK_DEV_SERVER_URL) {
    // Load the url of the dev server if in development mode
    await win.loadURL(process.env.WEBPACK_DEV_SERVER_URL as string);
    if (!process.env.IS_TEST) win.webContents.openDevTools();
  } else {
    createProtocol(""app"");
    // Load the index.html when not in development
    win.loadURL(""app://./index.html"");
  }
}

// Quit when all windows are closed.
app.on(""window-all-closed"", () => {
  // On macOS it is common for applications and their menu bar
  // to stay active until the user quits explicitly with Cmd + Q
  if (process.platform !== ""darwin"") {
    app.quit();
  }
});

app.on(""activate"", () => {
  // On macOS it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) createWindow();
});

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on(""ready"", async () => {
  if (isDevelopment && !process.env.IS_TEST) {
    // Install Vue Devtools
    try {
      await installExtension(VUEJS_DEVTOOLS);
    } catch (e) {
      console.error(""Vue Devtools failed to install:"", String(e));
    }
  }
  createWindow();
});

// Exit cleanly on request from parent process in development mode.
if (isDevelopment) {
  if (process.platform === ""win32"") {
    process.on(""message"", (data) => {
      if (data === ""graceful-exit"") {
        app.quit();
      }
    });
  } else {
    process.on(""SIGTERM"", () => {
      app.quit();
    });
  }
}
"
src/types/missing-modules.d.ts,"declare module ""cytoscape-klay"";
declare module ""cytoscape-automove"";
declare module ""cytoscape-edgehandles"";
declare module ""vue3-highlightjs"";
declare module ""vue3-markdown-it"";
"
src/types/index.ts,"export * from ""./components"";
export * from ""./cytoscape"";
export * from ""./domain"";
export * from ""./hooks"";
export * from ""./api"";
"
src/types/cytoscape/index.ts,"export * from ""./plugins"";
export * from ""./layout"";
export * from ""./core"";
"
src/types/cytoscape/core/general.ts,"import {
  Core,
  EventObject,
  LayoutOptions,
  Layouts,
  Stylesheet,
} from ""cytoscape"";
import {
  AutoMoveOptions,
  AutoMoveRule,
  EdgeHandleCore,
  EdgeHandlersOptions,
  KlayLayoutOptions,
} from ""@/types/cytoscape"";
import { CytoEvent } from ""@/types/cytoscape/core/events"";

/**
 * Defines CytoCore, an application specific definition of cytoscape defining
 * interfaces with the plugin made available.
 */
export interface CytoCore extends Core {
  automove(input: string | AutoMoveOptions): AutoMoveRule;
  layout(l: LayoutOptions | KlayLayoutOptions): Layouts;
  edgehandles(opts: EdgeHandlersOptions): EdgeHandleCore;
}

/**
 * Defines a cyto event handler.
 */
export interface CytoEventDefinition {
  events: CytoEvent[];
  selector?: string;
  action: (cy: CytoCore, event: EventObject) => void;
}

/**
 * Defines a collection of cyto event handlers.
 */
export type CytoEventHandlers = Record<string, CytoEventDefinition>;

/**
 * Defines a cyto style sheet.
 */
export type CytoStyleSheet =
  | Stylesheet
  | {
      /**
       * The selector to add this style to.
       */
      selector: string;
      /**
       * The style attributes to add for this selector.
       */
      style: Record<string, unknown>;
    };
"
src/types/cytoscape/core/cursor.ts,"/**
 * Extracted from: https://developer.mozilla.org/en-US/docs/Web/CSS/cursor
 *
 * Enumerates cursor types.
 */
export enum CSSCursor {
  /**
   * The UA will determine the cursor to display based on the current context.
   * E.g., equivalent to text when hovering text.
   */
  AUTO = ""auto"",
  /**
   * The cursor is a pointer that indicates a link. Typically an image of a pointing hand.
   */
  POINTER = ""pointer"",
  /**
   * A context menu is available.
   */
  CONTEXT_MENU = ""context-menu"",
  /**
   * Help information is available.
   */
  HELP = ""help"",
  /**
   * The program is busy, and the user can't interact with the interface (in contrast to progress).
   * Sometimes an image of an hourglass or a watch.
   */
  WAIT = ""wait"",
  /**
   * The table cell or set of cells can be selected.
   */
  CELL = ""cell"",
  /**
   * Cross cursor, often used to indicate selection in a bitmap.
   */
  CROSSHAIR = ""crosshair"",
  /**
   * Clicking here is not allowed.
   */
  NOT_ALLOWED = ""not-allowed"",
  /**
   * Something can be zoomed in.
   */
  ZOOM_IN = ""zoom-in"",
  /**
   * Something can be zoomed out.
   */
  ZOOM_OUT = ""zoom-out"",
  /**
   * Something can be grabbed (dragged to be moved).
   */
  GRAB = ""grab"",
  /**
   * Something can be grabbed (dragged to be moved).
   */
  GRABBING = ""grabbing"",
  /**
   * The text can be selected. Typically the shape of an I-beam.
   */
  TEXT = ""text"",
}
"
src/types/cytoscape/core/events.ts,"/**
 * Enumerates types of cyto events.
 *
 * Extracted from: https://js.cytoscape.org/#events
 */
export enum CytoEvent {
  /**
   * # User input device events.
   */

  /**
   * When the mouse button is pressed.
   */
  MOUSE_DOWN = ""mousedown"",
  /**
   * When the mouse button is released.
   */
  MOUSE_UP = ""mouseup"",
  /**
   * After `mousedown` then `mouseup`.
   */
  CLICK = ""click"",
  /**
   * When the cursor is put on top of the target.
   */
  MOUSE_OVER = ""mouseover"",
  /**
   * When the cursor is moved off of the target.
   */
  MOUSE_OUT = ""mouseout"",
  /**
   * When the cursor is moved somewhere on top of the target.
   */
  MOUSE_MOVE = ""mousemove"",
  /**
   * When one or more fingers starts to touch the screen.
   */
  TOUCH_START = ""touchstart"",
  /**
   * When one or more fingers are moved on the screen.
   */
  TOUCH_MOVE = ""touchmove"",
  /**
   * When one or more fingers are removed from the screen.
   */
  TOUCH_END = ""touchend"",

  /**
   * When the viewport is resized (usually by calling cy.resize(),
   * a window resize, or toggling a class on the Cytoscape.js div).
   */
  RESIZE = ""resize"",

  /**
   * # High level events.
   */

  /**
   * Tap start event (either mousedown or touchstart).
   */
  TAP_START = ""tapstart"",
  /**
   * Move event (either touchmove or mousemove).
   */
  TAP_DRAG = ""tapdrag"",
  /**
   * Over element event (either touchmove or mousemove/mouseover).
   */
  TAP_DRAG_OVER = ""tapdragover"",
  /**
   * Off of element event (either touchmove or mousemove/mouseout).
   */
  TAP_DRAGOUT = ""tapdragout"",
  /**
   * Tap end event (either mouseup or touchend).
   */
  TAP_END = ""tapend"",
  /**
   * Tap event (either click, or touchstart followed by touchend without touchmove).
   */
  TAP = ""tap"",
  /**
   * Tap hold event.
   */
  TAP_HOLD = ""taphold"",
  /**
   * Right-click mousedown or two-finger tapstart.
   */
  CXT_TAP_START = ""cxttapstart"",
  /**
   * Right-click mouseup or two-finger tapend.
   */
  CXT_TAP_END = ""cxttapend"",
  /**
   * Right-click or two-finger tap.
   */
  CXT_TAP = ""cxttap"",
  /**
   * Mousemove or two-finger drag after cxttapstart but before cxttapend.
   */
  CXT_DRAG = ""cxtdrag"",
  /**
   * When going over a node via cxtdrag.
   */
  CXT_DRAG_OVER = ""cxtdragover"",
  /**
   * When going off a node via cxtdrag.
   */
  CXT_DRAG_OUT = ""cxtdragout"",
  /**
   * When starting box selection.
   */
  BOX_START = ""boxstart"",
  /**
   * When ending box selection.
   */
  BOX_END = ""boxend"",
  /**
   * Triggered on elements when selected by box selection.
   */
  BOX_SELECT = ""boxselect"",
  /**
   * Triggered on elements when inside the box on boxend.
   */
  BOX = ""box"",

  /**
   * # Custom cytoscape events.
   */

  /**
   * When an element is added to the graph.
   */
  ADD = ""add"",
  /**
   * When an element is removed from the graph.
   */
  REMOVE = ""remove"",
  /**
   * When an element is moved w.r.t. topology.
   */
  MOVE = ""move"",
  /**
   * When the compound parent is changed.
   */
  NODES = ""nodes"",
  /**
   * When the source or target is changed.
   */
  EDGES = ""edges"",
  /**
   * When an element is selected.
   */
  SELECT = ""select"",
  /**
   * When an element is unselected.
   */
  UNSELECT = ""unselect"",
  /**
   * When an element is selected by a tap gesture.
   */
  TAP_SELECT = ""tapselect"",
  /**
   * When an element is unselected by a tap elsewhere.
   */
  TAP_UNSELECT = ""tapunselect"",
  /**
   * When an element is locked.
   */
  LOCK = ""lock"",
  /**
   * When an element is unlocked.
   */
  UNLOCK = ""unlock"",
  /**
   * When an element is grabbed directly (including only the one node directly under the cursor or the users finger).
   */
  GRAB_ON = ""grabon"",
  /**
   * When an element is grabbed (including all elements that would be dragged).
   */
  GRAB = ""grab"",
  /**
   * When an element is grabbed and then moved.
   */
  DRAG = ""drag"",
  /**
   * When an element is freed (i.e. let go from being grabbed).
   */
  FREE = ""free"",
  /**
   * When an element is freed directly (including only the one node directly under the cursor or the users finger).
   */
  FREE_ON = ""freeon"",
  /**
   * When an element is freed after being dragged (i.e. grab then drag then free).
   */
  DRAG_FREE = ""dragfree"",
  /**
   * When an element is freed after being dragged directly (i.e. grabon, drag, freeon).
   */
  DRAG_FREE_ON = ""dragfreeon"",
  /**
   * When an element changes position.
   */
  POSITION = ""position"",
  /**
   * When an element changes position.
   */
  POSITION_BOUNDS = ""position bounds"",
  /**
   * When an elements data is changed.
   */
  DATA = ""data"",
  /**
   * When an elements scratchpad data is changed.
   */
  SCRATCH = ""scratch"",
  /**
   * When an elements style is changed.
   */
  STYLE = ""style"",
  /**
   * When a nodes background image is loaded.
   */
  BACKGROUND = ""background"",
  /**
   * When the pan or zoom changes.
   */
  PAN_ZOOM = ""pan zoom"",

  /**
   * # Edge Handle Events.
   */
  EH_COMPLETE = ""ehcomplete"",
}
"
src/types/cytoscape/core/cyto-core-graph.ts,"import cytoscape, { CytoscapeOptions } from ""cytoscape"";
import { CytoCore } from ""@/types/cytoscape/core"";

/**
 * Background: Cytoscape has to be wrapped in a promise in order to
 * wait for all elements to be loaded into the instance.
 *
 * See issue: https://github.com/rcarcasses/vue-cytoscape/issues/50
 */

/**
 * Wraps cytoscape instance in a promise.
 */
export type ResolveCy =
  | ((value: CytoCore | PromiseLike<CytoCore>) => void)
  | null;

/**
 * Returns an instance of cytoscape when all elements have
 * been loaded
 */
export type CyPromise = Promise<CytoCore>;

/**
 * Defines a plugin to be used on cytoscape
 */
export interface CytoCorePlugin {
  initialize: (cy: typeof cytoscape) => void;
  afterInit: (cy: CytoCore) => void;
}

/**
 * Defines the necessary components to setup a cytoscape graph including:
 */
export interface CytoCoreGraph {
  /**
   * Name to be used for error messages.
   */
  name: string;
  /**
   * Defines initial configuration settings the graph should have.
   */
  config: CytoscapeOptions;
  /**
   * Resolution function to store unique cytoscape instance
   */
  saveCy: ResolveCy;
  /**
   * List of plugins that are installed onto cytoscape instance.
   */
  plugins: CytoCorePlugin[];
  /**
   * Handler for performing any actions once all plugins and elements have
   * been setup in cytoscape instance.
   */
  afterInit: (cy: CytoCore) => void;
}
"
src/types/cytoscape/core/index.ts,"export * from ""./cursor"";
export * from ""./events"";
export * from ""./cyto-core-graph"";
export * from ""./general"";
"
src/types/cytoscape/plugins/automove.ts,"import { NodeSingular, NodeCollection, EventObject } from ""cytoscape"";
import { EmptyLambda } from ""@/types"";
import { CytoEvent } from ""@/types/cytoscape"";

/**
 * Types were manually constructed from: https://github.com/cytoscape/cytoscape.js-automove
 */

/**
 * Returns whether to select the given node.
 */
type NodeSelectionFunction = (node: NodeSingular) => boolean;

/**
 * Enumerates the types of auto move repositions.
 */
export enum AutoMoveReposition {
  MEAN = ""mean"",
  VIEWPORT = ""viewport"",
  DRAG = ""drag"",
}

/**
 * Enumerates the types of bounding boxes.
 */
enum AutoMoveBoundingBoxType {
  INSIDE = ""inside"",
  OUTSIDE = ""outside"",
}

/**
 * Defines a bounding box.
 */
interface AutoMoveBoundingBox {
  x1: number;
  y1: number;
  x2: number;
  y2: number;
  type?: AutoMoveBoundingBoxType;
}

/**
 * Defines the position of a node.
 */
interface NodePosition {
  x: number;
  y: number;
}

/**
 * Returns an updated position of the given node.
 */
type NodePositioningFunction = (node: NodeSingular) => NodePosition;

/**
 * Run when an update is made.
 */
type UpdateHandler = (update: EmptyLambda) => void;

/**
 * Defines the options for auto moving a node.
 */
export interface AutoMoveOptions {
  nodesMatching?: NodeSelectionFunction | string | NodeCollection;
  reposition?:
    | AutoMoveReposition
    | AutoMoveBoundingBox
    | NodePositioningFunction;
  when?: UpdateHandler | ""matching"";
  meanIgnores?: NodeSelectionFunction;
  meanOnSelfPosition?: NodeSelectionFunction;
  dragWith?: NodeSelectionFunction | string | NodeCollection | NodeSingular;
}

/**
 * Defines rule callbacks for an auto move.
 */
export interface AutoMoveRule {
  /**
   * Manually applies a rule.
   */
  apply(): void;
  /**
   * Returns whether a rule is enabled.
   */
  enabled(): boolean;
  /**
   * Toggles whether the rule is enabled.
   */
  toggle(): void;
  /**
   * Temporarily disables the rule.
   */
  disable(): void;
  /**
   * Re-enables a disabled rule.
   */
  enable(): void;
  /**
   * Removes and cleans up this rule.
   */
  destroy(): void;
}

/**
 * A collection of auto move event handlers.
 */
export type AutoMoveEventHandlers = Record<string, AutoMoveEventDefinition>;

/**
 * Fired on an auto move event.
 *
 * @param node - The node being moved.
 * @param rule - The rules for moving.
 * @param event - The event for moving.
 */
export type AutoMoveNodeEvent = (
  node: NodeSingular,
  rule: AutoMoveRule,
  event: EventObject
) => void;

/**
 * Defines an auto move event.
 */
export interface AutoMoveEventDefinition {
  /**
   * Events that trigger this auto move.
   */
  triggers: CytoEvent[];
  /**
   * The auto move action.
   */
  action: AutoMoveNodeEvent;
}
"
src/types/cytoscape/plugins/edge-handles.ts,"import { NodeSingular, EdgeDataDefinition } from ""cytoscape"";

/**
 * Defines options for the edge handler.
 */
export interface EdgeHandlersOptions {
  /**
   * Returns whether the source and target can be connected.
   *
   * @param source - The source node.
   * @param target - The target node.
   *
   * @return Whether the nodes can be connected.
   */
  canConnect(source: NodeSingular, target: NodeSingular): boolean;
  /**
   * Returns the edge definition from the source to the target node.
   *
   * @param source - The source node.
   * @param target - The target node.
   *
   * @return The edge definition
   */
  edgeParams(source: NodeSingular, target: NodeSingular): EdgeDataDefinition;
  /**
   * The time spent hovering over a target node before it is considered selected.
   */
  hoverDelay: number;
  /**
   * When enabled, the edge can be drawn by just moving close to a target node.
   * This can be confusing on compound graphs.
   */
  snap: boolean;
  /**
   * The target node must be less than or equal to this many pixels away from the cursor/finger.
   */
  snapThreshold: number;
  /**
   * The number of times per second (Hz) that snap checks done (lower is less expensive).
   */
  snapFrequency: number;
  /**
   * Set events:no to edges during draws, prevents mouseouts on compounds.
   */
  noEdgeEventsInDraw: boolean;
  /**
   * During an edge drawing gesture, disable browser gestures such as two-finger trackpad swipe and pinch-to-zoom.
   */
  disableBrowserGestures: boolean;
}

/**
 * Defines the edge handler callbacks.
 */
export interface EdgeHandleCore {
  /**
   * Called when an edge creation is first started.
   *
   * @param source - The node that the edge is coming from.
   */
  start(source: NodeSingular): void;
  /**
   * Called when the edge creation is stopped.
   */
  stop(): void;
  /**
   * Called to enable edge creation.
   */
  enable(): void;
  /**
   * Called to disable edge creation.
   */
  disable(): void;
  /**
   * Called to enable edge drawing.
   */
  enableDrawMode(): void;
  /**
   * Called to disable edge drawing.
   */
  disableDrawMode(): void;
  /**
   * Called to destroy this edge handler.
   */
  destroy(): void;
}
"
src/types/cytoscape/plugins/klay.ts,"import { CytoCore, CyLayout } from ""@/types/cytoscape/"";

/**
 * Types were extracted from: https://github.com/cytoscape/cytoscape.js-klay
 */

/**
 * Enumerates the overall direction of edges: horizontal (right / left) or vertical (down / up).
 */
export enum LayoutDirection {
  UNDEFINED = ""UNDEFINED"",
  RIGHT = ""RIGHT"",
  LEFT = ""LEFT"",
  DOWN = ""DOWN"",
  UP = ""UP"",
}

/**
 * Enumerates the alignment to tell the BK node placer to use a certain alignment instead of taking the optimal result.
 */
export enum FixedAlignment {
  /**
   * Chooses the smallest layout from the four possible candidates.
   */
  NONE = ""NONE"",
  /**
   * Chooses the left-up candidate from the four possible candidates.
   */
  LEFTUP = ""LEFTUP"",
  /**
   * Chooses the right-up candidate from the four possible candidates.
   */
  RIGHTUP = ""RIGHTUP"",
  /**
   * Chooses the left-down candidate from the four possible candidates.
   */
  LEFTDOWN = ""LEFTDOWN"",
  /**
   * Chooses the right-down candidate from the four possible candidates.
   */
  RIGHTDOWN = ""RIGHTDOWN"",
  /**
   * Creates a balanced layout from the four possible candidates.
   */
  BALANCED = ""BALANCED"",
}

/**
 * Enumerates the strategies for node layering.
 */
export enum NodeLayering {
  /**
   * This algorithm tries to minimize the length of edges. This is the most computationally intensive algorithm.
   * The number of iterations after which it aborts if it hasn't found a result yet can be set with the Maximal
   * Iterations option.
   */
  NETWORK_SIMPLEX = ""NETWORK_SIMPLEX"",
  /**
   * A very simple algorithm that distributes nodes along their longest path to a sink node.
   */
  LONGEST_PATH = ""LONGEST_PATH"",
  /**
   * Distributes the nodes into layers by comparing their positions before the layout algorithm was started.
   * The idea is that the relative horizontal order of nodes as it was before layout was applied is not changed.
   * This of course requires valid positions for all nodes to have been set on the input graph before calling the
   * layout algorithm. The interactive node layering algorithm uses the Interactive Reference Point option to
   * determine which reference point of nodes are used to compare positions.
   */
  INTERACTIVE = ""INTERACTIVE"",
}

/**
 * Enumerates types of node placement.
 */
export enum NodePlacement {
  /**
   * Minimizes the number of edge bends at the expense of diagram size: diagrams drawn with this algorithm are
   * usually higher than diagrams drawn with other algorithms.
   */
  BRANDES_KOEPF = ""BRANDES_KOEPF"",
  /**
   * Computes a balanced placement.
   */
  LINEAR_SEGMENTS = ""LINEAR_SEGMENTS"",
  /**
   * Tries to keep the preset y coordinates of nodes from the original layout. For dummy nodes, a guess is made to infer their coordinates. Requires the other interactive phase implementations to have run as well.
   */
  INTERACTIVE = ""INTERACTIVE"",
  /**
   * Minimizes the area at the expense of... well, pretty much everything else.
   */
  SIMPLE = ""SIMPLE"",
}

/**
 * Enumerates types of node shapes.
 */
export enum NodePlacement {
  ROUND_RECTANGLE = ""round-rectangle"",
  RECTANGLE = ""rectangle"",
  ELLIPSE = ""ellipse"",
  POLYGON = ""polygon"",
}

/**
 * Defines the klay layout settings.
 */
export interface KlayLayoutSettings {
  spacing?: number;
  direction?: LayoutDirection;
  fixedAlignment?: FixedAlignment;
  layoutHierarchy?: boolean;
  nodeLayering?: NodeLayering;
  nodePlacement?: NodePlacement;
  inLayerSpacingFactor?: number;
  thoroughness?: number;
  randomizationSeed?: number;
}

/**
 * Defines the klay layout options.
 */
export interface KlayLayoutOptions {
  name: ""klay"";
  klay: KlayLayoutSettings;
}

/**
 * A hook for performing layout changes.
 */
export type LayoutHook = (cy: CytoCore, layout: CyLayout) => void;
"
src/types/cytoscape/plugins/index.ts,"export * from ""./automove"";
export * from ""./edge-handles"";
export * from ""./klay"";
"
src/types/cytoscape/layout/cy-layout.ts,"import {
  KlayLayoutSettings,
  LayoutHook,
  AutoMoveEventHandlers,
} from ""@/types/cytoscape/plugins"";
import { CytoCore, CytoEventHandlers } from ""@/types/cytoscape/core"";

/**
 * Defines the layout and event handlers of a graph.
 */
export interface CyLayout {
  klaySettings: KlayLayoutSettings | undefined;
  preLayoutHooks: LayoutHook[];
  postLayoutHooks: LayoutHook[];
  autoMoveHandlers: AutoMoveEventHandlers;
  cytoEventHandlers: CytoEventHandlers;
  createLayout(cy: CytoCore, generate?: boolean): void;
}
"
src/types/cytoscape/layout/index.ts,"export * from ""./cy-layout"";
"
src/types/components/integrations.ts,"/**
 * The props for the integrations stepper.
 */
export interface IntegrationsStepperProps {
  /**
   * Whether this stepper is to create a project or connect with an existing one.
   */
  type: ""create"" | ""connect"";
}

/**
 * The props for the integrations stepper.
 */
export interface AuthenticationListItemProps {
  /**
   * The name of the integration.
   */
  title: string;
  /**
   * Whether the user has credentials for this integration.
   */
  hasCredentials: boolean;
  /**
   * Whether this integration is loading.
   */
  loading?: boolean;
  /**
   * Whether this integration is disabled.
   */
  inactive?: boolean;
}
"
src/types/components/traces.ts,"import { ArtifactSchema, MatrixSchema, TraceProps } from ""@/types"";

/**
 * Enumerates the different methods of filtering artifacts by number of traces.
 */
export enum TraceCountTypes {
  all = ""all"",
  onlyTraced = ""onlyTraced"",
  notTraced = ""notTraced"",
}

/**
 * The props for displaying a trace link.
 */
export interface TraceLinkDisplayProps extends TraceProps {
  /**
   * Whether to display only the source or target artifact.
   */
  showOnly?: ""source"" | ""target"";
}

/**
 * The props for displaying trace link approval buttons.
 */
export interface TraceLinkApprovalProps extends TraceProps {
  /**
   * Whether this trace link can be deleted.
   */
  deletable?: boolean;
}

/**
 * The props for displaying a trace matrix creator.
 */
export interface TraceMatrixCreatorProps {
  /**
   * The trace matrices to edit.
   */
  modelValue: MatrixSchema[];
}

/**
 * The props for displaying a trace matrix chip.
 */
export interface TraceMatrixChipProps {
  /**
   * The source artifact.
   */
  source: ArtifactSchema;
  /**
   * The target artifact.
   */
  target: ArtifactSchema;
}
"
src/types/components/navigation.ts,"import { IconVariant, URLQuery } from ""@/types"";

/**
 * Defines a navigation option that links to a page.
 */
export interface NavOption {
  /**
   * The option's name.
   */
  label: string;
  /**
   * The option's icon id.
   */
  icon: IconVariant;
  /**
   * If true, a divider will be displayed above this option.
   */
  divider?: boolean;
  /**
   * If true, this option will be hidden.
   */
  disabled?: boolean;
  /**
   * The navigation path corresponding to this option.
   */
  path: string | { path: string; query: URLQuery };
}

/**
 * The props for displaying an authenticated page.
 */
export interface PrivatePageProps {
  /**
   * Whether to display in full window mode.
   */
  fullWindow?: boolean;
  /**
   * Whether a cytoscape graph is being displayed.
   */
  graph?: boolean;
  /**
   * The page title to display.
   */
  title?: string;
  /**
   * The page subtitle to display.
   */
  subtitle?: string;
  /**
   * Whether to display a back button to the project graph.
   */
  backToProject?: boolean;
}
"
src/types/components/search.ts,"import { ArtifactSchema } from ""@/types"";

/**
 * The props for rendering a search list item.
 */
export interface SearchOptionProps {
  /**
   * The option to display, either an artifact or artifact type.
   */
  option: ArtifactSchema | string;
}
"
src/types/components/delta.ts,"import {
  ArtifactDeltaSchema,
  ArtifactSchema,
  EntityModificationSchema,
  TraceLinkSchema,
} from ""@/types"";

/**
 * Defines all artifact delta types.
 */
export type DeltaType = ""added"" | ""modified"" | ""removed"";

/**
 * Represents a changed artifact.
 */
export interface ChangedArtifact {
  /**
   * The artifact name.
   */
  name: string;
  /**
   * The artifact delta type.
   */
  deltaType: string;
  /**
   * The changed artifact.
   */
  artifact: ArtifactDeltaSchema;
}

/**
 * The props for displaying an artifact's diff between changes.
 */
export interface ArtifactDeltaDiffProps {
  /**
   * Whether the modal is open.
   */
  open: boolean;
  /**
   * The changed artifact to display.
   */
  delta: ChangedArtifact;
}

/**
 * The props for displaying an artifact delta button.
 */
export interface ArtifactDeltaButtonProps {
  /**
   * The changed entity name.
   */
  name: string;
  /**
   * The type of change delta for this entity.
   */
  deltaType: DeltaType;
}

/**
 * The props for displaying an artifact delta button group.
 */
export interface ArtifactDeltaButtonGroupProps {
  /**
   * The change type for this group.
   */
  deltaType: DeltaType;
  /**
   * A collection of all items with this type of change, keyed by id.
   */
  items: Record<
    string,
    ArtifactSchema | EntityModificationSchema<ArtifactSchema> | TraceLinkSchema
  >;
  /**
   *  If true, items will be interpreted as traces instead of artifacts.
   */
  isTraces?: boolean;
}
"
src/types/components/settings.ts,"import { MembershipSchema, OpenableProps } from ""@/types"";

/**
 * The types of tabs on the settings page.
 */
export enum SettingsTabTypes {
  members = ""members"",
  upload = ""upload"",
  integrations = ""integrations"",
  attributes = ""attributes"",
}

/**
 * The props for displaying a project member save modal.
 */
export interface ProjectMemberModalProps extends OpenableProps {
  /**
   * The member to edit, setting edit mode.
   */
  member?: MembershipSchema;
  /**
   * The email to invite, setting add mode.
   */
  email?: string | null;
  /**
   * The project id to invite the member to, if in add mode.
   */
  projectId?: string;
}
"
src/types/components/jobs.ts,"import { JobSchema } from ""@/types"";

/**
 * The props for displaying a row in the job table.
 */
export interface JobRowProps {
  /**
   * Props passed in from the quasar table.
   */
  quasarProps: Record<string, unknown>;
  /**
   * The job to render.
   */
  job: JobSchema;
  /**
   * Whether the row is expanded.
   */
  expanded: boolean;
}
"
src/types/components/graph.ts,"import { ElementDefinition } from ""cytoscape"";
import {
  ArtifactDeltaState,
  ArtifactProps,
  ClassNameProps,
  CytoCoreGraph,
  StyleProps,
  ThemeColor,
  TraceLinkSchema,
  TraceProps,
} from ""@/types"";

/**
 * Enumerates the modes of the project graph.
 */
export enum GraphMode {
  tim = ""tim"",
  tree = ""tree"",
  table = ""table"",
  delta = ""delta"",
}

/**
 * Enumerates the modes of the project graph.
 */
export enum GraphElementType {
  node = ""node"",
  edge = ""edge"",
}

/**
 * The required properties for defining an element (e.g. node or edge)
 * in cytoscape.
 */
export interface CytoElement<Data = CytoElementData> {
  /**
   * The data for the graph node or link.
   */
  data: Data;
  /**
   * The element's custom style.
   */
  style?: Record<string, unknown>;
  /**
   * The element's cytoscape classes.
   */
  classes?: string;
}

/**
 * Required properties for defining the data that is held within each
 * cytoscape element.
 */
export interface CytoElementData {
  /**
   * A unique identifier for the element with cytoscape instance.
   */
  id: string;
  /**
   * The type of element being represented.
   */
  type: GraphElementType;
  /**
   * The type of graph for this node.
   */
  graph: GraphMode.tree | GraphMode.tim;

  /**
   * Whether the app is running in dark mode.
   */
  dark: boolean;
  /**
   * The cytoscape label placed within nodes and besides edges.
   */
  label?: string;
}

/**
 * Required properties for defining a cytoscape edge.
 */
export interface CytoEdgeData extends CytoElementData {
  /**
   * The cytoscape element id to point from.
   */
  source: string;
  /**
   * The cytoscape element id to point toward.
   */
  target: string;
}

/**
 * Defines an artifact's data in cytoscape.
 */
export interface ArtifactCytoElementData extends CytoElementData {
  /**
   * The name of the artifact.
   */
  artifactName: string;
  /**
   * The type of the artifact.
   */
  artifactType: string;
}

/**
 * Defines an artifact element.
 */
export type ArtifactCytoElement = CytoElement<ArtifactCytoElementData>;

/**
 * Defines a trace link's data in cytoscape.
 */
export interface TraceCytoElementData
  extends CytoEdgeData,
    Pick<TraceLinkSchema, ""traceType"" | ""approvalStatus""> {
  /**
   * The state of changes to the trace link.
   */
  deltaType?: ArtifactDeltaState;
  /**
   * Whether to fade this trace link.
   */
  faded?: boolean;
}

/**
 * Defines a trace link element.
 */
export type TraceCytoElement = CytoElement<TraceCytoElementData>;

/**
 * Defines a tim node's data in cytoscape.
 */
export interface TimNodeCytoElementData extends CytoElementData {
  /**
   * The type of the artifact.
   */
  artifactType: string;
}

/**
 * Defines a tim node in cytoscape.
 */
export type TimNodeCytoElement = CytoElement<TimNodeCytoElementData>;

/**
 * Defines a tim edge's data in cytoscape.
 */
export interface TimEdgeCytoElementData extends CytoEdgeData {
  /**
   * The name of the source artifact type.
   */
  sourceType: string;
  /**
   The name of the target artifact type.
   */
  targetType: string;
  /**
   * The number of links between these artifact layers.
   */
  count: number;
  /**
   * Whether this edge contains generated links.
   */
  generated: boolean;
}

/**
 * Defines a tim edge in cytoscape.
 */
export type TimEdgeCytoElement = CytoElement<TimEdgeCytoElementData>;

/**
 * The props for rendering a cytoscape graph.
 */
export interface CytoscapeProps extends ClassNameProps {
  /**
   * The id of this cytoscape graph.
   */
  id: string;
  /**
   * The graph configuration data.
   */
  graph: CytoCoreGraph;
}

/**
 * The props for rendering the TIM tree graph.
 */
export interface TimTreeProps {
  /**
   * Whether the tree is visible.
   */
  visible: boolean;
}

/**
 * The props for rendering a cytoscape element wrapper.
 */
export interface CyElementProps extends StyleProps {
  /**
   * The element to display.
   */
  definition: ElementDefinition;
}

/**
 * The props for rendering the display of a cytoscape node.
 */
export interface NodeDisplayProps {
  /**
   * The type of node to display.
   */
  variant: ""tim"" | ""artifact"" | ""footer"" | ""sidebar"" | ""menu"";
  /**
   * The color of the node to display.
   */
  color: ThemeColor;
  /**
   * The title of the node to display above the separator.
   */
  title?: string;
  /**
   * The subtitle of the node to display below the separator.
   */
  subtitle?: string;
  /**
   * Whether to display a separator between the title and subtitle.
   */
  separator?: boolean;
  /**
   * The body content to display.
   */
  body?: string;
  /**
   * Whether the node is selected.
   */
  selected?: boolean;
}

/**
 * The props for rendering an artifact node on the graph.
 */
export interface ArtifactNodeProps extends ArtifactProps {
  /**
   * The artifact ids currently selected in view.
   */
  artifactsInView: string[];
}

/**
 * The props for rendering artifact node display panels on the graph.
 */
export interface ArtifactNodeDisplayProps extends ArtifactProps {
  /**
   * The color of the artifact node.
   */
  color: string;
  /**
   * The color of the artifact node in delta state.
   */
  deltaColor: string;
  /**
   * Whether the artifact is selected.
   */
  selected: boolean;
  /**
   * The ids of the artifact's hidden children.
   */
  hiddenChildren: string[];
}

/**
 * The props for rendering a trace link edge on the graph.
 */
export interface TraceLinkProps extends TraceProps {
  /**
   * The artifact ids currently selected in view.
   */
  artifactsInView: string[];
}

/**
 * The props for rendering an artifact type node on the graph.
 */
export interface TimNodeProps {
  /**
   * The artifact type to render.
   */
  artifactType: string;
  /**
   * The number of artifacts of this type.
   */
  count: number;
  /**
   * The icon to display for this artifact type.
   */
  icon?: string;
}

/**
 * The props for rendering a trace matrix edge on the graph.
 */
export interface TimLinkProps {
  /**
   * The source artifact type to render.
   */
  sourceType: string;
  /**
   * The target artifact type to render.
   */
  targetType: string;
  /**
   * The number of trace links of this type.
   */
  count: number;
  /**
   * Whether this matrix contains generated links.
   */
  generated?: boolean;
}
"
src/types/components/index.ts,"export * from ""./base"";
export * from ""./common"";
export * from ""./navigation"";
export * from ""./jobs"";
export * from ""./project"";
export * from ""./artifact"";
export * from ""./traces"";
export * from ""./settings"";
export * from ""./attribute"";
export * from ""./integrations"";
export * from ""./models"";
export * from ""./graph"";
export * from ""./delta"";
export * from ""./search"";
"
src/types/components/models.ts,"import { GenerationModelSchema, TrainingStepSchema } from ""@/types"";

/**
 * Enumerates the different tabs for the model editor.
 */
export enum TracePredictionTabTypes {
  models = ""models"",
  generation = ""generation"",
  approval = ""approval"",
}

/**
 * Defines a generated summary and callback to save it.
 */
export interface ArtifactSummaryConfirmation {
  /**
   * The generated summary to save.
   */
  summary: string;
  /**
   * A callback to save the summary.
   */
  confirm: () => void;
  /**
   * A callback to clear the summary & confirmation.
   */
  clear: () => void;
}

/**
 * The props for displaying a generation model.
 */
export interface GenerationModelProps {
  /**
   * The model to display.
   */
  model: GenerationModelSchema;
  /**
   * Whether this model is generated.
   */
  generated?: boolean;
}

/**
 * The props for displaying a model training step.
 */
export interface ModelTrainingStepProps {
  /**
   * The step to display.
   */
  step: TrainingStepSchema;
}
"
src/types/components/artifact.ts,"import { ArtifactProps, ArtifactSchema } from ""@/types"";

/**
 * The props for displaying an artifact name.
 */
export interface ArtifactNameDisplayProps extends ArtifactProps {
  /**
   * The artifact to display.
   */
  artifact: ArtifactSchema;
  /**
   * Whether to display the artifact type.
   */
  displayType?: boolean;
  /**
   * Whether to display the artifact name in a tooltip.
   */
  displayTooltip?: boolean;
  /**
   * Whether to display the name as a header.
   */
  isHeader?: boolean;
  /**
   * Testing selector for the name.
   */
  dataCyName?: string;
  /**
   * Testing selector for the type.
   */
  dataCyType?: string;
  /**
   * The alignment of the name.
   */
  align?: ""center"" | ""left"" | ""right"";
}
"
src/types/components/attribute.ts,"import { AttributeLayoutSchema, AttributeSchema } from ""@/types"";

/**
 * The props for displaying an attribute layout.
 */
export interface AttributeLayoutProps {
  /**
   * The attribute layout to display or edit.
   */
  layout?: AttributeLayoutSchema;
}

/**
 * The props for displaying an artifact attribute.
 */
export interface AttributeProps {
  /**
   * The attribute to display or edit.
   */
  attribute?: AttributeSchema;
}
"
src/types/components/project/project-creator.ts,"import { ArtifactSchema, ModelType, TraceLinkSchema } from ""@/types/domain"";

/**
 * Defines a collection of parsed artifacts.
 */
export type ArtifactMap = Record<string, ArtifactSchema>;

export enum CreatorTabTypes {
  standard = ""standard"",
  bulk = ""bulk"",
  import = ""import"",
}

export enum LoaderTabTypes {
  load = ""load"",
  uploads = ""uploads"",
}

/**
 * Represents a panel for uploading files in the project creator.
 */
export interface CreatorFilePanel {
  variant: ""artifact"" | ""trace"";
  name: string;
  type: string;
  open: boolean;
  valid: boolean;
  loading: boolean;
  ignoreErrors: boolean;
  itemNames: string[];
  file?: File;
  errorMessage?: string;

  // Artifacts
  artifacts?: ArtifactSchema[];

  // Traces
  toType?: string;
  isGenerated: boolean;
  generateMethod?: ModelType;
  traces?: TraceLinkSchema[];
}

/**
 * The props for displaying a file upload panel.
 */
export interface FilePanelProps {
  /**
   * The panel being edited.
   */
  panel: CreatorFilePanel;
  /**
   * The panel index.
   */
  index: number;
  /**
   * The type of data being created.
   */
  variant: ""artifact"" | ""trace"";
  /**
   * The label for the type of panel.
   */
  label: string;
  /**
   * The panel's label to display over the panel name.
   */
  newLabel: string;
}
"
src/types/components/project/project.ts,"import { MinimalProps, OpenableProps, ProjectIdProps } from ""@/types"";

/**
 * The props for displaying a project files upload input.
 */
export interface ProjectFilesInputProps {
  /**
   * The value of the input.
   */
  modelValue: File[];
  /**
   * The test selector for the input.
   */
  dataCy?: string;
}

/**
 * The props to display a project's identifying information.
 */
export interface ProjectIdentifierProps {
  /**
   * The name of the project.
   */
  name: string;
  /**
   * The description of the project.
   */
  description: string;
  /**
   * The test selector for the name.
   */
  dataCyName?: string;
  /**
   * The test selector for the description.
   */
  dataCyDescription?: string;
}

/**
 * The props for displaying a project's version creator.
 */
export interface CreateVersionModalProps
  extends OpenableProps,
    Partial<ProjectIdProps> {}

/**
 * The props for displaying a project table.
 */
export interface ProjectSelectorTableProps
  extends OpenableProps,
    MinimalProps {}

/**
 * The props for displaying a project version table.
 */
export interface VersionSelectorTableProps
  extends OpenableProps,
    MinimalProps,
    ProjectIdProps {
  /**
   * If true, the current version will be hidden.
   */
  hideCurrentVersion?: boolean;
}
"
src/types/components/project/project-view.ts,"export enum ProjectTableTabTypes {
  artifact = ""artifact"",
  trace = ""trace"",
  approve = ""approve"",
}
"
src/types/components/project/index.ts,"export * from ""./project-creator"";
export * from ""./project-view"";
export * from ""./project"";
"
src/types/components/common/alert.ts,"import { MessageType } from ""@/types"";

/**
 * The props for the Alert component.
 */
export interface AlertProps {
  /**
   * The type of alert to render.
   */
  type?: MessageType;
  /**
   * The message to render.
   */
  message?: string;
}
"
src/types/components/common/flex.ts,"import { AlignType, JustifyType, MarginProps, SizeType } from ""@/types"";

/**
 * Defines props for a flex container.
 */
export interface FlexBoxProps extends MarginProps {
  /**
   * How to align the content.
   */
  align?: AlignType;
  /**
   * How to justify the content.
   */
  justify?: JustifyType;
  /**
   * The max width to set (in pixels)
   */
  maxWidth?: number;
  /**
   * Whether to expand to full width.
   */
  fullWidth?: boolean;
  /**
   * Whether to render as a flex column instead of row.
   */
  column?: boolean;
  /**
   * Whether to allow the items to wrap.
   * @default Unset unless an explicit boolean true or false is set.
   */
  wrap?: boolean;
}

/**
 * Defines props for a flex container item.
 */
export interface FlexItemProps extends MarginProps {
  /**
   * How many parts this column should take up, out of 12.
   */
  parts?: SizeType | ""auto"";
  /**
   * Whether to expand to full width.
   */
  fullWidth?: boolean;
}
"
src/types/components/common/table.ts,"import {
  ExpandableProps,
  LoadingProps,
  MinimalProps,
  TableColumn,
  TableGroupRow,
  TableRow,
  TestableProps,
} from ""@/types"";

/**
 * The props for a table component.
 */
export interface TableProps<Row = TableRow>
  extends LoadingProps,
    TestableProps {
  /**
   * The columns to render in the table.
   */
  columns: TableColumn<Row>[];
  /**
   * The column names that are currently visible, if not all of them.
   */
  visibleColumns?: string[];
  /**
   * The rows of the table.
   */
  rows: Row[];
  /**
   * The field on each row that is unique.
   */
  rowKey: string | ((row: Row) => string);
  /**
   * The number of rows to display per page.
   */
  rowsPerPage?: number;
  /**
   * Enables selection of rows.
   */
  selection?: ""single"" | ""multiple"";
  /**
   * The values of selected rows.
   */
  selected?: Row[];
  /**
   * The ids of expanded rows.
   */
  expanded?: string[];
  /**
   * The text to filter by.
   */
  filterText?: string;
  /**
   * A function to filter the table with.
   */
  filter?: (
    rows: Row[],
    filterText: string | undefined,
    cols: TableColumn[]
  ) => Row[];
  /**
   * Which attribute to sort by.
   */
  sortBy?: string;
  /**
   * Whether to sort descending.
   */
  sortDesc?: boolean;
  /**
   * A function to sort the table with.
   */
  sort?(rows: Row[], sortBy: string, descending: boolean): Row[];
  /**
   * Where to place separators. Defaults to horizontal.
   */
  separator?: ""horizontal"" | ""vertical"" | ""cell"" | ""none"";
  /**
   * Any cells can be customized through the slot `body-cell-[name]`.
   */
  customCells?: string[];
  /**
   * Whether to display densely.
   */
  dense?: boolean;
  /**
   * If true, virtual scroll will be enabled.
   */
  virtualScroll?: boolean;
}

/**
 * The props for a table component that can display groups of rows.
 */
export interface GroupableTableProps
  extends Pick<
      TableProps,
      ""columns"" | ""rows"" | ""rowKey"" | ""loading"" | ""expanded"" | ""customCells""
    >,
    ExpandableProps {
  /**
   * The name of an item.
   */
  itemName?: string;
  /**
   * The default row key to group by.
   */
  defaultGroupBy?: string;
  /**
   * The default row keys to sort by.
   */
  defaultSortBy?: string;
  /**
   * The default sort direction.
   */
  defaultSortDesc?: boolean;
  /**
   * Determines whether a row should be visible.
   */
  filterRow?(row: TableRow): boolean;
}

/**
 * The props for a table header component on groupable tables.
 */
export interface GroupableTableHeaderProps {
  /**
   * The columns to render in the table.
   */
  columns: TableColumn[];
  /**
   * The search text to filter with.
   */
  searchText: string;
  /**
   * The label for the searchbar.
   */
  searchLabel: string;
  /**
   * The row key to group by.
   */
  groupBy: string | undefined;
  /**
   * The row keys to sort by.
   */
  sortBy: string | undefined;
  /**
   * Whether to sort in descending order.
   */
  sortDesc: boolean;
  /**
   * Whether the table is in fullscreen mode.
   */
  inFullscreen: boolean;
}

/**
 * The props for a groupable table row component.
 */
export interface GroupableTableRowProps extends ExpandableProps {
  /**
   * Props passed in from the quasar table.
   */
  quasarProps: Record<string, unknown>;
  /**
   A generic row of a table, or a group header.
   */
  row: TableGroupRow;
  /**
   * The visible table columns.
   */
  columns: TableColumn[];
  /**
   * Whether the row is expanded.
   */
  expand?: boolean;
}

/**
 * The props for a table component that can display selectable rows.
 */
export interface SelectorTableProps
  extends Pick<TableProps, ""columns"" | ""rows"" | ""rowKey"" | ""loading"">,
    MinimalProps {
  /**
   * The values of selected rows.
   */
  selected?: TableRow[];
  /**
   * The name of an item.
   */
  itemName?: string;
  /**
   * Whether elements can be added.
   */
  addable?: boolean;
  /**
   * Whether these rows are editable.
   */
  editable?: boolean | ((row: TableRow) => boolean);
  /**
   * Whether these rows are deletable.
   */
  deletable?: boolean | ((row: TableRow) => boolean);
  /**
   * A hint to display beneath the searchbar.
   */
  searchHint?: string;
}
"
src/types/components/common/modal.ts,"import { LoadingProps, TestableProps } from ""@/types"";

/**
 * The props for the modal displaying errors.
 */
export interface ErrorModalProps {
  /**
   * The errors to display.
   */
  errors: string[];
}

/**
 * The props for displaying a modal.
 */
export interface ModalProps extends LoadingProps, TestableProps {
  /**
   * The modal title.
   */
  title: string;
  /**
   * The modal subtitle.
   */
  subtitle?: string;
  /**
   * Whether the modal is open.
   */
  open: boolean;
  /**
   * A fixed width size to set for the modal.
   */
  size?: ""sm"" | ""md"" | ""lg"" | ""xl"";
}
"
src/types/components/common/input.ts,"import {
  ArtifactSchema,
  ArtifactTypeSchema,
  AttributeCollectionSchema,
  AttributeSchema,
  ClassNameProps,
  ColorProps,
  DisabledProps,
  ErrorMessageProps,
  GenerationModelSchema,
  LabelProps,
  MarginProps,
  MultipleProps,
  OutlinedProps,
  SelectOption,
  TestableProps,
} from ""@/types"";

/**
 * Defines the text input component props.
 */
export interface TextInputProps
  extends LabelProps,
    ClassNameProps,
    ErrorMessageProps,
    Pick<MarginProps, ""b"">,
    DisabledProps,
    TestableProps {
  /**
   * The model value.
   */
  modelValue?: string | number | null;
  /**
   * A hint to display below the input.
   */
  hint?: string;
  /**
   * Whether to hide the hint.
   */
  hideHint?: boolean;
  /**
   * The base input component type to use.
   */
  type?:
    | ""text""
    | ""password""
    | ""textarea""
    | ""email""
    | ""search""
    | ""tel""
    | ""file""
    | ""number""
    | ""url""
    | ""time""
    | ""date"";
}

/**
 * Defines the file input component props.
 */
export interface FileInputProps
  extends ErrorMessageProps,
    MultipleProps,
    TestableProps {
  /**
   * The synchronized files value.
   */
  modelValue?: File | File[] | null;
}

/**
 * Defines the select input component props.
 */
export interface SelectInputProps
  extends OutlinedProps,
    LabelProps,
    DisabledProps {
  /**
   * The selected option to manage.
   */
  modelValue?: unknown;
  /**
   * The options to select from.
   */
  options: unknown[];
  /**
   * The key of an option's id.
   */
  optionValue?: string | ((opt: unknown) => string);
  /**
   * The key of an option's display label.
   */
  optionLabel?: string | ((opt: unknown) => string);
  /**
   * Only saves the option's value, not the entire object.
   */
  optionToValue?: boolean;
}

/**
 * Defines the multiselect input component props.
 */
export interface MultiselectInputProps
  extends Pick<
      SelectInputProps,
      | ""label""
      | ""optionValue""
      | ""optionLabel""
      | ""optionToValue""
      | ""outlined""
      | ""disabled""
    >,
    Pick<TextInputProps, ""hint"">,
    ErrorMessageProps,
    ClassNameProps,
    Pick<MarginProps, ""b"">,
    TestableProps {
  /**
   The selected options to manage.
   */
  modelValue: unknown[];
  /**
   * The options to select from.
   */
  options: string[] | SelectOption[] | unknown[];
  /**
   * If true, new options can be created by pressing enter.
   */
  addValues?: boolean;
  /**
   * Whether to display a button to clear the input.
   */
  clearable?: boolean;
}

/**
 * Defines the password input component props.
 */
export interface PasswordInputProps extends LabelProps, ErrorMessageProps {
  /**
   * The model value.
   */
  modelValue: string;
}

/**
 * Defines the project input component props.
 */
export interface ProjectInputProps extends MultipleProps {
  modelValue: string[] | string | undefined;
  excludeCurrentProject?: boolean;
}

/**
 * Defines the searchbar component props.
 */
export interface SearchbarProps extends LabelProps {
  /**
   * The search text to manage.
   */
  modelValue: string;
  /**
   * A hint to display below the input.
   */
  hint?: string;
}

/**
 * Defines the switch input component props.
 */
export interface SwitchInputProps extends LabelProps, ColorProps {
  /**
   * The switch value to manage.
   */
  modelValue: boolean;
}

/**
 * Defines the artifact input component props.
 */
export interface ArtifactInput extends LabelProps, MultipleProps {
  /**
   * The artifact(s) to manage.
   */
  modelValue: string[] | string | undefined;
  /**
   * If true, only artifacts in the current view are displayed.
   */
  onlyDocumentArtifacts?: boolean;
  /**
   * If set, these artifacts will be removed from the list.
   */
  hiddenArtifactIds?: string[];
  /**
   * If set, these types will be hidden from the initial artifact list.
   */
  defaultHiddenTypes?: string[];
}

/**
 * Defines the artifact type input component props.
 */
export interface ArtifactTypeInputProps
  extends MultipleProps,
    LabelProps,
    ErrorMessageProps,
    Pick<TextInputProps, ""hint""> {
  /**
   * The artifact type(s) to manage.
   */
  modelValue: string[] | string | null;
  /**
   * If true, the number of artifacts matching this type is displayed.
   */
  showCount?: boolean;
  /**
   * If true, the input and chips are displayed more compactly.
   */
  dense?: boolean;
}

/**
 * Defines the attribute input component props.
 */
export interface AttributeInputProps {
  /**
   * The collection of attribute values.
   */
  attributes: AttributeCollectionSchema;
  /**
   * The attribute being edited.
   */
  attribute: AttributeSchema;
}

/**
 * Defines the attribute list input component props.
 */
export interface AttributeListInputProps {
  /**
   * The artifact to manage the collection of attributes within.
   */
  artifact: ArtifactSchema;
}

/**
 * Defines the generation model input component props.
 */
export interface CustomModelInputProps {
  /**
   * The model to manage the selection of.
   */
  modelValue: GenerationModelSchema | undefined;
}

/**
 * Defines the model generation method input component props.
 */
export interface GenMethodInputProps {
  /**
   * The generation method to manage the selection of.
   */
  modelValue?: string;
  /**
   * If true, only trainable methods are displayed.
   */
  onlyTrainable?: boolean;
}

/**
 * Defines the artifact level input component props.
 */
export interface ArtifactLevelInputProps {
  /**
   * The artifact level to display and allow editing of.
   */
  artifactType: ArtifactTypeSchema;
}
"
src/types/components/common/base-table.ts,"/**
 * A column within a data table.
 */
export interface TableColumn<Row = Record<string, unknown>> {
  /**
   * The column field id.
   */
  name: keyof Row | string;
  /**
   * The column display name.
   */
  label: string;
  /**
   * A function for returning the field id from a row item.
   */
  field(row: Row): unknown;
  /**
   * Whether this column is required and cannot be hidden.
   */
  required?: boolean;
  /**
   * Whether this column is sortable.
   */
  sortable?: boolean;
  /**
   * How to align the text content.
   */
  align?: ""left"" | ""center"";
  /**
   * Any classes to apply.
   */
  classes?: string;
  /**
   * A function for formatting the cell text.
   */
  format?(value: unknown): string;
  /**
   * A function for comparing two rows when sorting by this column.
   */
  sort?(a: unknown, b: unknown): number;
}

/**
 * A generic row of a table.
 */
export type TableRow = Record<string, unknown>;

/**
 * A generic row of a table, or a group header.
 */
export type TableGroupRow =
  | TableRow
  | {
      /**
       * The field name that is being grouped by.
       */
      $groupBy: string;
      /**
       * The field value that all rows share for this group.
       */
      $groupValue: string;
      /**
       * The number of rows in this group.
       */
      $groupRows: number;
      /**
       * The sort index of this row.
       */
      $sortIdx: number;
    };
"
src/types/components/common/button.ts,"import {
  ClassNameProps,
  ColorProps,
  DisabledProps,
  IconProps,
  LoadingProps,
  MarginProps,
  OutlinedProps,
  SizeProps,
  TestableProps,
} from ""@/types"";
import { Routes } from ""@/router"";

/**
 * The props for the back button.
 */
export interface BackButtonProps {
  /**
   * The label to render on the button.
   * @default ""Back To Project"" | ""Go Back""
   */
  label?: string;
  /**
   * The route to navigate to.
   * @default Go back in router history.
   */
  route?: Routes;
  /**
   * If true, the back button will always return to the project page.
   */
  toProject?: boolean;
}

/**
 * The props for the icon button component.
 */
export interface IconButtonProps
  extends IconProps,
    DisabledProps,
    ColorProps,
    SizeProps,
    TestableProps {
  /**
   * The tooltip message to display on this button.
   */
  tooltip: string;
  /**
   * The ms to wait before displaying the tooltip.
   * @default 200
   */
  tooltipDelay?: number;
  /**
   * The icon id to render on this button.
   */
  iconId?: string;
  /**
   * Whether to render this button as a fab.
   */
  fab?: boolean;
  /**
   * Rotates the icon on this button (in degrees).
   */
  rotate?: number;
}

/**
 * The props for the text button component.
 */
export interface TextButtonProps
  extends IconProps,
    DisabledProps,
    ColorProps,
    LoadingProps,
    MarginProps,
    ClassNameProps,
    SizeProps,
    OutlinedProps,
    TestableProps {
  /**
   * Renders a flat text button.
   */
  text?: boolean;
  /**
   * Renders the button as a full width block.
   */
  block?: boolean;
  /**
   * The loading percentage to render on a loading button.
   */
  percentage?: number;
  /**
   * The button text to display, if not using the default slot.
   */
  label?: string;
  /**
   * If true, the button label will be hidden.
   */
  hideLabel?: boolean;
}

/**
 * The props for the artifact type button group component.
 */
export interface TypeButtonProps {
  /**
   * Whether the buttons are visible by default.
   * @default false
   */
  defaultVisible?: boolean;
  /**
   * Which type buttons are not active.
   * Defaults to all buttons being active.
   */
  hiddenTypes: string[];
}
"
src/types/components/common/layout.ts,"import {
  ClassNameProps,
  ColorProps,
  DetailsOpenState,
  IconProps,
} from ""@/types"";

/**
 * Defines props for the right sidebar detail panel.
 */
export interface DetailsPanelProps {
  /**
   * The panel being controlled.
   */
  panel: DetailsOpenState;
}

/**
 * Defines props for displaying a panel of content.
 */
export interface PanelCardProps extends ColorProps, IconProps, ClassNameProps {
  /**
   * A title to render on the card.
   */
  title?: string;
  /**
   * A subtitle title to render on the card.
   */
  subtitle?: string;
  /**
   * The panel's container's classes.
   */
  containerClass?: string;
  /**
   * Whether this card should be displayed minimally.
   */
  minimal?: boolean;
  /**
   * Whether this card should display an icon to collapse content and just show the title.
   */
  collapsable?: boolean;
}
"
src/types/components/common/chip.ts,"import {
  ClassNameProps,
  ClickableProps,
  ColorProps,
  IconProps,
  OutlinedProps,
  RemovableProps,
  StyleProps,
  TestableProps,
} from ""@/types"";

/**
 * Defines props for a chip component.
 */
export interface ChipProps
  extends ClassNameProps,
    ColorProps,
    StyleProps,
    OutlinedProps,
    ClickableProps,
    RemovableProps,
    TestableProps {
  /**
   * A chip label to display.
   */
  label?: string;
  /**
   * If true, the chip is displayed more compactly.
   */
  dense?: boolean;
}

/**
 * Defines props for an attribute chip component.
 */
export interface AttributeChipProps
  extends ColorProps,
    IconProps,
    RemovableProps,
    TestableProps {
  /**
   * The chip text.
   */
  value: string | number;
  /**
   * If true, the chip text will be converted from ""camelCase"" to ""Display Case"".
   */
  format?: boolean;
  /**
   * Whether this chip is for an artifact type, customizing the display and icon.
   */
  artifactType?: boolean;
  /**
   * Whether this chip is for a delta type, customizing the display and icon.
   */
  deltaType?: boolean;
  /**
   * Whether this chip is for an approval type, customizing the display and icon.
   */
  approvalType?: boolean;
  /**
   * Whether to render a confidence score instead of a chip.
   */
  confidenceScore?: boolean;
  /**
   * If true, the chip is displayed more compactly.
   */
  dense?: boolean;
}
"
src/types/components/common/index.ts,"export * from ""./enums"";
export * from ""./button"";
export * from ""./alert"";
export * from ""./attribute"";
export * from ""./chip"";
export * from ""./typography"";
export * from ""./flex"";
export * from ""./icon"";
export * from ""./input"";
export * from ""./list"";
export * from ""./layout"";
export * from ""./modal"";
export * from ""./stepper"";
export * from ""./base-table"";
export * from ""./table"";
"
src/types/components/common/list.ts,"import {
  ArtifactSchema,
  ClickableProps,
  ColorProps,
  IconProps,
  SelectOption,
  TestableProps,
  URLQuery,
} from ""@/types"";

/**
 * Defines props for a component that displays an artifact list item.
 */
export interface ArtifactListItemProps extends ClickableProps {
  /**
   * The artifact to display.
   */
  artifact: ArtifactSchema;
  /**
   * Whether to display the title.
   */
  displayTitle?: boolean;
  /**
   * Whether to display a divider between the content.
   */
  displayDivider?: boolean;
  /**
   * Whether to default the artifact content to expanded.
   */
  defaultExpanded?: boolean;
  /**
   * Whether to expand to full width.
   */
  fullWidth?: boolean;
}

/**
 * Defines props for a component that displays a expansion item.
 */
export interface ExpansionItemProps {
  /**
   * The label to display.
   */
  label: string;
  /**
   * The caption ti display under the label.
   */
  caption?: string;
}

/**
 * Defines props for a component that displays a list of components.
 */
export interface ListProps {
  /**
   * Whether to add a border to the list.
   */
  bordered?: boolean;
  /**
   * The number of pixels to set the scroll area height to.
   */
  scrollHeight?: number;
}

/**
 * Defines props for a component that displays a list item.
 */
export interface ListItemProps
  extends ClickableProps,
    IconProps,
    ColorProps,
    TestableProps {
  /**
   * The item title, instead of using the `default` slot.
   */
  title?: string;
  /**
   * The item subtitle, instead of using the `subtitle` slot.
   */
  subtitle?: string;
  /**
   * The icon id, if not using an icon variant name.
   */
  iconId?: string;
  /**
   * The item tooltip.
   * If set to true, a tooltip will be generated based on the title and subtitle.
   */
  tooltip?: true | string;
  /**
   * Where the list item navigates to when clicked.
   */
  to?: string | { path: string; query: URLQuery };
  /**
   * Whether to render a divider between the title and subtitle.
   */
  divider?: boolean;
  /**
   * The optional number of columns ot take up with the action space, out of 12.
   */
  actionCols?: number;
}

/**
 * Defines props for a component that displays a set of tabs.
 */
export interface TabListProps {
  /**
   * The tab id currently selected.
   */
  modelValue: string;
  /**
   * The tabs to display.
   */
  tabs: SelectOption[];
}
"
src/types/components/common/attribute.ts,"import {
  ArtifactSchema,
  AttributeCollectionSchema,
  AttributeLayoutSchema,
  AttributeSchema,
} from ""@/types"";

/**
 * The props for displaying an attribute.
 */
export interface AttributeDisplayProps {
  /**
   * The collection of attribute values to display from.
   */
  values: AttributeCollectionSchema;
  /**
   * The attribute from the collection to display.
   */
  attribute: AttributeSchema;
  /**
   * If true, the attribute name will be displayed above the value.
   */
  showName?: boolean;
}

/**
 * The props for displaying an attribute grid.
 */
export interface AttributeGridProps {
  /**
   * The layout of attributes to display.
   */
  layout: AttributeLayoutSchema;
  /**
   * Whether the attribute grid is editable.
   */
  editable?: boolean;
}

/**
 * The props for displaying an attribute list.
 */
export interface AttributeListProps {
  /**
   * The artifact to display the custom attributes of.
   */
  artifact: ArtifactSchema;
}

/**
 * Package: 'vue3-drr-grid-layout'
 * Defines component props.
 */
export interface GridItemData {
  x: number;
  y: number;
  w: number;
  h: number;
  i: string;
}
"
src/types/components/common/enums.ts,"import { SearchMode } from ""@/types"";

/**
 * Represents an option for a select menu.
 */
export interface SelectOption {
  /**
   * The iud of the option to use as a stored.
   */
  id: string;
  /**
   * The name of the option to display.
   */
  name: string;
}

/**
 * Represents an option for searching modes.
 */
export interface SearchSelectOption extends SelectOption {
  /**
   * The iud of the option to use as a stored.
   */
  id: SearchMode;
  /**
   * Describes this search mode.
   */
  description: string;
  /**
   * The placeholder for the search input.
   */
  placeholder: string;
  /**
   * Whether this mode searches for artifacts.
   */
  artifactSearch?: boolean;
}
"
src/types/components/common/typography.ts,"import { ClassNameProps, ColorProps, MarginProps, SizeProps } from ""@/types"";

/**
 * The variants of text that can be displayed.
 */
export type TextType =
  | ""large""
  | ""title""
  | ""subtitle""
  | ""body""
  | ""small""
  | ""caption""
  | ""expandable""
  | ""code"";

/**
 * The types of text elements.
 */
export type ElementType = ""span"" | ""p"" | ""div"" | ""h1"" | ""h2"" | ""h3"" | ""a"";

/**
 * The methods of text alignment.
 */
export type TextAlignType = ""left"" | ""center"" | ""right"";

/**
 * Defines props for displaying text.
 */
export interface TypographyProps
  extends ColorProps,
    SizeProps,
    MarginProps,
    ClassNameProps {
  /**
   * The text value to display.
   */
  value?: string | number;
  /**
   * Whether to truncate text with an ellipsis.
   */
  ellipsis?: boolean;

  /**
   * Whether to inherit color from the parent element.
   */
  inheritColor?: boolean;
  /**
   * Whether to color this text as an error.
   */
  error?: boolean;
  /**
   * Renders the text with a faded color.
   */
  secondary?: boolean;

  /**
   * Bolds the text.
   */
  bold?: boolean;
  /**
   * Sets the text to wrap.
   */
  wrap?: boolean;

  /**
   * The variant of text to render.
   * @default `body`
   */
  variant?: TextType;
  /**
   * The element to render the text on.
   * @default `span`
   */
  el?: ElementType;
  /**
   * How to align the text.
   * @default `left`
   */
  align?: TextAlignType;

  /**
   * For expandable variants, whether the content defaults to expanded.
   */
  defaultExpanded?: boolean;
  /**
   * The length at which to automatically collapse a default expanded component.
   * If set to 0, the component will never collapse by default.
   */
  collapseLength?: number;
}

/**
 * Defines props for a component that renders a separator.
 */
export interface SeparatorProps
  extends MarginProps,
    ClassNameProps,
    ColorProps {
  /**
   * Whether to render the separator vertically.
   */
  vertical?: boolean;
  /**
   * Whether to pad the separator.
   */
  inset?: boolean;
  /**
   * Whether to style to separator for the navigation bar.
   */
  nav?: boolean;
}
"
src/types/components/common/stepper.ts,"import { LoadingProps, MinimalProps } from ""@/types"";

/**
 * Defines a step used by the stepper component.
 */
export interface StepperStep {
  /**
   * The step title.
   */
  title: string;
  /**
   * Whether the step is done.
   */
  done: boolean;
  /**
   * An optional step caption.
   */
  caption?: string;
}

/**
 * Defines props for the stepper component.
 */
export interface StepperProps extends MinimalProps {
  /**
   * The current 1-based step number.
   */
  modelValue: number;
  /**
   * The steps to render.
   * A slot will be created for each step, named by their 1-based index.
   */
  steps: StepperStep[];
  /**
   * If true, the label text will be made as dense as possible.
   * Useful when displaying long lists of steps
   */
  denseLabels?: boolean;
  /**
   * If true, the actions will be hidden.
   */
  hideActions?: boolean;
}

/**
 * Defines props for the stepper step that displays a list of items.
 */
export interface StepperListStepProps extends LoadingProps {
  /**
   * The step title.
   */
  title: string;
  /**
   * The number of items in this step.
   */
  itemCount: number;
  /**
   * The message to display when empty.
   */
  emptyMessage?: string;
}
"
src/types/components/common/icon.ts,"import { ClickableProps, ColorProps, StyleProps, TestableProps } from ""@/types"";

/**
 * Enumerates the types of icons.
 */
export type IconVariant =
  | ""add""
  | ""edit""
  | ""save""
  | ""saving""
  | ""delete""
  | ""cancel""
  | ""leave""
  | ""info""
  | ""update""
  | ""success""
  | ""error""
  | ""invite""
  | ""artifact""
  | ""trace""
  | ""upload""
  | ""download""
  | ""sync""
  | ""integrate""
  | ""warning""
  | ""back""
  | ""account""
  | ""search""
  | ""code""
  | ""create-artifact""
  | ""create-trace""
  | ""generate""
  | ""generate-artifacts""
  | ""generate-traces""
  | ""notification""
  | ""share""
  | ""logs""
  | ""more""
  | ""undo""
  | ""redo""
  | ""logout""
  | ""file""
  | ""down""
  | ""up""
  | ""arrow-down""
  | ""arrow-up""
  | ""fullscreen""
  | ""fullscreen-exit""
  | ""home-list""
  | ""home-add""
  | ""job-complete""
  | ""job-cancel""
  | ""job-fail""
  | ""trace-approve""
  | ""trace-decline""
  | ""trace-decline-all""
  | ""trace-unreview""
  | ""view-tim""
  | ""view-tree""
  | ""view-table""
  | ""view-delta""
  | ""graph-zoom-in""
  | ""graph-zoom-out""
  | ""graph-center""
  | ""graph-refresh""
  | ""nav-toggle""
  | ""nav-home""
  | ""nav-create""
  | ""nav-open""
  | ""nav-uploads""
  | ""nav-artifact""
  | ""nav-trace""
  | ""nav-settings""
  | ""filter-open""
  | ""filter-close""
  | ""group-open""
  | ""group-open-all""
  | ""group-close""
  | ""group-close-all"";

/**
 * Defines props for an icon.
 */
export interface IconDisplayProps
  extends ColorProps,
    StyleProps,
    TestableProps {
  /**
   * The icon variant to render.
   */
  variant?: IconVariant;
  /**
   * The id of an icon, if not rendering a preset variant.
   */
  id?: string;
  /**
   * The size of the icon.
   */
  size?: ""xs"" | ""sm"" | ""md"" | ""lg"" | ""xl"";
  /**
   * How much to rotate the icon (in degrees).
   */
  rotate?: number;
}

/**
 * Defines props for the safa icon.
 */
export interface SafaIconProps extends ClickableProps {
  /**
   * Whether to hide the icon.
   */
  hidden?: boolean;
}
"
src/types/components/base/props.ts,"import {
  ArtifactSchema,
  IconVariant,
  IdentifierSchema,
  ThemeColor,
  TraceLinkSchema,
} from ""@/types"";

/**
 * The possible increments for spacing.
 */
export type SizeType =
  | """"
  | ""1""
  | ""2""
  | ""3""
  | ""4""
  | ""5""
  | ""6""
  | ""7""
  | ""8""
  | ""9""
  | ""10""
  | ""11""
  | ""12"";

/**
 * Defines props for a component with margins.
 */
export interface MarginProps {
  /**
   * The x margin.
   */
  x?: SizeType;
  /**
   * The y margin.
   */
  y?: SizeType;
  /**
   * The left margin.
   */
  l?: SizeType;
  /**
   * The right margin.
   */
  r?: SizeType;
  /**
   * The top margin.
   */
  t?: SizeType;
  /**
   * The bottom margin.
   */
  b?: SizeType;
}

/**
 * Defines props for a component that can display a label.
 */
export interface LabelProps {
  /**
   * The label to display.
   */
  label?: string;
}

/**
 * Defines props for a component with a color.
 */
export interface ColorProps {
  /**
   * The color to render the component with.
   */
  color?: ThemeColor;
}

/**
 * Defines props for a component with a css class name.
 */
export interface ClassNameProps {
  /**
   * The classnames to include on this component.
   */
  class?: string;
}

/**
 * Defines props for a component with a css style.
 */
export interface StyleProps {
  /**
   * The css style to apply.
   */
  style?: string;
}

/**
 * Defines props for a component with an icon.
 */
export interface IconProps {
  /**
   * The type of icon to render.
   */
  icon?: IconVariant;
}

/**
 * Defines props for a component that can load.
 */
export interface LoadingProps {
  /**
   * Whether the component is loading.
   */
  loading?: boolean;
}

/**
 * Defines props for a component that can be disabled.
 */
export interface DisabledProps {
  /**
   * Whether the component is disabled.
   */
  disabled?: boolean;
}

/**
 * Defines props for a component that can be small or large.
 */
export interface SizeProps {
  /**
   * Renders a smaller component.
   */
  small?: boolean;
  /**
   * Renders a larger component.
   */
  large?: boolean;
}

/**
 * Defines props for a component that can be outlined.
 */
export interface OutlinedProps {
  /**
   * If true, the component will be rendered as outlined.
   */
  outlined?: boolean;
}

/**
 * Defines props for a component that can be clicked.
 */
export interface ClickableProps {
  /**
   * Whether the component is clickable.
   */
  clickable?: boolean;
}

/**
 * Defines props for a component that can be removed.
 */
export interface RemovableProps {
  /**
   * Whether the component is removable, displaying a remove button.
   */
  removable?: boolean;
}

/**
 * Defines props for a component that can be made minimal.
 */
export interface MinimalProps {
  /**
   * Whether the component should be displayed with minimal information.
   */
  minimal?: boolean;
}

/**
 * Defines props for a component that can be expanded.
 */
export interface ExpandableProps {
  /**
   * Whether the component can be expanded.
   */
  expandable?: boolean;
}

/**
 * Defines props for a component that can be opened.
 */
export interface OpenableProps {
  /**
   * Whether the component is open.
   */
  open: boolean;
}

/**
 * Defines props for a component that can display an error.
 */
export interface ErrorMessageProps {
  /**
   * An error message to display, if one exists.
   */
  errorMessage?: string | false;
}

/**
 * Defines props for a component that can have multiple items instead of one.
 */
export interface MultipleProps {
  /**
   * Whether to allow multiple items.
   */
  multiple?: boolean;
}

/**
 * Defines props for a component that can be selected in tests.
 */
export interface TestableProps {
  /**
   * The testing selector to set.
   */
  dataCy?: string;
}

/**
 * Defines props for a component that displays a project.
 */
export interface ProjectIdProps {
  /**
   * The project to display or edit.
   */
  project: IdentifierSchema;
}

/**
 * Defines props for a component that displays an artifact.
 */
export interface ArtifactProps {
  /**
   * The artifact to display or edit.
   */
  artifact: ArtifactSchema;
}

/**
 * Defines props for a component that displays a trace link.
 */
export interface TraceProps {
  /**
   * The trace link to display or edit.
   */
  trace: TraceLinkSchema;
}
"
src/types/components/base/types.ts,"/**
 * The methods of alignment.
 */
export type AlignType = ""start"" | ""center"" | ""end"";

/**
 * The methods of justifying.
 */
export type JustifyType = AlignType | ""between"" | ""around"";

export type ThemeColor =
  | ""primary""
  | ""secondary""
  | ""accent""
  | ""positive""
  | ""negative""
  | ""nodeDefault""
  | ""nodeGenerated""
  | string;
"
src/types/components/base/index.ts,"export * from ""./types"";
export * from ""./props"";
"
src/types/shims/shims-tsx.d.ts,"import Vue, { VNode } from ""vue"";

declare global {
  namespace JSX {
    // tslint:disable no-empty-interface
    interface Element extends VNode {}
    // tslint:disable no-empty-interface
    interface ElementClass extends Vue {}
    interface IntrinsicElements {
      [elem: string]: any;
    }
  }
}
"
src/types/hooks/general.ts,"import { DocumentType, FTANodeType, SafetyCaseType } from ""@/types"";

/**
 * Enumerates types of panels.
 */
export enum PanelType {
  appPanel = ""appPanel"",
  errorDisplay = ""errorDisplay"",
  detailsPanel = ""detailsPanel"",
  projectSaver = ""projectSaver"",
  projectDeleter = ""projectDeleter"",
  artifactCreator = ""artifactCreator"",
  traceCreator = ""traceCreator"",
  traceLinkDraw = ""traceLinkDraw"",
}

/**
 * Represents the open state of the artifact creator.
 */
export type ArtifactCreatorOpenState =
  | boolean
  | SafetyCaseType
  | FTANodeType
  | DocumentType;

/**
 * Represents the open state of the trace link creator.
 */
export type TraceCreatorOpenState =
  | boolean
  | { type: ""source""; artifactId: string }
  | { type: ""target""; artifactId: string }
  | { type: ""both""; sourceId: string; targetId: string };

/**
 * Represents the type of details panel states.
 */
export type DetailsOpenState =
  | boolean
  | ""delta""
  | ""document""
  | ""displayArtifact""
  | ""displayArtifactBody""
  | ""generateArtifact""
  | ""saveArtifact""
  | ""displayTrace""
  | ""saveTrace""
  | ""generateTrace""
  | ""displayArtifactLevel""
  | ""saveArtifactLevel""
  | ""displayTraceMatrix"";

/**
 * Represents the states of all openable panels.
 */
export interface PanelStateMap {
  [PanelType.appPanel]: boolean;
  [PanelType.detailsPanel]: DetailsOpenState;
  [PanelType.projectSaver]: boolean;
  [PanelType.projectDeleter]: boolean;
  [PanelType.artifactCreator]: ArtifactCreatorOpenState;
  [PanelType.traceCreator]: TraceCreatorOpenState;
  [PanelType.errorDisplay]: boolean;
  [PanelType.traceLinkDraw]: boolean;
}

/**
 * Defines a title and message for a confirmation dialog.
 */
export interface ConfirmDialogueMessage {
  type: ConfirmationType;
  title: string;
  body: string;
  statusCallback: (status: boolean) => void;
}

export enum ConfirmationType {
  INFO = ""info"",
  CLEAR = ""clear"",
}

/**
 * General type for representing an empty callback
 */
export type EmptyLambda = () => void;

export enum LocalStorageKeys {
  darkMode = ""dark"",
}
"
src/types/hooks/filters.ts,"/**
 * Defines an ignore filter action.
 */
export interface IgnoreTypeFilterAction {
  type: ""ignore"";
  ignoreType: string;
  action: ""add"" | ""remove"";
}

/**
 * Defines an subtree filter action.
 */
export interface SubtreeFilterAction {
  type: ""subtree"";
  nodeIds: string[];
  centerIds?: string[];
}

/**
 * Defines a general filter action.
 */
export type FilterAction = IgnoreTypeFilterAction | SubtreeFilterAction;
"
src/types/hooks/document.ts,"import { ArtifactSchema, TraceLinkSchema } from ""@/types"";

/**
 * Defines the artifacts displayed in a document.
 */
export interface DocumentArtifacts {
  /**
   * All artifacts in the project.
   * If empty, the current artifacts will be preserved.
   */
  artifacts?: ArtifactSchema[];
  /**
   * The artifacts that are visible in the current document.
   * If empty, all artifacts are made visible.
   */
  currentArtifactIds?: string[];
}

/**
 * Defines the trace links displayed in a document.
 */
export interface DocumentTraces {
  /**
   * All trace links in the project.
   * If empty, the current traces will be preserved.
   */
  traces?: TraceLinkSchema[];
  /**
   * The artifacts that are visible in the current document.
   * If empty, all trace links are made visible.
   */
  currentArtifactIds?: string[];
}
"
src/types/hooks/viewport.ts,"import { CyPromise, CyLayout } from ""@/types"";

export interface LayoutPayload {
  cyPromise: CyPromise;
  layout: CyLayout;
}
"
src/types/hooks/commit.ts,"import { CommitSchema } from ""@/types"";

/**
 * Container for a commit and its revert used in commit module.
 */
export interface CommitHistory {
  /**
   * The original commit;
   */
  commit: CommitSchema;
  /**
   * The revert of the commit containing the states
   * before the commit is applied.
   */
  revert: CommitSchema;
}
"
src/types/hooks/composables.ts,"import { ComputedRef, Ref, WritableComputedRef } from ""vue"";
import { QVueGlobals, Screen } from ""quasar/dist/types"";
import { TableColumn } from ""@/types"";

/**
 * Defines a hook for using the app theme.
 */
export interface ThemeHook {
  /**
   * The current theme.
   */
  theme: QVueGlobals;
  /**
   * Whether the app is in dark mode.
   */
  darkMode: WritableComputedRef<boolean>;
  /**
   * Toggles whether the theme is in dark mode.
   * @param dark - The explicit mode to set.
   *        If none is given, the current mode is toggled.
   */
  toggleDarkMode(dark?: boolean): void;
}

/**
 * Defines a hook for managing changes with the screen size.
 */
export interface ScreenHook {
  /**
   * Whether the current window is small enough to
   * collapse content vertically.
   */
  smallWindow: ComputedRef<boolean>;
  /**
   * The quasar screen hook.
   */
  screen: ComputedRef<Screen>;
}

/**
 * Props for creating a table filter hook.
 */
export interface TableFilterProps {
  /**
   * The columns to render in the table.
   */
  columns: TableColumn[];
  /**
   * The rows of the table.
   */
  rows: Record<string, unknown>[];
  /**
   * The name of an item.
   */
  itemName?: string;
  /**
   * Determines whether a row should be visible.
   */
  filterRow?(row: Record<string, unknown>): boolean;
  /**
   * The default row keys to sort by.
   */
  defaultSortBy?: string;
  /**
   * The default sort direction.
   */
  defaultSortDesc?: boolean;
}

/**
 * Defines a hook for sorting and filtering table rows.
 */
export interface TableFilterHook {
  /**
   * The table search text.
   */
  searchText: Ref<string | null>;
  /**
   * The table search label.
   */
  searchLabel: ComputedRef<string>;
  /**
   * The table search sort field.
   */
  sortBy: Ref<string | undefined>;
  /**
   * The table search sort direction.
   */
  sortDesc: Ref<boolean>;
  /**
   * The table rows after filtering.
   */
  filteredRows: ComputedRef<Record<string, unknown>[]>;
}
"
src/types/hooks/index.ts,"export * from ""./commit"";
export * from ""./filters"";
export * from ""./general"";
export * from ""./snackbar"";
export * from ""./viewport"";
export * from ""./document"";
export * from ""./composables"";
"
src/types/hooks/snackbar.ts,"/**
 * Enumerates app store message types.
 */
export enum MessageType {
  info = ""info"",
  update = ""update"",
  success = ""success"",
  error = ""error"",
  warning = ""warning"",
  clear = ""clear"",
}

/**
 * Defines a snackbar message.
 */
export interface SnackbarMessage {
  /**
   * A list of errors.
   */
  errors: string[];
  /**
   * The message text.
   */
  message: string;
  /**
   * The message type.
   */
  type: MessageType;
}
"
src/types/api/github-api.ts,"/**
 * Represents a GitHub import request.
 */
export interface GitHubImportSchema {
  /**
   * The branch to import.
   */
  branch?: string;
  /**
   * File patterns to include.
   * Matches based on java's default globbing.
   * See https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/file/FileSystem.html#getPathMatcher(java.lang.String)
   */
  include?: string[];
  /**
   * File patterns to exclude.
   * Matches based on java's default globbing.
   * See https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/file/FileSystem.html#getPathMatcher(java.lang.String)
   */
  exclude?: string[];
  /**
   * The artifact type id to import as.
   */
  artifactType?: string;
}

/**
 * Represents a GitHub installation (authorized organization).
 */
export interface GitHubOrganizationSchema {
  /**
   * The installation's unique id.
   */
  id: string;
  /**
   * The installation's name.
   */
  name: string;
}

/**
 * Defines a GitHub repository.
 */
export interface GitHubProjectSchema {
  /**
   * The project's id.
   */
  id: string;
  /**
   * The project's name.
   */
  name: string;
  /**
   * The project's description.
   */
  description: string;
  /**
   * The project's url.
   */
  url?: string;
  /**
   * The project's size.
   */
  size: number;
  /**
   * A timestamp for the project was created.
   */
  creationDate: string;
  /**
   * The owner of this project.
   */
  owner: string;
  /**
   * The list of active branches in this repository.
   */
  branches: string[];
  /**
   * The default branch for this repository.
   */
  defaultBranch: string;
}
"
src/types/api/file-api.ts,"/**
 Represents the project TIM file artifact format.
 */
export interface TimArtifactJsonSchema {
  /**
   * The name of the artifact type for these artifacts.
   */
  type: string;
  /**
   * The name of the file containing artifacts.
   */
  fileName: string;
}

/**
 Represents the project TIM file trace link format.
 */
export interface TimTraceJsonSchema {
  /**
   * The name of the artifact source type for these trace links.
   */
  sourceType: string;
  /**
   * The name of the artifact target type for these trace links.
   */
  targetType: string;
  /**
   * The name of the file containing trace links.
   * Must be included unless `generateLinks` is set to true.
   */
  fileName?: string;
  /**
   * The name of the file containing trace links.
   */
  generateLinks?: boolean;
}

/**
 Represents the project TIM file format.
 */
export interface TimJsonSchema {
  /**
   * A collection of descriptors for each artifact file.
   */
  artifacts: TimArtifactJsonSchema[];
  /**
   * A collection of descriptors for each trace file.
   */
  traces: TimTraceJsonSchema[];
}
"
src/types/api/jira-api.ts,"/**
 * Represents a Jira installation (authorized organization).
 */
export interface JiraOrganizationSchema {
  /**
   * The installation's unique id.
   */
  id: string;
  /**
   * The installation's name.
   */
  name: string;
}

/**
 * Represents a jira project.
 */
export interface JiraProjectSchema {
  /**
   * The project's unique id.
   */
  id: string;
  /**
   * The project's unique key name.
   */
  key: string;
  /**
   * The project's name.
   */
  name: string;
  /**
   * The project's description.
   */
  description: string;
  /**
   * The project's avatar.
   */
  mediumAvatarUrl: string;
}
"
src/types/api/websocket-api.ts,"/**
 * Notifies client of a series of changes to the project.
 *
 */
export interface ChangeMessageSchema {
  /**
   * The user initiating the change.
   */
  user: string;
  /**
   * List of changes occurring to project.
   * Each change depicts what entity was affected, how it was affected
   * (UPDATED / DELETED), and the affected entity ids).
   */
  changes: ChangeSchema[];
  /**
   * Includes whether the default document layout should be updated.
   * This is true if any artifacts or trace links where changed.
   */
  updateLayout: boolean;
}

/**
 * Represents list of changed entities.
 */
export interface ChangeSchema {
  entity: EntityType;
  action: ActionType;
  entityIds: string[];
}

/**
 * Entity being changed.
 */
export enum EntityType {
  PROJECT = ""PROJECT"",
  MEMBERS = ""MEMBERS"",
  VERSION = ""VERSION"",
  TYPES = ""TYPES"",
  TRACE_MATRICES = ""TRACE_MATRICES"",
  DOCUMENT = ""DOCUMENT"",
  ARTIFACTS = ""ARTIFACTS"",
  TRACES = ""TRACES"",
  WARNINGS = ""WARNINGS"",
  JOBS = ""JOBS"",
  LAYOUT = ""LAYOUT"",
  SUBTREES = ""SUBTREES"",
  MODELS = ""MODELS"",
  ATTRIBUTES = ""ATTRIBUTES"",
  ATTRIBUTE_LAYOUTS = ""ATTRIBUTE_LAYOUTS"",
}

/**
 * A list of all entities that can trigger updates
 * through notifications when made by the current user.
 */
export const notifyUserEntities = [
  EntityType.VERSION,
  EntityType.WARNINGS,
  EntityType.LAYOUT,
];

/**
 * The action performed on an change to an entity.
 * Used in notifications to signal asynchronous updates.
 */
export enum ActionType {
  UPDATE = ""UPDATE"",
  DELETE = ""DELETE"",
}
"
src/types/api/base-api.ts,"/**
 * Defines the options for interacting with API endpoints.
 */
export interface APIOptions {
  headers?: Record<string, string>;
  method: APIMethods;
  body?: string | FormData;
}

type APIMethods = ""GET"" | ""POST"" | ""PUT"" | ""DELETE"";

/**
 * Defines a error response from the API.
 */
export interface APIError {
  /**
   * The error status.
   */
  status: number;
  /**
   * The body of the error.
   */
  body: APIErrorBody;
}

/**
 * Defines an API error.
 */
export interface APIErrorBody {
  /**
   * The error details.
   */
  details: string;
  /**
   * The error message.
   */
  message: string;
  /**
   * A list of stack traces.
   */
  errors: string[];
}

/**
 * Defines the callbacks for an io handler function.
 */
export interface IOHandlerCallback<Res = void> {
  /**
   * Called on success with the response data.
   * @param res - The successful response data.
   */
  onSuccess?: (res: Res) => void;
  /**
   * Called on error with the error details.
   * @param err - The returned error.
   */
  onError?: (err: Error) => void;
  /**
   * Called regardless of whether the action succeeds or fails once complete.
   */
  onComplete?: () => void;
}

/**
 * Represents a URL parameter in the app's web address.
 */
export type URLParameter = undefined | null | string | (string | null)[];

/**
 * Represents a collection of URL parameters.
 */
export type URLQuery = Record<string, URLParameter>;
"
src/types/api/job-api.ts,"/**
 * Identifies a job being performed.
 */
export interface JobSchema {
  /**
   * The UUID of the job.
   */
  id: string;
  /**
   * A readable name for the job.
   */
  name: string;
  /**
   * The current step this job is on.
   */
  currentStep: number;
  /**
   * The steps names involved with this job.
   */
  steps: string[];
  /**
   * The current status of the job.
   */
  status: JobStatus;
  /**
   * Timestamp of when the job was started.
   */
  startedAt: string;
  /**
   * Timestamp of when the job was last updated.
   */
  lastUpdatedAt: string;
  /**
   * Timestamp of when the job was completed.
   */
  completedAt: string;
  /**
   * Integer percentage of current progress of the job.
   */
  currentProgress: number;
  /**
   * The UUID of the entity completed or updated by this job.
   */
  completedEntityId?: string;
}

/**
 * The state a job can be in.
 */
export enum JobStatus {
  /**
   * The job is being performed as expected.
   */
  IN_PROGRESS = ""IN_PROGRESS"",
  /**
   * The job has finished.
   */
  COMPLETED = ""COMPLETED"",
  /**
   * The job has been cancelled.
   */
  CANCELLED = ""CANCELLED"",
  /**
   * The job has failed.
   */
  FAILED = ""FAILED"",
}

/**
 * Describes an entry in the job log.
 */
export interface JobLogSchema {
  id: string;
  job: string;
  stepNum: number;
  timestamp: string;
  entry: string;
}
"
src/types/api/layout-api.ts,"import { LayoutPositionsSchema } from ""@/types"";

/**
 * Represents the configuration to refresh document layouts.
 */
export interface LayoutRegenerationSchema {
  /**
   * If true, the default document will be regenerated.
   */
  defaultDocument: boolean;
  /**
   * A list of all document ids to regenerate.
   */
  documentIds: string[];
}

/**
 * Represents regenerated layouts.
 */
export interface GeneratedLayoutsSchema {
  /**
   * Returns the layout for the default document.
   */
  defaultDocumentLayout: LayoutPositionsSchema;
  /**
   * Returns the layout for each document regenerated, keyed by document id.
   */
  documentLayoutMap: Record<string, LayoutPositionsSchema>;
}
"
src/types/api/index.ts,"export * from ""./base-api"";
export * from ""./project-api"";
export * from ""./commit-api"";
export * from ""./websocket-api"";
export * from ""./jira-api"";
export * from ""./job-api"";
export * from ""./github-api"";
export * from ""./layout-api"";
export * from ""./file-api"";
"
src/types/api/commit-api.ts,"import { ArtifactSchema, VersionSchema, TraceLinkSchema } from ""@/types"";

/**
 * Represents a single commit containing one or more changes to
 * either artifacts or trace links
 */
export interface CommitSchema {
  /**
   * The version this commit is being made on.
   */
  commitVersion: VersionSchema;
  /**
   * The changes occurring to the project artifacts.
   */
  artifacts: EntityCommitSchema<ArtifactSchema>;
  /**
   * The changes occurring to project traces.
   */
  traces: EntityCommitSchema<TraceLinkSchema>;
  /**
   * If false, errors will be silent.
   */
  failOnError?: boolean;
}

/**
 * Encapsulates the changes for a generic type of project entity.
 */
export interface EntityCommitSchema<Entity> {
  /**
   * The entities that were added.
   */
  added: Entity[];
  /**
   * The entities that were removed
   */
  removed: Entity[];
  /**
   * The entities that were modified.
   */
  modified: Entity[];
}
"
src/types/api/project-api.ts,"import {
  ArtifactSchema,
  GeneratedMatrixSchema,
  ProjectSchema,
  TraceLinkSchema,
} from ""@/types/domain"";

/**
 * Defines the response from checking if an artifact exists.
 */
export interface NameValidationSchema {
  /**
   * Whether the artifact exists.
   */
  artifactExists: boolean;
}

/**
 * The response from parsing a file.
 */
export interface ParseFileSchema {
  /**
   * Any parsing errors encountered.
   */
  errors: string[];
}

/**
 * The response from parsing an artifact file.
 */
export interface ParseArtifactFileSchema extends ParseFileSchema {
  /**
   * The artifacts parsed.
   */
  entities: ArtifactSchema[];
}

/**
 * The response from parsing a trace file.
 */
export interface ParseTraceFileSchema extends ParseFileSchema {
  /**
   * The traces parsed.
   */
  entities: TraceLinkSchema[];
}

/**
 * The request payload for creating a project via JSON.
 */
export interface CreateProjectByJsonSchema {
  /**
   * The project entities to commit.
   */
  project: ProjectSchema;
  /**
   * The trace generation request to perform and commit.
   */
  requests: GeneratedMatrixSchema[];
}
"
src/types/domain/project.ts,"import {
  ArtifactSchema,
  ArtifactTypeSchema,
  DocumentSchema,
  LayoutPositionsSchema,
  MembershipSchema,
  TraceLinkSchema,
  GenerationModelSchema,
  WarningSchema,
  AttributeSchema,
  AttributeLayoutSchema,
  SubtreeMapSchema,
  TraceMatrixSchema,
} from ""@/types"";

/**
 * Defines a project.
 */
export interface IdentifierSchema {
  /**
   * The ID of the project.
   */
  projectId: string;

  /**
   * The name of the project.
   */
  name: string;
  /**
   * The description of the project.
   */
  description: string;

  /**
   * List of members and their roles in the project.
   */
  members: MembershipSchema[];

  /**
   * The primary owner of this project.
   */
  owner: string;
}

/**
 * Defines the version of a project.
 */
export interface VersionSchema {
  /**
   * The project version id.
   */
  versionId: string;
  /**
   * The project.
   */
  project?: IdentifierSchema;
  /**
   * The major version number.
   */
  majorVersion: number;
  /**
   * The minor version number.
   */
  minorVersion: number;
  /**
   * The revision version number.
   */
  revision: number;
}

/**
 * Defines a versioned and parsed project.
 */
export interface ProjectSchema extends IdentifierSchema {
  /**
   * The project's version.
   */
  projectVersion?: VersionSchema;

  /**
   * The project's artifacts.
   */
  artifacts: ArtifactSchema[];
  /**
   * The project's traces.
   */
  traces: TraceLinkSchema[];
  /**
   * The artifact types in the project.
   */
  artifactTypes: ArtifactTypeSchema[];
  /**
   * The trace matrices in the project.
   */
  traceMatrices: TraceMatrixSchema[];

  /**
   * The current document id.
   */
  currentDocumentId?: string;
  /**
   * The different documents for this project.
   */
  documents: DocumentSchema[];

  /**
   * A collection of warnings on project artifacts.
   */
  warnings: Record<string, WarningSchema[]>;

  /**
   * Map of artifact ids to their position in the default graph.
   */
  layout: LayoutPositionsSchema;
  /**
   * Map of artifact ids to their subtree information.
   */
  subtrees: SubtreeMapSchema;

  /**
   * List of trained project models.
   */
  models: GenerationModelSchema[];

  /**
   * A list of custom attributes used on this project.
   */
  attributes?: AttributeSchema[];
  /**
   * Layouts for displaying this project's custom attributes.
   */
  attributeLayouts?: AttributeLayoutSchema[];
}

export type VersionType = ""major"" | ""minor"" | ""revision"";
"
src/types/domain/membership.ts,"/**
 * The types of permissions allowed on an organization.
 */
export type OrganizationPermissionType = ""navigation"" | ""viewer"" | ""editor"";

/**
 * The types of permissions allowed on a project.
 */
export type ProjectPermissionType = ""viewer"" | ""editor"" | ""admin"" | ""owner"";

/**
 * Represents a member in a given project
 */
export interface MembershipSchema {
  projectMembershipId: string;
  email: string;
  role: ProjectRole;
}

/**
 * Represents a role with certain authorization constraints
 * within a given project.
 */
export enum ProjectRole {
  VIEWER = ""VIEWER"",
  EDITOR = ""EDITOR"",
  ADMIN = ""ADMIN"",
  OWNER = ""OWNER"",
}

/**
 * Represents a request for adding a member to a project.
 */
export interface MemberRequestSchema {
  memberEmail: string;
  projectRole: ProjectRole;
}
"
src/types/domain/installations.ts,"/**
 * Defines a 3rd party data installation to a project.
 */
export interface InstallationSchema {
  /**
   * The Jira project ID, or GitHub repository name.
   */
  installationId: string;
  /**
   * The Jira or GitHub organization id that the project is within.
   */
  installationOrgId: string;
  /**
   * The ISO timestamp of the last installation sync.
   */
  lastUpdate: string;
  /**
   * The type of installation.
   */
  type: ""GITHUB"" | ""JIRA"";
}
"
src/types/domain/search.ts,"/**
 * The search modes that are supported.
 */
export enum SearchMode {
  /**
   * Search by tracing a prompt string to some type of artifacts.
   */
  prompt = ""prompt"",
  /**
   * Search by tracing artifacts to some type of artifacts.
   */
  artifacts = ""artifacts"",
  /**
   * Search by tracing artifact types to other types of artifacts.
   */
  artifactTypes = ""artifactTypes"",
  /**
   * Font-end only.
   * Search within the current view for artifacts.
   */
  search = ""search"",
}

/**
 * Represents a request to search for matching artifacts within a project.
 */
export interface SearchQuerySchema {
  /**
   * The type of information to predict traces to.
   */
  mode: SearchMode;
  /**
   * Used in ""prompt"" mode.
   * This string of text will be treated as an artifact to predict links from.
   */
  prompt?: string;
  /**
   * Used in ""artifacts"" mode.
   * These artifacts will be used as the base to predict links from.
   */
  artifactIds?: string[];
  /**
   * Used in ""artifactTypes"" mode.
   * All artifacts of these types will be used as the base to predict links from.
   */
  artifactTypes?: string[];

  /**
   * What type(s) of artifacts to predict links from the search artifacts to.
   */
  searchTypes: string[];
  /**
   * The model to predict links with.
   * @default Our best model.
   */
  model?: string;
  /**
   * How many of the top predictions to include.
   * @default 5
   */
  maxResults?: number;
  /**
   * What other type(s) of artifacts should I import,
   * if they have existing links to the artifacts retrieved with the search artifacts + `searchTypes` artifacts.
   */
  relatedTypes?: string[];
}

/**
 * Represents the artifacts that match a search request.
 */
export interface SearchResultsSchema {
  /**
   * The ids of artifacts that match the search request.
   */
  artifactIds: string[];
}
"
src/types/domain/delta.ts,"/**
 * Enumerates the types of artifact deltas.
 */
import {
  ArtifactSchema,
  LayoutPositionsSchema,
  SubtreeMapSchema,
  TraceLinkSchema,
} from ""@/types"";

/**
 * Enumerates the types of delta state.
 */
export enum ArtifactDeltaState {
  NO_CHANGE = ""NO_CHANGE"",
  MODIFIED = ""MODIFIED"",
  ADDED = ""ADDED"",
  REMOVED = ""REMOVED"",
  IMPACTED = ""IMPACTED"",
}

/**
 * Defines a modification over some delta
 */
export interface EntityModificationSchema<Entity> {
  before: Entity;
  after: Entity;
}

/**
 * Defines the delta entities state.
 */
export interface EntityDeltaSchema<Entity> {
  /**
   * A collection of all added entities.
   */
  added: Record<string, Entity>;
  /**
   * A collection of all removed entities.
   */
  removed: Record<string, Entity>;
  /**
   * A collection of all modified entities.
   */
  modified: Record<string, EntityModificationSchema<Entity>>;
  /**
   * A collection of all impacted entities.
   */
  impacted?: Record<string, Entity>;
}

/**
 * Defines the changed project data between two versions.
 */
export interface VersionDeltaSchema {
  /**
   * Mapping of artifact names and their corresponding changes.
   */
  artifacts: EntityDeltaSchema<ArtifactSchema>;
  /**
   * Mapping of trace ids and their corresponding changes.
   */
  traces: EntityDeltaSchema<TraceLinkSchema>;
  /**
   * Map of artifact ids to their position in the delta graph.
   */
  layout?: LayoutPositionsSchema;
  /**
   * Map of delta artifact ids to their subtree information.
   */
  subtrees?: SubtreeMapSchema;
}

/**
 * Represents an artifact delta.
 */
export type ArtifactDeltaSchema =
  | ArtifactSchema
  | EntityModificationSchema<ArtifactSchema>;
"
src/types/domain/authentication.ts,"/**
 * Defines a user model.
 */
export interface UserSchema {
  /**
   * The user's id.
   */
  userId: string;
  /**
   * The user's email.
   */
  email: string;
}

/**
 * Defines a user & password model.
 */
export interface UserPasswordSchema {
  /**
   * The user's email.
   */
  email: string;
  /**
   * The user's password.
   */
  password: string;
}

/**
 * Defines a session model.
 */
export interface SessionSchema {
  /**
   * The JWT token authorizing current user.
   */
  token: string;
  /**
   * The version ID to load when the app loads.
   */
  versionId?: string;
}

/**
 * Defines a user model for password reset.
 */
export interface UserResetSchema {
  /**
   * The user's email.
   */
  email: string;
}

/**
 * Defines a user model for password reset.
 */
export interface PasswordResetSchema {
  /**
   * The token generated and included by email as a query param to securely change a user's password.
   */
  resetToken: string;
  /**
   * The new password to set.
   */
  newPassword: string;
}

/**
 * Defines a user model for password change.
 */
export interface PasswordChangeSchema {
  /**
   * The current password to change.
   */
  oldPassword: string;
  /**
   * The new password to set.
   */
  newPassword: string;
}
"
src/types/domain/document.ts,"import { LayoutPositionsSchema } from ""@/types"";
import { IdentifierSchema } from ""@/types/domain/project"";

/**
 * Enumerates the type of documents supported by SAFA.
 */
export enum DocumentType {
  ARTIFACT_TREE = ""ARTIFACT_TREE"",
  FTA = ""FTA"",
  SAFETY_CASE = ""SAFETY_CASE"",
  FMEA = ""FMEA"",
  FMECA = ""FMECA"",
}

/**
 * Defines a specific document.
 */
export interface DocumentSchema {
  /**
   * The id of this document.
   */
  documentId: string;
  /**
   * The project associated with this document.
   */
  project: IdentifierSchema;
  /**
   * The name of the document.
   */
  name: string;
  /**
   * The description of the document.
   */
  description: string;
  /**
   * The type of document.
   */
  type: DocumentType;
  /**
   * The ids of artifacts displayed within this document.
   */
  artifactIds: string[];
  /**
   * Map of document ids to their artifact positions.
   */
  layout: LayoutPositionsSchema;
}
"
src/types/domain/model.ts,"import { GeneratedMatrixSchema, VersionSchema } from ""@/types"";

/**
 * Enumerates the type of generated trace models.
 */
export enum ModelType {
  AutomotiveBert = ""AutomotiveBert"",
  NLBert = ""NLBert"",
  PLBert = ""PLBert"",
  VSM = ""VSM"",
}

/**
 * Represents a model trained to generate trace links.
 */
export interface GenerationModelSchema {
  /**
   * The model's id.
   */
  id: string;
  /**
   * The model's name.
   */
  name: string;
  /**
   * The base model that is being extended.
   */
  baseModel: ModelType;
  /**
   * The logged steps of training on this model.
   */
  steps?: TrainingStepSchema[];
}

/**
 * Lists the methods by which a model can be shared.
 */
export enum ModelShareType {
  CLONE = ""COPY_BY_VALUE"",
  REUSE = ""COPY_BY_REFERENCE"",
}

/**
 * Describes a matrix of artifacts.
 */
export interface MatrixSchema {
  /**
   * The source artifact type.
   */
  source: string;
  /**
   * The target artifact type.
   */
  target: string;
}

/**
 * Represents a matrix to generate or train links on.
 */
export interface TrainOrGenerateLinksSchema {
  /**
   * The version to commit the entities to.
   */
  projectVersion?: VersionSchema;
  /**
   * The sets of matrices to generate or train on.
   */
  requests: GeneratedMatrixSchema[];
}

/**
 * Represents a step of model training.
 */
export interface TrainingStepSchema {
  /**
   * The type of training being done.
   *
   * `keywords` - Pre-Training: Keywords
   * `document` - Pre-Training: Documents
   * `repository` - Intermediate-Training: Repositories
   * `project` - Fine-Tuning: Project Data
   */
  type: ""keywords"" | ""document"" | ""repository"" | ""project"";
  /**
   * The ISO timestamp of when this step was last updated.
   */
  updatedAt: string;
  /**
   * The status of this training step.
   */
  status: ""In Progress"" | ""Completed"" | ""Failed"";
  /**
   * On the keywords step, any keywords to compile
   * documents and repositories using.
   */
  keywords: string[];
  /**
   * On the documents step, any documents being trained on.
   */
  documents: {
    /**
     * The name of this document.
     */
    name: string;
    /**
     * The link to where this document is stored.
     */
    url: string;
  }[];
  /**
   * On the repositories step, any GitHub repositories being trained on.
   */
  repositories: {
    /**
     * The name of this repository.
     */
    name: string;
    /**
     * The link to where this repository is stored.
     */
    url: string;
  }[];
  /**
   * On the training step, any projects being trained on.
   */
  projects: {
    /**
     * The project's id.
     */
    id: string;
    /**
     * The project's name.
     */
    name: string;
    /**
     * The trace matrices being used for training.
     */
    levels: MatrixSchema[];
  }[];
}
"
src/types/domain/tim.ts,"/**
 * Defines a type of artifact in a project.
 */
export interface ArtifactTypeSchema {
  /**
   * The UUID for specific artifact type.
   */
  typeId: string;
  /**
   * The name of this type of artifacts.
   */
  name: string;

  /**
   * The icon that should be used to represent it.
   */
  icon: string;
  /**
   * The color of this artifact type.
   */
  color: string;

  /**
   * @readonly
   * The number of artifacts of this artifact type.
   */
  count: number;
}

/**
 * Defines a trace matrix in the project.
 */
export interface TraceMatrixSchema {
  /**
   * The UUID for this trace matrix.
   */
  id: string;
  /**
   * @readonly
   * The type of the artifact that this matrix links from.
   */
  sourceType: string;
  /**
   * @readonly
   * The type of the artifact that this matrix links to.
   */
  targetType: string;

  /**
   * @readonly
   * The total number of trace links between these types.
   */
  count: number;
  /**
   * @readonly
   * The number of trace links between these types that were generated.
   */
  generatedCount: number;
  /**
   * @readonly
   * The number of trace links between these types that were generated and approved.
   */
  approvedCount: number;
}
"
src/types/domain/links.ts,"/**
 * Enumerates the type of trace approvals.
 */
export enum ApprovalType {
  UNREVIEWED = ""UNREVIEWED"",
  APPROVED = ""APPROVED"",
  DECLINED = ""DECLINED"",
}

/**
 * Enumerates the type of traces.
 */
export enum TraceType {
  GENERATED = ""GENERATED"",
  MANUAL = ""MANUAL"",
}

/**
 * Defines a link.
 */
export interface LinkSchema {
  /**
   * The source node ID.
   */
  sourceId: string;
  /**
   * The source node name.
   */
  sourceName: string;
  /**
   * The target node ID.
   */
  targetId: string;
  /**
   * The target node name.
   */
  targetName: string;
}

/**
 * Defines a trace link.
 */
export interface TraceLinkSchema extends LinkSchema {
  /**
   * The trace link ID.
   */
  traceLinkId: string;
  /**
   * The approval status of the trace.
   */
  approvalStatus: ApprovalType;
  /**
   * The confidence score of the trace.
   */
  score: number;
  /**
   * The type of trace.
   */
  traceType: TraceType;
  /**
   * The explanation of why a trace link was generated.
   */
  explanation?: string;
}

/**
 * Represents a trace link merged with other properties.
 */
export interface FlatTraceLink extends TraceLinkSchema {
  /**
   * The type of source artifact.
   */
  sourceType: string;
  /**
   * The body of source artifact.
   */
  sourceBody: string;
  /**
   * The type of target artifact.
   */
  targetType: string;
  /**
   * The body of target artifact.
   */
  targetBody: string;
}

/**
 * Represents links generated for a project.
 */
export interface GeneratedLinksSchema {
  /**
   * All generated links.
   */
  traceLinks: FlatTraceLink[];
  /**
   * Approved generated link ids.
   */
  approvedIds: string[];
  /**
   * Declined generated link ids.
   */
  declinedIds: string[];
}
"
src/types/domain/warning.ts,"/**
 * Defines an artifact warning.
 */
export interface WarningSchema {
  /**
   * The artifact rule name.
   */
  ruleName: string;
  /**
   * The artifact rule message.
   */
  ruleMessage: string;
}

/**
 * A collection of warnings keyed by artifact id.
 */
export type WarningCollectionSchema = Record<string, WarningSchema[]>;
"
src/types/domain/subtree.ts,"/**
 * Represents a node's subtree, parents, and children.
 */
export interface SubtreeItemSchema {
  /**
   * The ids of parents of this node.
   */
  parents: string[];
  /**
   The ids of children of this node.
   */
  children: string[];
  /**
   The ids of children of this node and their children, recursively.
   */
  subtree: string[];
  /**
   The ids of parents of this node and their parents, recursively.
   */
  supertree: string[];
  /**
   The ids of both the subtree and supertree combined.
   */
  neighbors: string[];
}

/**
 * Maps each node to its related nodes.
 */
export type SubtreeMapSchema = Record<string, SubtreeItemSchema>;
"
src/types/domain/layout.ts,"/**
 * The position of a node within a graph.
 * A nodes position refers to the centre point of its body.
 */
export interface PositionSchema {
  /**
   * # of pixes right from the top-left  corner.
   */
  x: number;
  /**
   * # of pixels down from the top-left corner.
   */
  y: number;
}

/**
 * Maps artifact ids to their coordinates on the graph.
 */
export type LayoutPositionsSchema = Record<string, PositionSchema>;
"
src/types/domain/index.ts,"export * from ""./authentication"";
export * from ""./tim"";
export * from ""./artifact"";
export * from ""./warning"";
export * from ""./files"";
export * from ""./document"";
export * from ""./membership"";
export * from ""./layout"";
export * from ""./project"";
export * from ""./links"";
export * from ""./delta"";
export * from ""./model"";
export * from ""./attribute"";
export * from ""./installations"";
export * from ""./search"";
export * from ""./hgen"";
export * from ""./subtree"";
"
src/types/domain/artifact.ts,"import { AttributeCollectionSchema } from ""./attribute"";
import { DocumentType } from ""./document"";

/**
 * Enumerates the types of FTA nodes.
 */
export enum FTANodeType {
  OR = ""OR"",
  AND = ""AND"",
}

/**
 * Enumerates the types of safety cases.
 */
export enum SafetyCaseType {
  GOAL = ""GOAL"",
  SOLUTION = ""SOLUTION"",
  CONTEXT = ""CONTEXT"",
  STRATEGY = ""STRATEGY"",
}

/**
 * A map from each safety case types to what they can trace to.
 */
export const allowedSafetyCaseTypes: Record<SafetyCaseType, SafetyCaseType[]> =
  {
    [SafetyCaseType.GOAL]: [SafetyCaseType.GOAL, SafetyCaseType.STRATEGY],
    [SafetyCaseType.SOLUTION]: [SafetyCaseType.GOAL],
    [SafetyCaseType.CONTEXT]: [SafetyCaseType.GOAL],
    [SafetyCaseType.STRATEGY]: [SafetyCaseType.GOAL],
  };

/**
 * Defines an artifact of a project.
 */
export interface ArtifactSchema {
  /**
   * A unique UUID identifying an artifact across versions.
   */
  id: string;
  /**
   * A unique UUID identifying an artifact across versions.
   */
  baseEntityId?: string;
  /**
   * The name of the artifact.
   */
  name: string;
  /**
   * A summary of the artifact.
   */
  summary?: string;
  /**
   * The content of the artifact.
   */
  body: string;
  /**
   * The type of the artifact.
   */
  type: string;
  /**
   * Whether the artifact is a code artifact.
   */
  isCode: boolean;
  /**
   * The ids of documents that display this artifact.
   */
  documentIds: string[];
  /**
   * The type of document this artifact is displayed in.
   */
  documentType?: DocumentType;
  /**
   * For FTA logic nodes,  the logical operator of this node.
   */
  logicType?: FTANodeType;
  /**
   * For safety case nodes, the type of safety case node.
   */
  safetyCaseType?: SafetyCaseType;
  /**
   * Represents a collection of custom attributes on an artifact.
   */
  attributes?: AttributeCollectionSchema;
}

/**
 * Defines an artifact with its custom fields flattened into the artifact data.
 */
export type FlatArtifact = Record<string, string | boolean> &
  Pick<ArtifactSchema, ""id"" | ""name"" | ""type"" | ""summary"" | ""isCode"">;
"
src/types/domain/attribute.ts,"/**
 * Enumerates the type of attribute properties.
 */
export enum AttributeType {
  text = ""text"", // String
  paragraph = ""paragraph"", // String
  select = ""select"", // String
  multiselect = ""multiselect"", // String Array
  relation = ""relation"", // String Array
  date = ""date"", // ISO Date String
  int = ""int"", // Integer
  float = ""float"", // Float
  boolean = ""boolean"", // Boolean
}

/**
 * Defines a custom attribute being tracked for a project.
 */
export interface AttributeSchema {
  /**
   * The key to this attribute within an artifact's `customFields` object.
   */
  key: string;
  /**
   * The label for this attribute
   */
  label: string;
  /**
   * The type of data represented by this attribute.
   */
  type: AttributeType;
  /**
   * Any pre-set options for this custom field to choose from.
   */
  options?: string[];
  /**
   * The min-value for a number field.
   */
  min?: number;
  /**
   * The max-value for a number field.
   */
  max?: number;
}

/**
 * A list of the attributes to lay out and their positions.
 */
export interface AttributePositionSchema {
  /**
   * The attribute key for this item.
   */
  key: string;
  /**
   * The x position in the layout.
   */
  x: number;
  /**
   * The y position in the layout.
   */
  y: number;
  /**
   * The height in the layout.
   */
  height: number;
  /**
   * The width in the layout.
   */
  width: number;
}

/**
 * Defines a layout of custom attributes for some set of artifact types.
 */
export interface AttributeLayoutSchema {
  /**
   * The ID of this attribute layout.
   */
  id: string;
  /**
   * The name of this attribute layout.
   */
  name: string;
  /**
   * The list of artifact types to display this attribute layout on.
   * If empty, this attribute will be displayed for all.
   */
  artifactTypes: string[];
  /**
   * A list of the attributes to lay out and their positions.
   */
  positions: AttributePositionSchema[];
}

/**
 * Represents all possible data types of an attribute.
 */
export type AttributeDataType =
  | string
  | string[]
  | number
  | boolean
  | undefined;

/**
 * Represents a collection of custom attributes, keyed by their `key` value.
 */
export type AttributeCollectionSchema = Record<string, AttributeDataType>;
"
src/types/domain/hgen.ts,"/**
 * The schema for a request to generate parent artifacts for a set of child artifacts.
 */
export interface GenerateArtifactSchema {
  /**
   * The model to generate the artifact with.
   */
  model?: string;
  /**
   * The artifact IDs to generate a parent artifact for.
   */
  artifacts: string[];
  /**
   * The type of parent artifact to generate.
   */
  targetTypes: string[];
  /**
   * The clusters of artifact ids to generate a parent artifact for.
   * If empty, artifacts will automatically be clustered.
   * If not empty, artifacts will be clustered according to the provided clusters.
   */
  clusters?: string[][];
}
"
src/types/domain/files.ts,"import { MatrixSchema, ModelType, GenerationModelSchema } from ""@/types/domain"";

/**
 * Defines a trace matrix generation request.
 */
export interface GeneratedMatrixSchema {
  /**
   * The default model to use to generate links.
   */
  method?: ModelType;
  /**
   * The custom model used to generate links.
   */
  model?: GenerationModelSchema;
  /**
   * The artifact levels to trace with method.
   */
  artifactLevels: MatrixSchema[];
}
"
src/util/enum-helper.ts,"import {
  ApprovalType,
  ArtifactDeltaState,
  AttributeType,
  CreatorTabTypes,
  DocumentType,
  FTANodeType,
  LoaderTabTypes,
  ModelShareType,
  ModelType,
  ProjectRole,
  ProjectTableTabTypes,
  SafetyCaseType,
  SearchMode,
  SearchSelectOption,
  SelectOption,
  SettingsTabTypes,
  TraceCountTypes,
  TracePredictionTabTypes,
} from ""@/types"";
import { enumToDisplay } from ""@/util/string-helper"";

/**
 * Converts an enum value into a selectable option with a title case name.
 *
 * @param enumValue - The enum value in upper snake case to convert.
 * @param name - The name of the option, which will bne generated if not given.
 * @return The selectable option.
 */
export function createEnumOption(
  enumValue: string,
  name?: string
): SelectOption {
  return { id: enumValue, name: name || enumToDisplay(enumValue) };
}

/**
 * Returns display names for each document type.
 *
 * @return The select option names and ids.
 */
export function documentTypeOptions(): SelectOption[] {
  return [
    createEnumOption(DocumentType.ARTIFACT_TREE, ""Default""),
    createEnumOption(DocumentType.FTA, ""FTA""),
    createEnumOption(DocumentType.SAFETY_CASE),
    createEnumOption(DocumentType.FMEA, ""FMEA""),
    createEnumOption(DocumentType.FMECA, ""FMECA""),
  ];
}

/**
 * Returns display names for each safety case type.
 *
 * @return The select option names and ids.
 */
export function safetyCaseOptions(): SelectOption[] {
  return [
    createEnumOption(SafetyCaseType.CONTEXT),
    createEnumOption(SafetyCaseType.GOAL),
    createEnumOption(SafetyCaseType.STRATEGY),
    createEnumOption(SafetyCaseType.SOLUTION),
  ];
}

/**
 * Returns display names for each logic type.
 *
 * @return The select option names and ids.
 */
export function logicTypeOptions(): SelectOption[] {
  return [createEnumOption(FTANodeType.AND), createEnumOption(FTANodeType.OR)];
}

/**
 * Returns display names for each delta type.
 *
 * @return The select option names and ids.
 */
export function deltaTypeOptions(): SelectOption[] {
  return [
    createEnumOption(ArtifactDeltaState.NO_CHANGE),
    createEnumOption(ArtifactDeltaState.ADDED),
    createEnumOption(ArtifactDeltaState.MODIFIED),
    createEnumOption(ArtifactDeltaState.REMOVED),
  ];
}

/**
 * Returns display names for each trace count type.
 *
 * @return The select option names and ids.
 */
export function traceCountOptions(): SelectOption[] {
  return [
    createEnumOption(TraceCountTypes.all, ""All Artifacts""),
    createEnumOption(TraceCountTypes.onlyTraced, ""Only Traced Artifacts""),
    createEnumOption(TraceCountTypes.notTraced, ""Only Orphan Artifacts""),
  ];
}

/**
 * Returns display names for each approval type.
 *
 * @return The select option names and ids.
 */
export function approvalTypeOptions(): SelectOption[] {
  return [
    createEnumOption(ApprovalType.UNREVIEWED),
    createEnumOption(ApprovalType.APPROVED),
    createEnumOption(ApprovalType.DECLINED),
  ];
}

/**
 * Returns display names for each trace model type.
 *
 * @return The select option names and ids.
 */
export function traceModelOptions(): SelectOption[] {
  return [
    createEnumOption(
      ModelType.NLBert,
      ""Slower, higher quality links. Traces free-text artifacts to other free-text artifacts.""
    ),
    createEnumOption(
      ModelType.PLBert,
      ""Slower, higher quality links. Traces free-text artifacts to source code.""
    ),
    createEnumOption(
      ModelType.AutomotiveBert,
      ""Slower, high quality links for automotive projects.""
    ),
    createEnumOption(ModelType.VSM, ""Faster, lower quality links.""),
  ];
}

/**
 * Returns display names for project role type.
 *
 * @return The select option names and ids.
 */
export function projectRoleOptions(): SelectOption[] {
  return [
    createEnumOption(ProjectRole.OWNER),
    createEnumOption(ProjectRole.ADMIN),
    createEnumOption(ProjectRole.EDITOR),
    createEnumOption(ProjectRole.VIEWER),
  ];
}

/**
 * Returns display names for model share options.
 *
 * @return The select option names and ids.
 */
export function modelShareOptions(): SelectOption[] {
  return [
    createEnumOption(ModelShareType.CLONE, ""Clone the model""),
    createEnumOption(ModelShareType.REUSE, ""Reuse the same model""),
  ];
}

/**
 * Returns display names for project creator tabs.
 *
 * @return The select option names and ids.
 */
export function creatorTabOptions(): SelectOption[] {
  return [
    createEnumOption(CreatorTabTypes.standard, ""Standard Upload""),
    createEnumOption(CreatorTabTypes.bulk, ""Bulk Upload""),
    createEnumOption(CreatorTabTypes.import, ""Integrations Import""),
  ];
}

/**
 * Returns display names for project loader tabs.
 *
 * @return The select option names and ids.
 */
export function loaderTabOptions(): SelectOption[] {
  return [
    createEnumOption(LoaderTabTypes.load, ""Open Project""),
    createEnumOption(LoaderTabTypes.uploads, ""Project Uploads""),
  ];
}

/**
 * Returns display names for trace prediction tabs.
 *
 * @return The select option names and ids.
 */
export function tracePredictionTabOptions(): SelectOption[] {
  return [
    createEnumOption(TracePredictionTabTypes.models, ""Models""),
    createEnumOption(TracePredictionTabTypes.generation, ""Trace Generation""),
    createEnumOption(TracePredictionTabTypes.approval, ""Trace Approval""),
  ];
}

/**
 * Returns display names for project settings tabs.
 *
 * @return The select option names and ids.
 */
export function settingsTabOptions(): SelectOption[] {
  return [
    createEnumOption(SettingsTabTypes.members, ""Members""),
    createEnumOption(SettingsTabTypes.upload, ""Data Upload""),
    createEnumOption(SettingsTabTypes.integrations, ""Data Integrations""),
    createEnumOption(SettingsTabTypes.attributes, ""Custom Attributes""),
  ];
}

/**
 * Returns display names for model training tabs.
 *
 * @return The select option names and ids.
 */
export function trainingTabOptions(): SelectOption[] {
  return [
    createEnumOption(""documents"", ""Documents""),
    createEnumOption(""repositories"", ""Repositories""),
    createEnumOption(""keywords"", ""Keywords""),
    createEnumOption(""project"", ""Project Data""),
  ];
}

/**
 * Returns display names for table view tabs.
 *
 * @return The select option names and ids.
 */
export function tableViewTabOptions(): SelectOption[] {
  return [
    createEnumOption(ProjectTableTabTypes.artifact, ""Artifacts""),
    createEnumOption(ProjectTableTabTypes.trace, ""Trace Links""),
    createEnumOption(ProjectTableTabTypes.approve, ""Trace Approval""),
  ];
}

/**
 * Returns display names for attribute types.
 *
 * @return The select option names and ids.
 */
export function attributeTypeOptions(): SelectOption[] {
  return [
    createEnumOption(AttributeType.text, ""Text""),
    createEnumOption(AttributeType.paragraph, ""Paragraph""),
    createEnumOption(AttributeType.select, ""Select""),
    createEnumOption(AttributeType.multiselect, ""Multiselect""),
    createEnumOption(AttributeType.relation, ""Relation""),
    createEnumOption(AttributeType.date, ""Date""),
    createEnumOption(AttributeType.int, ""Integer""),
    createEnumOption(AttributeType.float, ""Number""),
    createEnumOption(AttributeType.boolean, ""Yes/No""),
  ];
}

/**
 * Returns display names for search modes.
 *
 * @return The select option names, descriptions, and ids.
 */
export function searchModeOptions(): SearchSelectOption[] {
  return [
    {
      id: SearchMode.prompt,
      name: ""Prompt"",
      description: ""Find artifacts that match a search prompt"",
      placeholder: ""Enter a prompt..."",
    },
    {
      id: SearchMode.artifacts,
      name: ""Artifact"",
      description: ""Find artifacts related to a specific artifact"",
      placeholder: ""Search artifacts..."",
      artifactSearch: true,
    },
    {
      id: SearchMode.search,
      name: ""Basic"",
      description: ""Search through currently displayed artifacts"",
      placeholder: ""Search current artifacts..."",
      artifactSearch: true,
    },
  ];
}
"
src/util/document-helper.ts,"import { DocumentType, SelectOption } from ""@/types"";
import { documentTypeOptions } from ""@/util/enum-helper"";

/**
 * Returns the document types of artifacts that can be created on a given document.
 *
 * @return The select option names and ids.
 */
export function documentTypeMap(): { [type in DocumentType]: SelectOption[] } {
  const options = documentTypeOptions();

  return {
    [DocumentType.ARTIFACT_TREE]: [options[0]],
    [DocumentType.FTA]: [options[0], options[1]],
    [DocumentType.SAFETY_CASE]: [options[0], options[2]],
    [DocumentType.FMEA]: [options[0], options[3]],
    [DocumentType.FMECA]: [options[0], options[4]],
  };
}

/**
 * Returns whether the given document represents a table.
 *
 * @param type - The current document type.
 * @return Whether the type is for a table.
 */
export function isTableDocument(type: DocumentType): boolean {
  const tableDocuments = [DocumentType.FMEA, DocumentType.FMECA];

  return tableDocuments.includes(type);
}
"
src/util/table-helper.ts,"/**
 * Sorts table rows alphabetically.
 * @param rows - The rows to sort.
 * @param sortBy - The item attribute to sort by.
 * @param descending - Whether to sort in descending order.
 */
export function sortRows(
  rows: Record<string, unknown>[],
  sortBy: string | undefined,
  descending: boolean
): Record<string, unknown>[] {
  const sortedRows = [...rows];

  if (sortBy) {
    sortedRows.sort((a, b) => {
      const x = descending ? b : a;
      const y = descending ? a : b;

      return String(x[sortBy]) > String(y[sortBy])
        ? 1
        : String(x[sortBy]) < String(y[sortBy])
        ? -1
        : 0;
    });
  }

  return sortedRows;
}
"
src/util/object-factory.ts,"import {
  ArtifactSchema,
  CommitSchema,
  ConfirmationType,
  ConfirmDialogueMessage,
  DocumentSchema,
  DocumentType,
  FTANodeType,
  IdentifierSchema,
  MessageType,
  ModelType,
  VersionDeltaSchema,
  ProjectSchema,
  SafetyCaseType,
  SessionSchema,
  SnackbarMessage,
  GenerationModelSchema,
  UserSchema,
  VersionSchema,
  AttributeSchema,
  AttributeType,
  AttributeLayoutSchema,
  MatrixSchema,
  GeneratedMatrixSchema,
} from ""@/types"";

/**
 * @return An empty snackbar message.
 */
export function createSnackbarMessage(): SnackbarMessage {
  return {
    errors: [],
    message: """",
    type: MessageType.clear,
  };
}

/**
 * @return An empty confirm dialog message.
 */
export function createConfirmDialogueMessage(): ConfirmDialogueMessage {
  return {
    type: ConfirmationType.CLEAR,
    title: """",
    body: """",
    statusCallback: () => null,
  };
}

/**
 * @return An empty user.
 */
export function createUser(): UserSchema {
  return {
    userId: """",
    email: """",
  };
}

/**
 * @return An empty session.
 */
export function createSession(): SessionSchema {
  return {
    token: """",
    versionId: """",
  };
}

/**
 * @return A project identifier initialized to the given values.
 */
export function createProjectIdentifier(
  identifier?: Partial<IdentifierSchema>
): IdentifierSchema {
  return {
    name: identifier?.name || """",
    projectId: identifier?.projectId || """",
    description: identifier?.description || """",
    owner: identifier?.owner || """",
    members: identifier?.members || [],
  };
}

/**
 * @return A project initialized to the given values.
 */
export function createProject(project?: Partial<ProjectSchema>): ProjectSchema {
  return {
    ...createProjectIdentifier(project),
    artifacts: project?.artifacts || [],
    traces: project?.traces || [],
    projectVersion: project?.projectVersion,
    artifactTypes: project?.artifactTypes || [],
    traceMatrices: project?.traceMatrices || [],
    documents: project?.documents || [],
    warnings: project?.warnings || {},
    layout: project?.layout || {},
    subtrees: project?.subtrees || {},
    models: project?.models || [],
    attributes: project?.attributes || [],
    attributeLayouts: project?.attributeLayouts || [],
  };
}

/**
 * @return An empty project delta.
 */
export function createProjectDelta(): VersionDeltaSchema {
  return {
    artifacts: {
      added: {},
      modified: {},
      removed: {},
    },
    traces: {
      added: {},
      modified: {},
      removed: {},
    },
  };
}

/**
 * @return An artifact initialized to the given props.
 */
export function createArtifact(
  artifact?: Partial<ArtifactSchema>
): ArtifactSchema {
  return {
    id: artifact?.id || """",
    baseEntityId: artifact?.baseEntityId || """",
    name: artifact?.name || """",
    summary: artifact?.summary || """",
    body: artifact?.body || """",
    type: artifact?.type || """",
    isCode: artifact?.isCode || false,
    documentType: artifact?.documentType || DocumentType.ARTIFACT_TREE,
    documentIds: artifact?.documentIds || [],
    safetyCaseType: artifact?.safetyCaseType || SafetyCaseType.GOAL,
    logicType: artifact?.logicType || FTANodeType.AND,
    attributes: artifact?.attributes || {},
  };
}

/**
 * Creates an artifact that may be initialized to a specific document type.
 *
 * @param artifact - The base artifact to create from.
 * @param type - If true or matching no values, a normal artifact will be created.
 *               If equal to an `FTANodeType`, an FTA node will be created.
 *               If equal to a `SafetyCaseType`, a safety case node will be created.
 *               If equal to a `DocumentType.FMEA`, an FMEA node will be created.
 * @return An artifact initialized to the given props.
 */
export function createArtifactOfType(
  artifact: Partial<ArtifactSchema> | undefined,
  type?: true | string
): ArtifactSchema {
  if (typeof type === ""string"") {
    const isFTA = type in FTANodeType;
    const isSC = type in SafetyCaseType;

    if (isFTA || type === DocumentType.FTA) {
      return createArtifact({
        ...artifact,
        documentType: DocumentType.FTA,
        logicType: isFTA ? (type as FTANodeType) : FTANodeType.AND,
        type: DocumentType.FTA,
      });
    } else if (isSC) {
      return createArtifact({
        ...artifact,
        documentType: DocumentType.SAFETY_CASE,
        safetyCaseType: isSC
          ? (type as SafetyCaseType)
          : SafetyCaseType.CONTEXT,
        type: DocumentType.SAFETY_CASE,
      });
    } else if (type === DocumentType.FMEA) {
      return createArtifact({
        ...artifact,
        documentType: DocumentType.FMEA,
        type: DocumentType.FMEA,
      });
    }
  }

  return createArtifact(artifact);
}

/**
 * @returns An empty commit.
 */
export function createCommit(version: VersionSchema): CommitSchema {
  return {
    commitVersion: version,
    artifacts: {
      added: [],
      removed: [],
      modified: [],
    },
    traces: {
      added: [],
      removed: [],
      modified: [],
    },
  };
}

/**
 * @return An document initialized to the given props.
 */
export function createDocument(
  document?: Partial<DocumentSchema>
): DocumentSchema {
  return {
    documentId: document?.documentId || """",
    project: document?.project || {
      projectId: """",
      name: """",
      description: """",
      owner: """",
      members: [],
    },
    name: document?.name || """",
    type: document?.type || DocumentType.ARTIFACT_TREE,
    artifactIds: document?.artifactIds || [],
    description: document?.description || """",
    layout: document?.layout || {},
  };
}

/**
 * @return A model initialized to the given props.
 */
export function createModel(
  model?: Partial<GenerationModelSchema>
): GenerationModelSchema {
  return {
    id: model?.id || """",
    name: model?.name || """",
    baseModel: model?.baseModel || ModelType.NLBert,
  };
}

/**
 * @return An attribute initialized to the given props.
 */
export function createAttribute(
  attribute?: Partial<AttributeSchema>
): AttributeSchema {
  return {
    key: attribute?.key || """",
    label: attribute?.label || """",
    type: attribute?.type || AttributeType.text,
    options: attribute?.options,
    min: attribute?.min,
    max: attribute?.max,
  };
}

/**
 * @return An attribute layout initialized to the given props.
 */
export function createAttributeLayout(
  layout?: Partial<AttributeLayoutSchema>
): AttributeLayoutSchema {
  return {
    id: layout?.id || """",
    name: layout?.name || """",
    artifactTypes: layout?.artifactTypes || [],
    positions: layout?.positions?.map((pos) => ({ ...pos })) || [],
  };
}

/**
 * Creates a generated trace matrix defined over many artifact levels for
 * some tracing method or custom model.
 *
 * @param artifactLevels - The artifact levels to train on.
 * @param method - If a baseline method is used, this defines that method.
 * @param model - If a custom model is used,
 */
export function createGeneratedMatrix(
  artifactLevels: MatrixSchema[],
  method?: ModelType,
  model?: GenerationModelSchema
): GeneratedMatrixSchema {
  return {
    method: model?.baseModel || method || undefined,
    model,
    artifactLevels: artifactLevels,
  };
}
"
src/util/object-helper.ts,"/**
 * Converts a value or an object containing that value to the value itself.
 *
 * @param objOrValue - A value, or an object containing the same value.
 * @param key - The key of the object containing the value.
 * @return The standardized value.
 */
export function standardizeValue<
  T extends string,
  V extends string | number | boolean
>(objOrValue: V | Record<T, V>, key: T): V {
  return typeof objOrValue === ""object"" ? objOrValue[key] : objOrValue;
}

/**
 * Converts a list of values, or objects containing those values, to a list of the value itself.
 *
 * @param objOrValueArray - A list of values, or objects containing those values.
 * @param key - The key of the object containing the value.
 * @return The standardized value array.
 */
export function standardizeValueArray<T extends string>(
  objOrValueArray: string[] | Record<T, string>[],
  key: T
): string[] {
  return objOrValueArray.map((objOrValue) => standardizeValue(objOrValue, key));
}

/**
 * Removes all items with fields that that match the given values.
 *
 * @param items - The items to filter.
 * @param key - The object field to check the values against.
 * @param removeValues - The values to remove if matched.
 * @return The filtered values.
 */
export function removeMatches<O, K extends keyof O>(
  items: O[],
  key: K,
  removeValues: O[K][]
): O[] {
  return items.filter((item) => !removeValues.includes(item[key]));
}

/**
 * Preserves all items with fields that that match the given values.
 *
 * @param items - The items to filter.
 * @param key - The object field to check the values against.
 * @param preserveValues - The values to preserve if matched.
 * @return The filtered values.
 */
export function preserveMatches<O, K extends keyof O>(
  items: O[],
  key: K,
  preserveValues: O[K][]
): O[] {
  return items.filter((item) => preserveValues.includes(item[key]));
}

/**
 * Collects items in an array by equivalent field values.
 *
 * @param items - The items to convert.
 * @param key  The key of the items to match on.
 * @return A collection of items keyed by their values of the given field.
 */
export function collectByField<O, K extends keyof O>(
  items: O[],
  key: K
): Record<string, O[]> {
  return items.reduce<Record<string, O[]>>(
    (acc, item) => ({
      ...acc,
      [String(item[key])]: [...(acc[String(item[key])] || []), item],
    }),
    {}
  );
}

/**
 * Removes all keys in the object besides those listed.
 *
 * @param obj - The object to remove from.
 * @param keys - The keys to preserve.
 * @return A new object with only the preserved keys.
 */
export function preserveObjectKeys<O, K extends keyof O>(
  obj: O,
  keys: K[]
): Pick<O, K> {
  return Object.entries(obj as Record<string, unknown>)
    .filter(([key]) => (keys as string[]).includes(key))
    .reduce((acc, cur) => ({ ...acc, ...cur }), {} as O);
}
"
src/util/type-checks.ts,"import {
  ArtifactSchema,
  ArtifactCytoElementData,
  ArtifactDeltaSchema,
  EntityModificationSchema,
} from ""@/types"";

/**
 * Returns whether the given artifact or delta is a modified artifact.
 *
 * @param artifact - The artifact to check.
 * @return Whether this item is a modified artifact.
 */
export function isModifiedArtifact(
  artifact: ArtifactDeltaSchema
): artifact is EntityModificationSchema<ArtifactSchema> {
  const requiredFields = [""before"", ""after""];
  return containsFields(artifact, requiredFields);
}

/**
 * Returns whether the given artifact or delta is an artifact.
 *
 * @param artifact - The artifact to check.
 * @return Whether this item is an artifact.
 */
export function isArtifact(
  artifact: ArtifactDeltaSchema
): artifact is ArtifactSchema {
  const requiredFields = [""id"", ""body"", ""type""];
  return containsFields(artifact, requiredFields);
}

/**
 * Returns whether the given cytoscape data is an artifact.
 *
 * @param artifact - The artifact to check.
 * @return Whether this item is an artifact.
 */
export function isArtifactData(
  artifact: unknown
): artifact is ArtifactCytoElementData {
  const requiredFields = [
    ""body"",
    ""artifactName"",
    ""artifactType"",
    ""artifactDeltaState"",
    ""isSelected"",
    ""opacity"",
  ];
  return containsFields(artifact, requiredFields);
}

/**
 * Returns whether an object contains certain fields.
 *
 * @param object - The object to check.
 * @param fields - The fields required to exist on the object.
 * @return Whether this object has all required fields.
 */
function containsFields(object: unknown, fields: string[]): boolean {
  return fields
    .map((field) => field in (object as Record<string, unknown>))
    .reduce((prev, curr) => prev && curr, true);
}
"
src/util/enabled-features.ts,"import { TrainingStepSchema } from ""@/types"";

/**
 * Example steps for model training.
 */
export const EXAMPLE_TRAINING_STEPS = [
  {
    type: ""document"",
    updatedAt: new Date(Date.now()).toISOString(),
    status: ""Completed"",
    keywords: [],
    documents: [
      {
        name: ""BOSCH Automotive Handbook.pdf"",
        url: ""https://path-to-gcp-bucket-file"",
      },
    ],
    repositories: [],
    projects: [],
  },
  {
    type: ""repository"",
    updatedAt: new Date(Date.now()).toISOString(),
    status: ""Completed"",
    keywords: [],
    documents: [],
    repositories: [
      {
        name: ""organization/my-project"",
        url: ""https://path-to-git-hub-repo"",
      },
    ],
    projects: [],
  },
  {
    type: ""project"",
    updatedAt: new Date(Date.now()).toISOString(),
    status: ""In Progress"",
    keywords: [],
    documents: [],
    repositories: [],
    projects: [
      {
        id: ""123"",
        name: ""My Project"",
        levels: [
          {
            source: ""Designs"",
            target: ""Designs"",
          },
          {
            source: ""Designs"",
            target: ""Requirements"",
          },
        ],
      },
    ],
  },
] as TrainingStepSchema[];

/**
 * A mapping of whether certain test features are enabled.
 */
export const ENABLED_FEATURES = {
  EXAMPLE_TRAINING_STEPS: false,
};
"
src/util/trace-helper.ts,"import {
  ApprovalType,
  ArtifactCytoElementData,
  ArtifactSchema,
  LinkSchema,
  TraceLinkSchema,
  TraceMatrixSchema,
  TraceType,
} from ""@/types"";

/**
 * Returns the trace ID made from the given source and target IDs.
 *
 * @param source - The source ID.
 * @param target - THe target ID.
 * @return The standardized ID of the source joined to the target.
 */
export function getTraceId(source: string, target: string): string {
  return `${source}-${target}`;
}

/**
 * Returns the trace ID made from the given source and target IDs.
 *
 * @param traceLink - The trace link.
 * @return The standardized ID of the source joined to the target.
 */
export function extractTraceId(traceLink: LinkSchema): string {
  return `${traceLink.sourceName}-${traceLink.targetName}`;
}

/**
 * Creates a predicate for matching a trace.
 *
 * @param sourceId - The source to match.
 * @param targetId - The target to match.
 * @param ignoreDirection - If true, will match traces in both directions.
 * @return A predicate for finding matching links.
 */
export function matchTrace(
  sourceId: string,
  targetId: string,
  ignoreDirection = false
) {
  return (trace: TraceLinkSchema): boolean =>
    ignoreDirection
      ? (trace.sourceId === sourceId && trace.targetId === targetId) ||
        (trace.targetId === sourceId && trace.sourceId === targetId)
      : trace.sourceId === sourceId && trace.targetId === targetId;
}

/**
 * Determines if the trace link is allowed based on the type of the nodes.
 *
 * @param source - The source artifact.
 * @param target - The target artifact.
 * @param traceMatrices - The existing links between types.
 * @return Whether the link is allowed.
 */
export function isLinkAllowedByType(
  source: ArtifactSchema | ArtifactCytoElementData,
  target: ArtifactSchema | ArtifactCytoElementData,
  traceMatrices: TraceMatrixSchema[]
): boolean {
  const sourceType =
    ""artifactType"" in source ? source.artifactType : source.type;
  const targetType =
    ""artifactType"" in target ? target.artifactType : target.type;

  return sourceType === targetType
    ? true
    : !traceMatrices.find(
        (matrix) =>
          matrix.sourceType === targetType && matrix.targetType === sourceType
      );
}

/**
 * Returns helper functions for determining a link's status.
 *
 * @param traceLink - The link to check.
 * @return Status callbacks.
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function linkStatus(traceLink?: TraceLinkSchema) {
  const canBeModified = () => traceLink?.traceType === TraceType.GENERATED;

  return {
    canBeModified,
    canBeApproved: () =>
      canBeModified() && traceLink?.approvalStatus !== ApprovalType.APPROVED,
    canBeDeclined: () =>
      canBeModified() && traceLink?.approvalStatus !== ApprovalType.DECLINED,
    canBeReset: () =>
      canBeModified() && traceLink?.approvalStatus !== ApprovalType.UNREVIEWED,
  };
}
"
src/util/artifact-helper.ts,"import { ArtifactSchema, FlatArtifact } from ""@/types"";

/**
 * Decides whether to filter an artifact out of view.
 *
 * @param artifact - The artifact to check.
 * @param queryText - The current query text.
 * @return If true, the artifact should be kept.
 */
export function filterArtifacts(
  artifact: ArtifactSchema,
  queryText: string
): boolean {
  const lowercaseQuery = queryText.toLowerCase();
  const { name, type, body } = artifact;

  return (
    name.toLowerCase().includes(lowercaseQuery) ||
    type.toLowerCase().includes(lowercaseQuery) ||
    body.toLowerCase().includes(lowercaseQuery)
  );
}

/**
 * Flattens an artifacts custom fields into the same object.
 *
 * @param artifact -The artifact to flatten.
 * @return The flattened artifact.
 */
export function flattenArtifact(artifact: ArtifactSchema): FlatArtifact {
  return {
    id: artifact.id,
    name: artifact.name,
    type: artifact.type,
    body: artifact.body,
    summary: artifact.summary || """",
    isCode: artifact.isCode || false,
    ...(artifact.attributes || {}),
  };
}

/**
 * Sorts a list of artifacts so that selected ones appear first.
 * @param artifacts - The list of artifacts to sort.
 * @param selectedIds - The list of selected artifact IDs.
 * @return The sorted list of artifacts.
 */
export function sortSelectedArtifactsToTop(
  artifacts: ArtifactSchema[],
  selectedIds: string[] | string | undefined | null
): ArtifactSchema[] {
  return [...artifacts].sort((a, b) => {
    // Move selected options to the top.
    if (selectedIds?.includes(a.id)) {
      return -1;
    } else if (selectedIds?.includes(b.id)) {
      return 1;
    }
    // Keep the original order for non-selected options.
    return artifacts.indexOf(a) - artifacts.indexOf(b);
  });
}
"
src/util/globals.ts,"/**
 * The id of the default layout that is automatically generated.
 */
export const DEFAULT_LAYOUT_ID = ""default"";

/**
 * The name to display for the default view that shows everything.
 */
export const DEFAULT_VIEW_NAME = ""All Artifacts"";

export const LOGOUT_ERROR = ""Session has timed out. Please log back in."";

/**
 * The amount of nodes at which we need to do graph optimizations.
 */
export const LARGE_NODE_COUNT = 100;

/**
 * The demo user's account.
 */
export const DEMO_ACCOUNT = {
  email: ""view@safa.ai"",
  password: ""safa!"",
};
"
src/util/icons.ts,"import { IconVariant } from ""@/types"";

export const DefaultTypeIcon = ""mdi-alpha-a-box-outline"";

export const TypeIcons = [
  ""mdi-clipboard-text"",
  ""mdi-math-compass"",
  ""mdi-hazard-lights"",
  ""mdi-pine-tree-fire"",
  ""mdi-alpha-a-box"",
  ""mdi-text-box-multiple"",
  ""mdi-code-braces-box"",
  ""mdi-drawing-box"",
  ""mdi-folder"",
  ""mdi-file-table"",
  ""mdi-database"",
  ""mdi-application-cog"",
  ""mdi-account-box-multiple"",
  ""mdi-book-lock"",
  ""mdi-message"",
  ""mdi-book-open"",
];

/**
 * Returns the icon id for the given variant.
 * @param variant - The icon variant.
 * @return The corresponding icon id.
 */
export function getIcon(variant?: IconVariant): string {
  switch (variant) {
    case ""add"":
      return ""mdi-plus"";
    case ""edit"":
      return ""mdi-pencil"";
    case ""save"":
      return ""mdi-content-save"";
    case ""saving"":
      return ""mdi-cloud-upload-outline"";
    case ""delete"":
      return ""mdi-delete"";
    case ""cancel"":
      return ""mdi-close"";
    case ""leave"":
      return ""mdi-tab-remove"";
    case ""info"":
      return ""mdi-alert-circle-outline"";
    case ""error"":
      return ""mdi-alert-circle-outline"";
    case ""invite"":
      return ""mdi-account-plus-outline"";
    case ""success"":
      return ""mdi-check-circle-outline"";
    case ""artifact"":
      return ""mdi-alpha-a-box-outline"";
    // return ""mdi-application-array-outline"";
    case ""trace"":
      return ""mdi-ray-start-arrow"";
    case ""upload"":
      return ""mdi-folder-arrow-up-outline"";
    case ""download"":
      return ""mdi-download"";
    case ""sync"":
      return ""mdi-cloud-sync-outline"";
    case ""integrate"":
      return ""mdi-transit-connection-variant"";
    case ""warning"":
      return ""mdi-hazard-lights"";
    case ""back"":
      return ""mdi-arrow-left"";
    case ""account"":
      return ""mdi-account-circle"";
    case ""search"":
      return ""mdi-magnify"";
    case ""code"":
      return ""mdi-code-json"";
    case ""create-artifact"":
      return ""mdi-folder-plus-outline"";
    case ""create-trace"":
      return ""mdi-ray-start-end"";
    case ""generate"":
      return ""mdi-creation"";
    case ""generate-artifacts"":
      return ""mdi-monitor-shimmer"";
    case ""generate-traces"":
      return ""mdi-chart-timeline-variant-shimmer"";
    case ""notification"":
      return ""mdi-bell-outline"";
    case ""share"":
      return ""mdi-share-variant"";
    case ""logs"":
      return ""mdi-post-outline"";
    case ""more"":
      return ""mdi-dots-horizontal"";
    case ""undo"":
      return ""mdi-undo"";
    case ""redo"":
      return ""mdi-redo"";
    case ""logout"":
      return ""mdi-logout-variant"";
    case ""file"":
      return ""mdi-paperclip"";
    case ""down"":
      return ""mdi-chevron-down"";
    case ""up"":
      return ""mdi-chevron-up"";
    case ""arrow-down"":
      return ""mdi-arrow-down"";
    case ""arrow-up"":
      return ""mdi-arrow-up"";
    case ""fullscreen"":
      return ""mdi-fullscreen"";
    case ""fullscreen-exit"":
      return ""mdi-fullscreen-exit"";
    case ""home-list"":
      return ""mdi-view-list"";
    case ""home-add"":
      return ""mdi-folder-plus-outline"";
    case ""job-complete"":
      return ""mdi-check-circle-outline"";
    case ""job-cancel"":
      return ""mdi-minus-circle-outline"";
    case ""job-fail"":
      return ""mdi-close-circle-outline"";
    case ""trace-approve"":
      return ""mdi-check-circle-outline"";
    case ""trace-decline"":
      return ""mdi-close-circle-outline"";
    case ""trace-decline-all"":
      return ""mdi-close-circle-multiple-outline"";
    case ""trace-unreview"":
      return ""mdi-checkbox-blank-circle-outline"";
    case ""view-tim"":
      return ""mdi-ballot"";
    case ""view-tree"":
      return ""mdi-family-tree"";
    case ""view-table"":
      return ""mdi-table-multiple"";
    case ""view-delta"":
      return ""mdi-compare"";
    case ""graph-zoom-in"":
      return ""mdi-magnify-plus-outline"";
    case ""graph-zoom-out"":
      return ""mdi-magnify-minus-outline"";
    case ""graph-center"":
      return ""mdi-graphql"";
    case ""graph-refresh"":
      return ""mdi-refresh"";
    case ""nav-toggle"":
      return ""mdi-menu-open"";
    case ""nav-home"":
      return ""mdi-home"";
    case ""nav-create"":
      return ""mdi-folder-plus"";
    case ""nav-open"":
      return ""mdi-list-box"";
    case ""nav-uploads"":
      return ""mdi-folder-upload"";
    case ""nav-artifact"":
      return ""mdi-family-tree"";
    case ""nav-trace"":
      return ""mdi-link-box"";
    case ""nav-settings"":
      return ""mdi-cog-box"";
    case ""filter-open"":
      return ""mdi-filter-menu-outline"";
    case ""filter-close"":
      return ""mdi-filter-minus-outline"";
    case ""group-open"":
      return ""mdi-chevron-up"";
    case ""group-open-all"":
      return ""mdi-arrow-expand-all"";
    case ""group-close"":
      return ""mdi-chevron-down"";
    case ""group-close-all"":
      return ""mdi-arrow-collapse-all"";
    default:
      return """";
  }
}
"
src/util/job-helper.ts,"import { IconVariant, JobSchema, JobStatus } from ""@/types"";
import { enumToDisplay, timestampToDisplay } from ""@/util/string-helper"";
import { getEnumColor } from ""@/util/theme"";

/**
 * Returns helpful display information about a job.
 * @param job - The job to display.
 * @return Display information
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function jobStatus(job: JobSchema) {
  return {
    isCompleted: () => job.status === JobStatus.COMPLETED,
    isInProgress: () => job.status === JobStatus.IN_PROGRESS,
    progress: () => {
      switch (job.status) {
        case JobStatus.IN_PROGRESS:
          return (
            `${job.currentProgress}% | ` +
            `${timestampToDisplay(job.lastUpdatedAt)}`
          );
        case JobStatus.COMPLETED:
          return timestampToDisplay(job.completedAt);
        case JobStatus.CANCELLED:
        case JobStatus.FAILED:
          return timestampToDisplay(job.lastUpdatedAt);
        default:
          return """";
      }
    },
    status: () => enumToDisplay(job.status || """"),
    color: () => getEnumColor(job.status || """"),
    icon: (): IconVariant => {
      switch (job.status) {
        case JobStatus.CANCELLED:
          return ""job-cancel"";
        case JobStatus.FAILED:
          return ""job-fail"";
        default:
          return ""job-complete"";
      }
    },
  };
}
"
src/util/index.ts,"export * from ""./globals"";
export * from ""./string-helper"";
export * from ""./object-helper"";
export * from ""./artifact-helper"";
export * from ""./trace-helper"";
export * from ""./type-checks"";
export * from ""./theme"";
export * from ""./enum-helper"";
export * from ""./object-factory"";
export * from ""./sub-tree-operations"";
export * from ""./icons"";
export * from ""./job-helper"";
export * from ""./table-helper"";
export * from ""./table-headers"";
export * from ""./document-helper"";
export * from ""./commit-builder"";

export * from ""./enabled-features"";
"
src/util/theme.ts,"import {
  ApprovalType,
  ArtifactDeltaState,
  DeltaType,
  JobStatus,
  MessageType,
  ThemeColor,
} from ""@/types"";

export enum Colors {
  white = ""#FFFFFF"",
  black = ""#1E1E1E"",

  grey = ""#41533F"",
  greyLight = ""#bdbdbd"",
  greyLightest = ""#EDEFEB"",
  greyDark = ""#616161"",
  greyDarkest = ""#333"",

  green = ""#55A630"",
  greenDark = ""#488E27"",

  blue = ""#3055A6"",

  red = ""#A63055"",
  redLight = ""#D51552"",

  orange = ""#fb8500"",

  brown = ""#b6ad90"",
  brownDark = ""#a68a64"",

  gradient1 = ""#81C644"",
  gradient2 = ""#61AD73"",
  gradient3 = ""#4194A2"",
  gradient4 = ""#207BD0"",
  gradient5 = ""#0062FF"",
}

/**
 * The gradient colors used in the theme.
 */
export const ThemeGradient = {
  nodeGradient1: Colors.gradient1,
  nodeGradient2: Colors.gradient2,
  nodeGradient3: Colors.gradient3,
  nodeGradient4: Colors.gradient4,
  nodeGradient5: Colors.gradient5,
};

/**
 * Defines all colors in the theme.
 */
export const ThemeColors = {
  primary: Colors.greenDark,
  primaryDark: Colors.green,
  secondary: Colors.brownDark,
  accent: Colors.green,
  error: Colors.red,
  errorDark: Colors.redLight,

  whiteBg: Colors.white,
  lightBg: Colors.greyLightest,
  lightText: Colors.grey,
  lightTextCaption: Colors.greyDark,
  lightSelected: Colors.greyLightest,

  blackBg: Colors.black,
  darkBg: Colors.greyDarkest,
  darkText: Colors.white,
  darkTextCaption: Colors.greyLight,
  darkSelected: Colors.greyLightest,

  added: Colors.green,
  modified: Colors.blue,
  removed: Colors.red,
  warning: Colors.orange,
  unchanged: Colors.grey,

  nodeDefault: Colors.brownDark,
  nodeGenerated: Colors.brown,

  ...ThemeGradient,
};

/**
 * The colors used in light mode.
 */
export const lightPalette: Record<string, string> = {
  primary: ThemeColors.primary,
  secondary: ThemeColors.secondary,
  accent: ThemeColors.accent,

  info: ThemeColors.primary,
  warning: ThemeColors.warning,
  negative: ThemeColors.error,
  positive: ThemeColors.added,

  text: ThemeColors.lightText,
  textCaption: ThemeColors.lightTextCaption,
  neutral: ThemeColors.whiteBg,
  background: ThemeColors.lightBg,
  selected: ThemeColors.lightSelected,

  added: ThemeColors.added,
  modified: ThemeColors.modified,
  removed: ThemeColors.removed,
  flagged: ThemeColors.warning,
  unchanged: ThemeColors.unchanged,

  nodeDefault: ThemeColors.nodeDefault,
  nodeGenerated: ThemeColors.nodeGenerated,

  ...ThemeGradient,
};

/**
 * The colors used in dark mode.
 */
export const darkPalette: Record<string, string> = {
  primary: ThemeColors.primaryDark,
  secondary: ThemeColors.secondary,
  accent: ThemeColors.accent,

  info: ThemeColors.primary,
  warning: ThemeColors.warning,
  negative: ThemeColors.errorDark,
  positive: ThemeColors.added,

  text: ThemeColors.darkText,
  textCaption: ThemeColors.darkTextCaption,
  neutral: ThemeColors.blackBg,
  background: ThemeColors.darkBg,
  selected: ThemeColors.darkSelected,

  added: ThemeColors.added,
  modified: ThemeColors.modified,
  removed: ThemeColors.removed,
  flagged: ThemeColors.warning,
  unchanged: ThemeColors.unchanged,

  nodeDefault: ThemeColors.nodeDefault,
  nodeGenerated: ThemeColors.nodeGenerated,

  ...ThemeGradient,
};

/**
 * Returns the color code based on a type color name.
 * @param colorName - The color name to get the color for.
 * @return The color.
 */
export function convertTypeToColor(
  colorName: keyof typeof ThemeGradient | string
): string {
  return (
    (ThemeGradient as Record<string, string>)[colorName] || ThemeColors.primary
  );
}

/**
 * Returns the background color for the given confidence score.
 * @param score - The score to get the color for.
 * @return The color.
 */
export function getScoreColor(score: number | string): ThemeColor {
  const [ints, decimals = ""0""] = String(score).split(""."");
  const tenths = decimals[0];

  if (ints === ""1"" || [""8"", ""9""].includes(tenths)) {
    return ""positive"";
  } else if ([""6"", ""7""].includes(tenths)) {
    return ""secondary"";
  } else {
    return ""negative"";
  }
}

/**
 * Returns the background color for an approval state.
 * @param state - The state to get the color for.
 * @return The color.
 */
export function getEnumColor(
  state:
    | ApprovalType
    | ArtifactDeltaState
    | DeltaType
    | MessageType
    | JobStatus
    | string
): ThemeColor {
  switch (state) {
    case ArtifactDeltaState.ADDED:
    case ApprovalType.APPROVED:
    case JobStatus.COMPLETED:
    case MessageType.success:
    case ""added"":
      return ""added"";
    case ArtifactDeltaState.MODIFIED:
    case ApprovalType.UNREVIEWED:
    case JobStatus.IN_PROGRESS:
    case MessageType.info:
    case MessageType.update:
    case ""modified"":
      return ""modified"";
    case ArtifactDeltaState.REMOVED:
    case ApprovalType.DECLINED:
    case JobStatus.FAILED:
    case MessageType.error:
    case ""removed"":
      return ""removed"";
    case MessageType.warning:
      return ""warning"";
    default:
      return ""unchanged"";
  }
}
"
src/util/commit-builder.ts,"import {
  ArtifactSchema,
  CommitSchema,
  VersionSchema,
  TraceLinkSchema,
} from ""@/types"";
import { createCommit } from ""@/util"";

/**
 * Responsible for creating a commit of changes.
 */
export class CommitBuilder {
  /**
   * The commit being built
   */
  commit: CommitSchema;

  /**
   * Creates a commit builder.
   * @param version - The project version to commit to.
   */
  constructor(version: VersionSchema) {
    this.commit = createCommit(version);
  }

  /**
   * Hides errors from the commit.
   */
  hideErrors(): this {
    this.commit.failOnError = false;
    return this;
  }

  /**
   * Adds a new artifact to this commit.
   *
   * @param artifact - The artifact to create.
   */
  withNewArtifact(artifact: ArtifactSchema): this {
    this.commit.artifacts.added.push(artifact);
    return this;
  }

  /**
   * Adds a modified artifact to this commit.
   *
   * @param artifact - The artifact to modify.
   */
  withModifiedArtifact(artifact: ArtifactSchema): this {
    this.commit.artifacts.modified.push(artifact);
    return this;
  }

  /**
   * Adds a removed artifact to this commit.
   *
   * @param artifact - The artifact to remove.
   */
  withRemovedArtifact(artifact: ArtifactSchema): this {
    this.commit.artifacts.removed.push(artifact);
    return this;
  }

  /**
   * Adds a new trace link to this commit.
   *
   * @param traceLink - The link to add.
   */
  withNewTraceLink(traceLink: TraceLinkSchema): this {
    this.commit.traces.added.push(traceLink);
    return this;
  }

  /**
   * Adds multiple new trace links to this commit.
   *
   * @param traceLinks - The links to add.
   */
  withNewTraceLinks(traceLinks: TraceLinkSchema[]): this {
    this.commit.traces.added.push(...traceLinks);
    return this;
  }

  /**
   * Adds a modified trace link to this commit.
   *
   * @param traceLinks - The links to modify.
   */
  withModifiedTraceLink(...traceLinks: TraceLinkSchema[]): this {
    this.commit.traces.modified.push(...traceLinks);
    return this;
  }
}
"
src/util/sub-tree-operations.ts,"import { ArtifactSchema } from ""@/types"";

/**
 * Returns a list of all child artifact ids of the given parents that match the given types.
 *
 * @param parentIds - The parent artifacts to get the subtrees of.
 * @param includedChildTypes - The child artifact types to find.
 * @param getSubtree - Returns the subtree node ids of an artifact.
 * @param getArtifact - Returns a matching artifact by id.
 *
 * @return The ids of all child artifacts that match.
 */
export function getMatchingChildren(
  parentIds: string[],
  includedChildTypes: string[],
  getSubtree: (id: string) => string[],
  getArtifact: (id: string) => ArtifactSchema | undefined
): string[] {
  if (includedChildTypes.length === 0) return [];

  const childArtifactIds = new Set<string>();

  parentIds.forEach((parentId) => {
    getSubtree(parentId).forEach((childId) => {
      const artifact = getArtifact(childId);

      if (!artifact || !includedChildTypes.includes(artifact.type)) return;

      childArtifactIds.add(childId);
    });
  });

  return Array.from(childArtifactIds);
}
"
src/util/table-headers.ts,"import {
  ArtifactSchema,
  AttributeSchema,
  FlatArtifact,
  FlatTraceLink,
  GenerationModelSchema,
  IdentifierSchema,
  InstallationSchema,
  JobSchema,
  MembershipSchema,
  TableColumn,
  VersionSchema,
} from ""@/types"";
import { timestampToDisplay } from ""@/util/string-helper"";

export const actionsColumn: TableColumn<
  | FlatArtifact
  | FlatTraceLink
  | IdentifierSchema
  | VersionSchema
  | InstallationSchema
  | GenerationModelSchema
  | MembershipSchema
> = {
  name: ""actions"",
  label: ""Actions"",
  sortable: false,
  align: ""left"",
  field: () => """",
};

export const artifactColumns: TableColumn<FlatArtifact>[] = [
  {
    name: ""name"",
    label: ""Name"",
    sortable: true,
    align: ""left"",
    classes: ""data-table-cell-200"",
    field: (row) => row.name,
  },
  {
    name: ""type"",
    label: ""Type"",
    sortable: true,
    align: ""left"",
    classes: ""data-table-cell-200"",
    field: (row) => row.type,
  },
];

export const artifactDeltaColumn: TableColumn<FlatArtifact> = {
  name: ""deltaType"",
  label: ""Delta State"",
  sortable: true,
  align: ""left"",
  classes: ""data-table-cell-200"",
  field: () => """",
};

export const artifactAttributesColumns: (
  attributes: AttributeSchema[]
) => TableColumn<FlatArtifact>[] = (attributes) =>
  attributes.map(({ key, label }) => ({
    label,
    name: key,
    field: (row: FlatArtifact) => (row[key] === undefined ? """" : row[key]),
    sortable: true,
    align: ""left"",
    classes: ""data-table-cell-200"",
  }));

export const artifactMatrixColumns: (
  artifacts: ArtifactSchema[]
) => TableColumn<FlatArtifact>[] = (attributes) =>
  attributes.map(({ id, name }) => ({
    label: name,
    name: id,
    field: () => """",
    sortable: true,
    align: ""left"",
  }));

export const jobColumns: TableColumn<JobSchema>[] = [
  {
    name: ""name"",
    label: ""Name"",
    field: (job) => job.name,
    align: ""left"",
  },
  {
    name: ""currentProgress"",
    label: ""Last Updated"",
    align: ""left"",
    field: (job) => job.currentProgress,
  },
  {
    name: ""status"",
    label: ""Status"",
    align: ""left"",
    field: (job) => job.status,
  },
];

export const approvalColumns: TableColumn<FlatTraceLink>[] = [
  {
    name: ""sourceName"",
    label: ""Child Name"",
    field: (row) => row.sourceName,
    sortable: true,
    align: ""left"",
  },
  {
    name: ""sourceType"",
    label: ""Child Type"",
    field: (row) => row.sourceType,
    sortable: true,
    align: ""left"",
  },
  {
    name: ""targetName"",
    label: ""Parent Name"",
    field: (row) => row.targetName,
    sortable: true,
    align: ""left"",
  },
  {
    name: ""targetType"",
    label: ""Parent Type"",
    field: (row) => row.targetType,
    sortable: true,
    align: ""left"",
  },
  {
    name: ""approvalStatus"",
    label: ""Approval Status"",
    field: (row) => row.approvalStatus,
    sortable: true,
    align: ""left"",
  },
  {
    name: ""score"",
    label: ""Confidence Score"",
    field: (row) => row.score,
    sortable: true,
    align: ""left"",
  },
  actionsColumn,
];

export const installationsColumns: TableColumn<InstallationSchema>[] = [
  {
    label: ""Integration Type"",
    name: ""type"",
    field: (row) => row.type,
    align: ""left"",
  },
  {
    label: ""Project ID"",
    name: ""installationId"",
    align: ""left"",
    field: (row) => row.installationId,
  },
  {
    label: ""Last Synced"",
    name: ""lastUpdate"",
    align: ""left"",
    field: (row) => row.lastUpdate,
    format: (lastUpdate: string) => timestampToDisplay(lastUpdate),
  },
  actionsColumn,
];

export const modelColumns: TableColumn<GenerationModelSchema>[] = [
  {
    name: ""name"",
    label: ""Name"",
    align: ""left"",
    field: (row) => row.name,
  },
  {
    name: ""baseModel"",
    label: ""Base Model"",
    align: ""left"",
    field: (row) => row.baseModel,
  },
  actionsColumn,
];

export const projectNameColumn: TableColumn<IdentifierSchema> = {
  name: ""name"",
  label: ""Name"",
  sortable: true,
  align: ""left"",
  classes: ""data-table-cell-200"",
  field: (row) => row.name,
};

export const projectExpandedColumns: TableColumn<IdentifierSchema>[] = [
  {
    name: ""description"",
    label: ""Description"",
    sortable: false,
    align: ""left"",
    classes: ""data-table-cell-200"",
    field: (row) => row.description,
  },
  {
    name: ""owner"",
    label: ""Owner"",
    sortable: false,
    align: ""left"",
    classes: ""data-table-cell-200"",
    field: (row) => row.owner,
  },
  actionsColumn,
];

export const versionColumns: TableColumn<VersionSchema>[] = [
  {
    name: ""majorVersion"",
    label: ""Major"",
    sortable: true,
    align: ""left"",
    field: (row) => row.majorVersion,
  },
  {
    name: ""minorVersion"",
    label: ""Minor"",
    sortable: true,
    align: ""left"",
    field: (row) => row.minorVersion,
  },
  {
    name: ""revision"",
    label: ""Revision"",
    sortable: true,
    align: ""left"",
    field: (row) => row.revision,
  },
];

export const membersColumns: TableColumn<MembershipSchema>[] = [
  {
    label: ""Email"",
    name: ""email"",
    align: ""left"",
    field: (row) => row.email,
  },
  {
    label: ""Role"",
    name: ""role"",
    align: ""left"",
    field: (row) => row.role,
  },
  actionsColumn,
];
"
src/util/string-helper.ts,"import { VersionSchema } from ""@/types"";

/**
 * Returns given string with newlines inserted after maxWordCount
 * has been reached.
 *
 * @param str - The original string.
 * @param maxWordCount - The maximum number of words to have per line.
 *
 * @returns The updated input string.
 */
export function splitIntoLines(str: string, maxWordCount: number): string {
  const words = str.split("" "");
  let finalString = """";
  let count = 0;

  words.forEach((w) => {
    if (count < maxWordCount) {
      finalString += w + "" "";
      count++;
    } else {
      finalString += w + ""
"";
      count = 0;
    }
  });

  return finalString;
}

/**
 * Capitalizes the first letter of the given string.
 *
 * @param str - The string to capitalize.
 *
 * @return The capitalized string.
 */
export function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}

/**
 * Converts `camelCase` to `Sentence Case`.
 *
 * @param str - The string to convert.ize.
 *
 * @return The capitalized string.
 */
export function camelcaseToDisplay(str: string): string {
  return capitalize(str.replace(/([A-Z])/g, "" $1""));
}

/**
 * Converts `UPPER_CASE` to `Sentence Case`.
 *
 * @param str - The string to convert.
 *
 * @return The capitalized string.
 */
export function uppercaseToDisplay(str: string): string {
  return str
    .split(""_"")
    .map((word) => capitalize(word))
    .join("" "");
}

/**
 * Capitalizes the first letter of all words in the given string.
 *
 * @param str - The string to capitalize.
 *
 * @return The capitalized string.
 */
export function capitalizeSentence(str: string): string {
  return str
    .split("" "")
    .map((word) => capitalize(word))
    .join("" "");
}

/**
 * Converts an enum value in capital snake case into a title case string.
 *
 * @param value - The value to convert.
 * @return The displayable value.
 */
export function enumToDisplay(value: string): string {
  return value
    .split(""_"")
    .map((word) => capitalize(word.toLowerCase()))
    .join("" "");
}
/**
 * Converts a timestamp to a display value.
 *
 * @param timestamp - The timestamp to convert.
 * @return The displayable value.
 */
export function timestampToDisplay(timestamp: string): string {
  const date = new Date(timestamp);

  return date.toLocaleDateString(""en-US"", {
    year: ""numeric"",
    month: ""short"",
    day: ""numeric"",
    weekday: ""short"",
    hour: ""numeric"",
    minute: ""numeric"",
  });
}

/**
 * Stringifies the version number.
 *
 * @param currentVersion - The current version number.
 *
 * @return The stringified version number.
 */
export function versionToString(currentVersion?: VersionSchema): string {
  if (currentVersion === undefined) {
    return ""X.X.X"";
  }
  return `${currentVersion.majorVersion}.${currentVersion.minorVersion}.${currentVersion.revision}`;
}

/**
 * Sanitizes the id of a node so it is valid in the DOM.
 * @param id - The artifact id.
 * @return The sanitized artifact id.
 */
export function sanitizeNodeId(id?: string): string {
  return id?.replace(/^[^a-z]+|[^\w:.-]+/gi, """") || """";
}
"
src/plugins/vue-pinia.ts,"import { createPinia } from ""pinia"";

const pinia = createPinia();

export default pinia;
"
src/plugins/quasar-user-options.ts,"import iconSet from ""quasar/icon-set/mdi-v4.js"";
import ""@quasar/extras/mdi-v4/mdi-v4.css"";
import { Notify } from ""quasar"";
import type { QuasarPluginOptions } from ""quasar"";
import { lightPalette } from ""@/util"";

const quasarOptions: Partial<QuasarPluginOptions> = {
  config: {
    brand: lightPalette,
    notify: {},
  },
  plugins: {
    Notify,
  },
  iconSet: iconSet,
};

// To be used on app.use(Quasar, { ... })
export default quasarOptions;
"
src/plugins/index.ts,"export { default as pinia } from ""./vue-pinia"";
export { default as quasarOptions } from ""./quasar-user-options"";

export { default as gridLayout } from ""vue3-drr-grid-layout"";
export { default as codeDiff } from ""v-code-diff"";
"
src/cytoscape/index.ts,"export * from ""./plugins"";
export * from ""./cy"";
export * from ""./events"";
export * from ""./graphs"";
export * from ""./hooks"";
export * from ""./layout"";
export * from ""./operations"";
export * from ""./styles"";
"
src/cytoscape/plugins/index.ts,"export * from ""./automove"";
export * from ""./edge-handles"";
"
src/cytoscape/plugins/automove/artifact-tree-auto-move-handlers.ts,"import { EventObject, NodeSingular } from ""cytoscape"";
import {
  AutoMoveEventHandlers,
  AutoMoveRule,
  CSSCursor,
  CytoEvent,
} from ""@/types"";

/**
 * Defines a set of triggers-handler pairs for use in the artifact tree graph.
 */
export const ArtifactTreeAutoMoveHandlers: AutoMoveEventHandlers = {
  moveArtifactWithoutSubtree: {
    triggers: [CytoEvent.CXT_DRAG],
    action: (node: NodeSingular, rule: AutoMoveRule, event: EventObject) => {
      document.body.style.cursor = CSSCursor.GRAB;
      const nodePosition = event.target.renderedPosition();
      event.target.renderedPosition({
        x: nodePosition.x + event.originalEvent.movementX / 2,
        y: nodePosition.y + event.originalEvent.movementY / 2,
      });
    },
  },
};
"
src/cytoscape/plugins/automove/index.ts,"export * from ""./artifact-tree-auto-move-handlers"";
"
src/cytoscape/plugins/edge-handles/can-connect.ts,"import { NodeSingular } from ""cytoscape"";
import { ArtifactCytoElementData } from ""@/types"";
import { traceStore } from ""@/hooks"";

/**
 * Return whether any two nodes can be traced.
 *
 * @param sourceNode - The source node on the graph.
 * @param targetNode - The target node on the graph.
 * @returns Whether the two nodes can be traced.
 */
export function canConnect(
  sourceNode: NodeSingular,
  targetNode: NodeSingular
): boolean {
  const sourceData: ArtifactCytoElementData | undefined = sourceNode.data();
  const targetData: ArtifactCytoElementData | undefined = targetNode.data();

  if (!sourceData || !targetData) return false;

  return traceStore.isLinkAllowed(sourceData, targetData) === true;
}
"
src/cytoscape/plugins/edge-handles/on-complete.ts,"import { CollectionReturnValue, EventObject, NodeSingular } from ""cytoscape"";

import {
  ArtifactCytoElementData,
  CytoCore,
  GraphMode,
  TimNodeCytoElementData,
} from ""@/types"";
import { traceApiStore, traceMatrixApiStore } from ""@/hooks"";
import { disableDrawMode } from ""@/cytoscape/plugins"";

/**
 * Creates the finalized trace link when an edge creation draw is completed.
 *
 * @param cy - The cytoscape instance.
 * @param event - The creation event.
 * @param sourceNode - The target node, being the one dragged from.
 * @param targetNode - The source node, being the one dragged to.
 * @param addedEdge - The temporary edge that was added.
 */
export function onArtifactTreeEdgeComplete(
  cy: CytoCore,
  event: EventObject,
  sourceNode: NodeSingular,
  targetNode: NodeSingular,
  addedEdge: CollectionReturnValue
): void {
  disableDrawMode();

  addedEdge.remove();

  if (sourceNode.data()?.graph === GraphMode.tree) {
    const sourceData: ArtifactCytoElementData = sourceNode.data();
    const targetData: ArtifactCytoElementData = targetNode.data();

    traceApiStore.handleCreate(sourceData, targetData);
  } else {
    const sourceData: TimNodeCytoElementData = sourceNode.data();
    const targetData: TimNodeCytoElementData = targetNode.data();

    traceMatrixApiStore.handleCreate(
      sourceData.artifactType,
      targetData.artifactType
    );
  }
}
"
src/cytoscape/plugins/edge-handles/index.ts,"export * from ""./options"";
export * from ""./edge-handles-core"";
export * from ""./can-connect"";
"
src/cytoscape/plugins/edge-handles/edge-handles-core.ts,"import { CollectionReturnValue, NodeSingular } from ""cytoscape"";
import { CytoCore, CytoEvent, EdgeHandleCore } from ""@/types"";
import { appStore } from ""@/hooks"";
import { onArtifactTreeEdgeComplete } from ""./on-complete"";

let edgeHandlesCore: EdgeHandleCore | undefined = undefined;

/**
 * Initializes edge handling.
 *
 * @param cyPromise - The cy instance.
 * @param instance - The edge handles instance.
 */
export function setEdgeHandlesCore(
  cyPromise: Promise<CytoCore>,
  instance: EdgeHandleCore
): Promise<void> {
  edgeHandlesCore = instance;

  return cyPromise.then((cy: CytoCore) => {
    cy.on(CytoEvent.EH_COMPLETE, (event, ...args: unknown[]) =>
      onArtifactTreeEdgeComplete(
        cy,
        event,
        args[0] as NodeSingular,
        args[1] as NodeSingular,
        args[2] as CollectionReturnValue
      )
    );
  });
}

/**
 * Enables edge drawing mode.
 */
export function enableDrawMode(): void {
  if (!edgeHandlesCore) return;

  edgeHandlesCore.enable();
  edgeHandlesCore.enableDrawMode();
  appStore.enableDrawLink();
}

/**
 * Disables edge drawing mode.
 */
export function disableDrawMode(): void {
  if (!edgeHandlesCore) return;

  edgeHandlesCore.disableDrawMode();
  edgeHandlesCore.disable();
  appStore.disableDrawLink();
}

/**
 * Toggles edge drawing mode.
 */
export function toggleDrawMode(): void {
  if (appStore.isCreateLinkEnabled) {
    disableDrawMode();
  } else {
    enableDrawMode();
  }
}
"
src/cytoscape/plugins/edge-handles/options.ts,"import { NodeSingular, EdgeDataDefinition } from ""cytoscape"";
import { EdgeHandlersOptions } from ""@/types"";
import { getTraceId } from ""@/util"";
import { canConnect } from ""@/cytoscape/plugins/edge-handles/can-connect"";

// the default values of each option are outlined below:
export const artifactTreeEdgeHandleOptions: EdgeHandlersOptions = {
  canConnect,

  /**
   * Handler that determines the data to be added to cytoscape upon the edge snap
   * to a target node.
   *
   * @param sourceNode - The source node on the graph.
   * @param targetNode - The target node on the graph.
   * @returns The created edge.
   */
  edgeParams(
    sourceNode: NodeSingular,
    targetNode: NodeSingular
  ): EdgeDataDefinition {
    const source: string = sourceNode.data().id;
    const target: string = targetNode.data().id;

    return { id: getTraceId(source, target), source, target };
  },

  // time spent hovering over a target node before it is considered selected.
  hoverDelay: 0,
  // when enabled, the edge can be drawn by just moving close to a target node (can be confusing on compound graphs).
  snap: true,
  // the target node must be less than or equal to this many pixels away from the cursor/finger.
  snapThreshold: 50,
  // the number of times per second (Hz) that snap checks done (lower is less expensive).
  snapFrequency: 15,
  // set events:no to edges during draws, prevents mouseouts on compounds.
  noEdgeEventsInDraw: true,
  // during an edge drawing gesture, disable browser gestures such as two-finger trackpad swipe and pinch-to-zoom.
  disableBrowserGestures: true,
};
"
src/cytoscape/layout/graph-layout.ts,"import {
  KlayLayoutSettings,
  LayoutHook,
  CyLayout,
  AutoMoveEventHandlers,
  CytoCore,
  CytoEventHandlers,
} from ""@/types"";
import { layoutStore } from ""@/hooks"";
import {
  ArtifactTreeAutoMoveHandlers,
  DefaultPostLayoutHooks,
  DefaultPreLayoutHooks,
  TIMPostLayoutHooks,
  TIMPreLayoutHooks,
} from ""@/cytoscape"";
import { DefaultEvents } from ""@/cytoscape/events"";
import { KlaySettings } from ""@/cytoscape/layout/klay-settings"";

/**
 * Defines a graph layout.
 */
export default class GraphLayout implements CyLayout {
  klaySettings: KlayLayoutSettings | undefined;
  preLayoutHooks: LayoutHook[];
  postLayoutHooks: LayoutHook[];
  autoMoveHandlers: AutoMoveEventHandlers;
  cytoEventHandlers: CytoEventHandlers;

  constructor(
    autoMoveHandlers: AutoMoveEventHandlers,
    cytoEventHandlers: CytoEventHandlers,
    layoutTemplate: KlayLayoutSettings | undefined,
    preLayoutHooks: LayoutHook[],
    postLayoutHooks: LayoutHook[]
  ) {
    this.klaySettings = layoutTemplate;
    this.preLayoutHooks = preLayoutHooks;
    this.postLayoutHooks = postLayoutHooks;
    this.autoMoveHandlers = autoMoveHandlers;
    this.cytoEventHandlers = cytoEventHandlers;
  }

  /**
   * Creates the layout.
   *
   * @param cy - The cy instance.
   * @param generate - Whether to generate the layout positions.
   */
  createLayout(cy: CytoCore, generate?: boolean): void {
    this.preLayoutHook(cy);

    if (this.klaySettings && generate) {
      cy.layout({
        name: ""klay"",
        klay: this.klaySettings,
      }).run();
    } else {
      cy.layout(layoutStore.layoutOptions).run();
    }

    this.postLayoutHook(cy);
  }

  /**
   * Runs pre-layout hooks.
   *
   * @param cy - The cy instance.
   */
  private preLayoutHook(cy: CytoCore): void {
    for (const preHook of this.preLayoutHooks) {
      preHook(cy, this);
    }
  }

  /**
   * Runs post-layout hooks.
   *
   * @param cy - The cy instance.
   */
  private postLayoutHook(cy: CytoCore): void {
    for (const postHook of this.postLayoutHooks) {
      postHook(cy, this);
    }
  }

  /**
   * Creates the artifact graph layout.
   */
  static createArtifactLayout(): GraphLayout {
    return new GraphLayout(
      ArtifactTreeAutoMoveHandlers,
      DefaultEvents,
      KlaySettings,
      DefaultPreLayoutHooks,
      DefaultPostLayoutHooks
    );
  }

  /**
   * Creates the TIM graph layout.
   */
  static createTimLayout(): GraphLayout {
    return new GraphLayout(
      {},
      DefaultEvents,
      KlaySettings,
      TIMPreLayoutHooks,
      TIMPostLayoutHooks
    );
  }
}
"
src/cytoscape/layout/index.ts,"export { default as GraphLayout } from ""./graph-layout"";
"
src/cytoscape/layout/klay-settings.ts,"import { KlayLayoutSettings } from ""@/types"";
import {
  LAYOUT_ALIGNMENT,
  LAYOUT_NODE_DIRECTION,
  LAYOUT_NODE_LAYERING,
  LAYOUT_NODE_PLACEMENT,
  LAYOUT_NODE_SPACING,
  LAYOUT_RANDOM_SEED,
  LAYOUT_THOROUGHNESS,
  LAYOUT_USE_HIERARCHY,
} from ""@/cytoscape/styles"";

// docs: https://github.com/cytoscape/cytoscape.js-klay
export const KlaySettings: KlayLayoutSettings = {
  spacing: LAYOUT_NODE_SPACING,
  direction: LAYOUT_NODE_DIRECTION,
  fixedAlignment: LAYOUT_ALIGNMENT,
  layoutHierarchy: LAYOUT_USE_HIERARCHY,
  nodeLayering: LAYOUT_NODE_LAYERING,
  nodePlacement: LAYOUT_NODE_PLACEMENT,
  thoroughness: LAYOUT_THOROUGHNESS,
  randomizationSeed: LAYOUT_RANDOM_SEED,
};
"
src/cytoscape/operations/general.ts,"import { CyPromise, CyLayout, LayoutPayload } from ""@/types"";
import { selectionStore } from ""@/hooks"";
import { applyAutoMoveEvents } from ""@/cytoscape/hooks"";
import { artifactTreeCyPromise, timTreeCyPromise } from ""@/cytoscape/cy"";
import {
  ANIMATION_DURATION,
  CENTER_GRAPH_PADDING,
  DEFAULT_ARTIFACT_TREE_ZOOM,
  ZOOM_INCREMENT,
} from ""@/cytoscape/styles"";

/**
 * Runs the given callback if cy is not animated.
 *
 * @param cb - The callback to run.
 * @param cyPromise - The cy instance.
 */
export function cyIfNotAnimated(
  cb: () => void,
  cyPromise: CyPromise = artifactTreeCyPromise
): void {
  cyPromise.then((cy) => {
    if (!cy.animated()) {
      cb();
    }
  });
}

/**
 * Resets the zoom level.
 *
 * @param cyPromise - The cy instance.
 */
export function cyZoomReset(
  cyPromise: CyPromise = artifactTreeCyPromise
): void {
  cyPromise.then((cy) => {
    cy.zoom(DEFAULT_ARTIFACT_TREE_ZOOM);
  });
}

/**
 * Zooms in the viewport.
 *
 * @param cyPromise - The cy instance.
 */
export function cyZoomIn(cyPromise: CyPromise = artifactTreeCyPromise): void {
  cyPromise.then((cy) => {
    cy.zoom(cy.zoom() + ZOOM_INCREMENT);
  });
}

/**
 * Zooms out the viewport.
 *
 * @param cyPromise - The cy instance.
 */
export function cyZoomOut(cyPromise: CyPromise = artifactTreeCyPromise): void {
  cyPromise.then((cy) => {
    cy.zoom(cy.zoom() - ZOOM_INCREMENT);
  });
}

/**
 * Centers the viewport on all graph nodes.
 *
 * @param animate - Whether to animate the centering.
 * @param cyPromise - The cy instance.
 */
export function cyCenterNodes(
  animate = false,
  cyPromise: CyPromise = artifactTreeCyPromise
): void {
  cyPromise.then((cy) => {
    const nodes = cy.nodes();

    if (animate) {
      if (cy.animated()) {
        cy.stop(false, false);
      }

      cy.animate({
        fit: { eles: nodes, padding: CENTER_GRAPH_PADDING },
        duration: ANIMATION_DURATION,
      });
    } else if (nodes.length > 10) {
      cy.fit(nodes, CENTER_GRAPH_PADDING);
    } else {
      cy.center(nodes);
    }
  });
}

/**
 * Creates the given layout.
 *
 * @param layoutPayload - The cy instance and layout.
 * @param generate - Whether to generate the layout positions.
 */
export function cyCreateLayout(
  layoutPayload: LayoutPayload,
  generate?: boolean
): void {
  layoutPayload.cyPromise.then((cy) => {
    layoutPayload.layout.createLayout(cy, generate);
  });
}

/**
 * Re-applies automove to all nodes.
 *
 * @param layout - The graph layout.
 * @param cyPromise - The cy instance.
 */
export function cyApplyAutomove(
  layout: CyLayout,
  cyPromise: CyPromise = artifactTreeCyPromise
): void {
  cyPromise.then((cy) => {
    applyAutoMoveEvents(cy, layout);
  });
}

/**
 * Moves the viewport such that given set of artifacts is in the middle of the viewport.
 * If no artifacts are given, the entire collection of nodes is centered.
 * Request is ignored if current animation is in progress to center the same collection of artifacts.
 *
 * @param currentCenteringCollection - The current centered artifacts.
 * @param artifactIds - The artifacts whose average point will be centered.
 * @param setCenteredArtifacts - Sets the current centered artifacts.
 * @param cyPromise - A promise returning an instance of cytoscape.
 */
export function cyCenterOnArtifacts(
  currentCenteringCollection: string[] | undefined,
  artifactIds: string[],
  setCenteredArtifacts: (ids: string[] | undefined) => void,
  cyPromise = artifactTreeCyPromise
): void {
  cyPromise.then((cy) => {
    if (cy.animated()) {
      cy.stop(false, false);
    }

    setCenteredArtifacts(artifactIds);

    const collection =
      artifactIds.length === 0
        ? cy.nodes()
        : cy.nodes().filter((n) => artifactIds.includes(n.data().id));

    cy.animate({
      zoom: DEFAULT_ARTIFACT_TREE_ZOOM,
      center: { eles: collection },
      duration: ANIMATION_DURATION,
      complete: () => setCenteredArtifacts(undefined),
    });
  });
}

/**
 * Set the visibility of nodes and edges related to given list of artifact names.
 * A node is related if it represents one of the target artifacts.
 * An edge is related if either source or target is an artifact in target
 * list.
 *
 * @param artifactIds - The artifacts to display or hide.
 * @param visible - Whether to display or hide these artifacts.
 * @param cyPromise - The cy instance.
 */
export function cySetDisplay(
  artifactIds: string[],
  visible: boolean,
  cyPromise: CyPromise = artifactTreeCyPromise
): void {
  const display = visible ? ""element"" : ""none"";

  cyPromise.then((cy) => {
    cy.nodes()
      .filter((n) => artifactIds.includes(n.data().id))
      .style({ display });

    cy.edges()
      .filter(
        (e) =>
          artifactIds.includes(e.target().data().id) &&
          artifactIds.includes(e.source().data().id)
      )
      .style({ display });
  });
}

/**
 * Shows all nodes and edges.
 *
 * @param cyPromise - The cy instance.
 */
export function cyDisplayAll(
  cyPromise: CyPromise = artifactTreeCyPromise
): void {
  cyPromise.then((cy) => {
    cy.nodes().style({ display: ""element"" });
    cy.edges().style({ display: ""element"" });
  });
}

/**
 * Centers the viewport on all graph nodes.
 *
 * @param cyPromise - The cy instance.
 */
export function cyResetTree(
  cyPromise: CyPromise = artifactTreeCyPromise
): void {
  const selectedId = selectionStore.selectedArtifact?.id;

  if (selectedId) {
    selectionStore.selectArtifact(selectedId);
  } else {
    cyCenterNodes(false, cyPromise);
  }
}

/**
 * Centers the viewport on all graph nodes.
 *
 * @param cyPromise - The cy instance.
 */
export function cyResetTim(cyPromise: CyPromise = timTreeCyPromise): void {
  cyPromise.then((cy) => {
    cy.fit(cy.nodes(), 150);
  });
}
"
src/cytoscape/operations/index.ts,"export * from ""./general"";
"
src/cytoscape/styles/index.ts,"export * from ""./config"";
export * from ""./stylesheets"";
"
src/cytoscape/styles/config/graph-config.ts,"import {
  FixedAlignment,
  LayoutDirection,
  NodeLayering,
  NodePlacement,
} from ""@/types"";

/**
 * General configuration.
 */
export const USE_MOTION_BLUR = false;
export const ANIMATION_DURATION = 200; // ms

/**
 * Viewport configuration.
 */
export const DEFAULT_ARTIFACT_TREE_ZOOM = 0.75;
export const ZOOM_INCREMENT = 0.05;

export const CENTER_GRAPH_PADDING = 40;

/**
 * TIM Layout configuration.
 */
export const LAYOUT_NODE_DIRECTION = LayoutDirection.DOWN;
export const LAYOUT_ALIGNMENT = FixedAlignment.BALANCED;
export const LAYOUT_USE_HIERARCHY = true;
export const LAYOUT_NODE_LAYERING = NodeLayering.NETWORK_SIMPLEX;
export const LAYOUT_NODE_PLACEMENT = NodePlacement.BRANDES_KOEPF;
export const LAYOUT_THOROUGHNESS = 10;
export const LAYOUT_RANDOM_SEED = 42;
export const LAYOUT_NODE_SPACING = 50;
"
src/cytoscape/styles/config/edge-config.ts,"import { GraphMode } from ""@/types"";
import { ThemeColors } from ""@/util"";

/**
 * General edge configuration.
 */
export const EDGE_WIDTH = 3;
export const EDGE_ARROW_SCALE = 2;

export const EDGE_COLOR = {
  DEFAULT: ThemeColors.nodeDefault,
  GENERATED: ThemeColors.nodeGenerated,
  GHOST: ThemeColors.primary,
  ADDED: ThemeColors.added,
  MODIFIED: ThemeColors.modified,
  REMOVED: ThemeColors.removed,
  NO_CHANGE: ThemeColors.unchanged,
};

export const EDGE_SHAPE = {
  SOURCE: ""none"",
  TARGET: ""chevron"",
};

/**
 * Artifact edge configuration.
 */
export const TRACE_CURVE_STYLE = ""bezier"";
export const TRACE_FADED_OPACITY = 0.3;

export const GENERATED_TRACE_MAX_WIDTH = 4;

export const TRACE_LINE_STYLE = {
  DEFAULT: ""solid"",
  UNREVIEWED: ""dashed"",
  CREATION: ""dotted"",
};

/**
 * TIM edge configuration.
 */
export const TIM_EDGE_SELECTOR = `edge[graph='${GraphMode.tim}']`;

export const TIM_EDGE_STYLE = ""taxi"";
export const TIM_EDGE_ARROW_SHAPE = ""chevron"";
export const TIM_EDGE_X_MARGIN = 10;
export const TIM_EDGE_FONT_WEIGHT = 400;
export const TIM_EDGE_FONT_SIZE = 20;
export const TIM_EDGE_FONT_BG_OPACITY = 0.8;
export const TIM_EDGE_LOOP_STEP_SIZE = 140;
"
src/cytoscape/styles/config/index.ts,"export * from ""./graph-config"";
export * from ""./node-config"";
export * from ""./edge-config"";
"
src/cytoscape/styles/config/node-config.ts,"import { ApprovalType, GraphMode, NodePlacement, TraceType } from ""@/types"";
import { ThemeColors } from ""@/util"";

/**
 * General node configuration.
 */
export const NODE_BORDER_WIDTH = 0;

export const NODE_BORDER_COLOR = ThemeColors.nodeDefault;
export const NODE_BG_COLOR = {
  LIGHT: ThemeColors.whiteBg,
  DARK: ThemeColors.blackBg,
};

/**
 * Artifact node configuration.
 */
export const ARTIFACT_NODE_SELECTOR = `node[graph='${GraphMode.tree}']`;
export const ARTIFACT_EDGE_SELECTOR = `edge[graph='${GraphMode.tree}']`;
export const GENERATED_LINK_SELECTOR = `${ARTIFACT_EDGE_SELECTOR}[traceType='${TraceType.GENERATED}']`;
export const GENERATED_APPROVED_LINK_SELECTOR = `${GENERATED_LINK_SELECTOR}[approvalStatus='${ApprovalType.APPROVED}']`;

export const ARTIFACT_WIDTH = 105;
export const ARTIFACT_HEIGHT = (ARTIFACT_WIDTH * 9) / 16;
export const ARTIFACT_PADDING = 50;
export const ARTIFACT_BORDER_STYLE = ""solid"";
export const ARTIFACT_FTA_BORDER_WIDTH = 2;

export const ARTIFACT_SHAPE = {
  DEFAULT: NodePlacement.ROUND_RECTANGLE,
  FTA: NodePlacement.POLYGON,
  SC_GOAL: NodePlacement.RECTANGLE,
  SC_CONTEXT: NodePlacement.ROUND_RECTANGLE,
  SC_SOLUTION: NodePlacement.ELLIPSE,
  SC_STRATEGY: NodePlacement.POLYGON,
};

export const ARTIFACT_POLYGONS = {
  FTA_AND:
    ""-0.4 -0.2, -0.35 -0.3, -0.3 -0.375, -0.25 -0.42, -0.2 -0.45, -0.15 -0.475, -0.1 -0.49, -0.05 -0.495, 0 -0.5, "" +
    ""0.05 -0.495, 0.1 -0.49, 0.15 -0.475, 0.2 -0.45, 0.25 -0.42, 0.3 -0.375, 0.35 -0.3, 0.4 -0.2, "" +
    ""0.4 0.5, -0.4 0.5"",
  FTA_OR:
    ""-0.4 0, -0.35 -0.115, -0.3 -0.215, -0.25 -0.28, -0.2 -0.34, -0.15 -0.395, -0.1 -0.435, -0.05 -0.47, 0 -0.5, "" +
    ""0.05 -0.47, 0.1 -0.435, 0.15 -0.395, 0.2 -0.34, 0.25 -0.28, 0.3 -0.215, 0.35 -0.115, 0.4 0, "" +
    ""0.4 0.5, 0.35 0.475, 0.3 0.455, 0.25 0.44, 0.2 0.425, 0.15 0.415, 0.1 0.41, 0.05 0.405, 0 0.4, "" +
    ""-0.05 0.405, -0.1 0.41, -0.15 0.415, -0.2 0.425, -0.25 0.44, -0.3 0.455, -0.35 0.475, -0.4 0.5"",
  SC_STRATEGY: ""-0.8 -0.8, 1 -0.8, 0.8 0.8, -1 0.8"",
};

/**
 * TIM node configuration.
 */
export const TIM_NODE_SELECTOR = `node[graph='${GraphMode.tim}']`;

export const TIM_NODE_SHAPE = ""round-rectangle"";
export const TIM_NODE_HEIGHT = 150;
export const TIM_NODE_WIDTH = 250;
export const TIM_NODE_COLOR = ""transparent"";
export const TIM_NODE_BORDER_WIDTH = 0;
"
src/cytoscape/styles/stylesheets/edge-styles.ts,"import { ApprovalType, ArtifactDeltaState, CytoStyleSheet } from ""@/types"";
import {
  EDGE_COLOR,
  EDGE_WIDTH,
  TIM_EDGE_SELECTOR,
  TRACE_CURVE_STYLE,
  ARTIFACT_EDGE_SELECTOR,
  GENERATED_APPROVED_LINK_SELECTOR,
  GENERATED_LINK_SELECTOR,
  EDGE_SHAPE,
  TIM_EDGE_STYLE,
  TIM_EDGE_ARROW_SHAPE,
  TIM_EDGE_X_MARGIN,
  EDGE_ARROW_SCALE,
  TRACE_FADED_OPACITY,
  TRACE_LINE_STYLE,
  TIM_EDGE_FONT_WEIGHT,
  TIM_EDGE_FONT_SIZE,
  TIM_EDGE_LOOP_STEP_SIZE,
  NODE_BG_COLOR,
  TIM_EDGE_FONT_BG_OPACITY,
} from ""@/cytoscape/styles/config"";

export const edgeStyles: CytoStyleSheet[] = [
  // Trace Links
  {
    selector: ARTIFACT_EDGE_SELECTOR,
    style: {
      width: EDGE_WIDTH,
      ""curve-style"": TRACE_CURVE_STYLE,
      ""line-color"": EDGE_COLOR.DEFAULT,
      ""source-arrow-shape"": EDGE_SHAPE.TARGET,
      ""target-arrow-shape"": EDGE_SHAPE.SOURCE,
      ""source-arrow-color"": EDGE_COLOR.DEFAULT,
      ""arrow-scale"": EDGE_ARROW_SCALE,
    },
  },
  {
    selector: `${ARTIFACT_EDGE_SELECTOR}[?faded]`,
    style: { opacity: TRACE_FADED_OPACITY },
  },
  // Generated Trace Links
  {
    selector: GENERATED_LINK_SELECTOR,
    style: {
      ""line-color"": EDGE_COLOR.GENERATED,
      ""source-arrow-color"": EDGE_COLOR.GENERATED,
    },
  },
  {
    selector: `${ARTIFACT_EDGE_SELECTOR}[approvalStatus='${ApprovalType.UNREVIEWED}']`,
    style: {
      ""line-style"": TRACE_LINE_STYLE.UNREVIEWED,
      ""line-dash-pattern"": [6, 3],
    },
  },
  {
    selector: GENERATED_APPROVED_LINK_SELECTOR,
    style: {
      ""line-style"": TRACE_LINE_STYLE.DEFAULT,
    },
  },
  // Trace Link Delta
  {
    selector: `${ARTIFACT_EDGE_SELECTOR}[deltaType='${ArtifactDeltaState.NO_CHANGE}']`,
    style: {
      ""target-arrow-color"": EDGE_COLOR.NO_CHANGE,
      ""source-arrow-color"": EDGE_COLOR.NO_CHANGE,
      ""line-color"": EDGE_COLOR.NO_CHANGE,
    },
  },
  {
    selector: `${ARTIFACT_EDGE_SELECTOR}[deltaType='${ArtifactDeltaState.ADDED}']`,
    style: {
      ""target-arrow-color"": EDGE_COLOR.ADDED,
      ""source-arrow-color"": EDGE_COLOR.ADDED,
      ""line-color"": EDGE_COLOR.ADDED,
    },
  },
  {
    selector: `${ARTIFACT_EDGE_SELECTOR}[deltaType='${ArtifactDeltaState.MODIFIED}']`,
    style: {
      ""target-arrow-color"": EDGE_COLOR.MODIFIED,
      ""source-arrow-color"": EDGE_COLOR.MODIFIED,
      ""line-color"": EDGE_COLOR.MODIFIED,
    },
  },
  {
    selector: `${GENERATED_APPROVED_LINK_SELECTOR}[deltaType='${ArtifactDeltaState.MODIFIED}']`,
    style: {
      ""target-arrow-color"": EDGE_COLOR.ADDED,
      ""source-arrow-color"": EDGE_COLOR.ADDED,
      ""line-color"": EDGE_COLOR.ADDED,
    },
  },
  {
    selector: `${ARTIFACT_EDGE_SELECTOR}[deltaType='${ArtifactDeltaState.REMOVED}']`,
    style: {
      ""target-arrow-color"": EDGE_COLOR.REMOVED,
      ""source-arrow-color"": EDGE_COLOR.REMOVED,
      ""line-color"": EDGE_COLOR.REMOVED,
    },
  },
  // Edge Creation Handles
  {
    selector: "".eh-hover"",
    style: {},
  },
  {
    selector: "".eh-source"",
    style: {
      ""border-width"": EDGE_WIDTH,
      ""border-color"": EDGE_COLOR.GENERATED,
    },
  },
  {
    selector: "".eh-target"",
    style: {
      ""border-width"": EDGE_WIDTH,
      ""border-color"": EDGE_COLOR.GENERATED,
    },
  },
  {
    selector: "".eh-ghost-edge"",
    style: {
      ""line-fill"": ""linear-gradient"",
      ""line-gradient-stop-colors"": ""cyan magenta yellow"",
      ""line-style"": TRACE_LINE_STYLE.CREATION,
      ""line-dash-pattern"": [6, 3],
      ""line-color"": EDGE_COLOR.GHOST,
      ""source-arrow-shape"": EDGE_SHAPE.SOURCE,
      ""target-arrow-shape"": EDGE_SHAPE.TARGET,
    },
  },
  {
    selector: "".eh-preview"",
    style: {
      ""line-color"": EDGE_COLOR.GENERATED,
      ""source-arrow-shape"": EDGE_SHAPE.SOURCE,
      ""target-arrow-shape"": EDGE_SHAPE.TARGET,
    },
  },
  {
    selector: "".eh-ghost-node"",
    style: {
      opacity: 0,
    },
  },
  {
    selector: "".eh-ghost-edge.eh-preview-active"",
    style: {
      opacity: 0,
    },
  },
  // TIM Edges
  {
    selector: TIM_EDGE_SELECTOR,
    style: {
      ""curve-style"": TIM_EDGE_STYLE,
      ""source-arrow-shape"": TIM_EDGE_ARROW_SHAPE,
      width: EDGE_WIDTH,
      ""text-margin-x"": TIM_EDGE_X_MARGIN,
      ""source-arrow-color"": EDGE_COLOR.DEFAULT,
      ""line-color"": EDGE_COLOR.DEFAULT,
      ""font-weight"": TIM_EDGE_FONT_WEIGHT,
      ""font-size"": TIM_EDGE_FONT_SIZE,
      ""text-background-opacity"": TIM_EDGE_FONT_BG_OPACITY,
      ""text-background-color"": NODE_BG_COLOR.LIGHT,
      label: ""data(label)"",
    },
  },
  {
    selector: `${TIM_EDGE_SELECTOR}[?dark]`,
    style: {
      ""text-background-color"": NODE_BG_COLOR.DARK,
      color: NODE_BG_COLOR.LIGHT,
    },
  },
  {
    selector: `${TIM_EDGE_SELECTOR}[?generated]`,
    style: {
      ""line-color"": EDGE_COLOR.GENERATED,
      ""source-arrow-color"": EDGE_COLOR.GENERATED,
    },
  },
  {
    selector: "".loop"",
    style: {
      ""control-point-step-size"": TIM_EDGE_LOOP_STEP_SIZE,
      ""loop-direction"": ""-90deg"",
      ""loop-sweep"": ""40deg"",
      ""target-endpoint"": ""outside-to-line"",
      ""source-endpoint"": ""outside-to-line"",
    },
  },
];
"
src/cytoscape/styles/stylesheets/node-styles.ts,"import { CytoStyleSheet, FTANodeType, SafetyCaseType } from ""@/types"";
import {
  TIM_NODE_SELECTOR,
  NODE_BG_COLOR,
  NODE_BORDER_COLOR,
  ARTIFACT_BORDER_STYLE,
  ARTIFACT_HEIGHT,
  ARTIFACT_NODE_SELECTOR,
  ARTIFACT_PADDING,
  ARTIFACT_SHAPE,
  ARTIFACT_WIDTH,
  NODE_BORDER_WIDTH,
  ARTIFACT_FTA_BORDER_WIDTH,
  ARTIFACT_POLYGONS,
  TIM_NODE_SHAPE,
  TIM_NODE_WIDTH,
  TIM_NODE_HEIGHT,
  TIM_NODE_BORDER_WIDTH,
  TIM_NODE_COLOR,
} from ""@/cytoscape/styles/config"";

export const nodeStyles: CytoStyleSheet[] = [
  // Artifacts
  {
    selector: ARTIFACT_NODE_SELECTOR,
    style: {
      width: ARTIFACT_WIDTH,
      height: ARTIFACT_HEIGHT,
      padding: ARTIFACT_PADDING,
      shape: ARTIFACT_SHAPE.DEFAULT,
      ""background-color"": NODE_BG_COLOR.LIGHT,
      ""border-style"": ARTIFACT_BORDER_STYLE,
      ""border-width"": NODE_BORDER_WIDTH,
      ""border-color"": NODE_BORDER_COLOR,
    },
  },
  {
    selector: `${ARTIFACT_NODE_SELECTOR}[?dark]`,
    style: {
      ""background-color"": NODE_BG_COLOR.DARK,
    },
  },
  // FTA Logic
  {
    selector: `${ARTIFACT_NODE_SELECTOR}[logicType='${FTANodeType.AND}']`,
    style: {
      ""border-width"": ARTIFACT_FTA_BORDER_WIDTH,
      shape: ARTIFACT_SHAPE.FTA,
      ""shape-polygon-points"": ARTIFACT_POLYGONS.FTA_AND,
    },
  },
  {
    selector: `${ARTIFACT_NODE_SELECTOR}[logicType='${FTANodeType.OR}']`,
    style: {
      ""border-width"": ARTIFACT_FTA_BORDER_WIDTH,
      shape: ARTIFACT_SHAPE.FTA,
      ""shape-polygon-points"": ARTIFACT_POLYGONS.FTA_OR,
    },
  },
  // Safety Cases
  {
    selector: `${ARTIFACT_NODE_SELECTOR}[safetyCaseType='${SafetyCaseType.GOAL}']`,
    style: {
      shape: ARTIFACT_SHAPE.SC_GOAL,
      width: ARTIFACT_WIDTH,
      height: ARTIFACT_HEIGHT,
    },
  },
  {
    selector: `${ARTIFACT_NODE_SELECTOR}[safetyCaseType='${SafetyCaseType.CONTEXT}']`,
    style: {
      shape: ARTIFACT_SHAPE.SC_CONTEXT,
      width: ARTIFACT_WIDTH,
      height: ARTIFACT_HEIGHT,
    },
  },
  {
    selector: `${ARTIFACT_NODE_SELECTOR}[safetyCaseType='${SafetyCaseType.SOLUTION}']`,
    style: {
      shape: ARTIFACT_SHAPE.SC_SOLUTION,
      width: ARTIFACT_HEIGHT * 1.4,
      height: ARTIFACT_HEIGHT * 1.4,
    },
  },
  {
    selector: `${ARTIFACT_NODE_SELECTOR}[safetyCaseType='${SafetyCaseType.STRATEGY}']`,
    style: {
      shape: ARTIFACT_SHAPE.SC_STRATEGY,
      width: ARTIFACT_WIDTH * 1.2,
      height: ARTIFACT_HEIGHT * 1.65,
      ""shape-polygon-points"": ARTIFACT_POLYGONS.SC_STRATEGY,
    },
  },
  // Tim Nodes
  {
    selector: TIM_NODE_SELECTOR,
    style: {
      shape: TIM_NODE_SHAPE,
      width: TIM_NODE_WIDTH,
      height: TIM_NODE_HEIGHT,
      ""background-color"": NODE_BG_COLOR.LIGHT,
      ""border-width"": TIM_NODE_BORDER_WIDTH,
      ""border-color"": TIM_NODE_COLOR,
    },
  },
  {
    selector: `${TIM_NODE_SELECTOR}[?dark]`,
    style: {
      ""background-color"": NODE_BG_COLOR.DARK,
    },
  },
  // Misc
  {
    selector: "".hidden"",
    css: {
      display: ""none"",
    },
  },
];
"
src/cytoscape/styles/stylesheets/index.ts,"export * from ""./node-styles"";
export * from ""./edge-styles"";
"
src/cytoscape/hooks/post-layout.ts,"import { EventObject, NodeSingular } from ""cytoscape"";
import { LayoutHook, AutoMoveReposition, CytoCore, CyLayout } from ""@/types"";
import { selectionStore } from ""@/hooks"";
import { timTreeCyPromise } from ""@/cytoscape/cy"";
import { cyCenterNodes, cyZoomReset } from ""@/cytoscape/operations"";

/**
 * Adds auto-move handlers to a node, so that its child nodes are dragged along with it.
 *
 * @param cy - The cy instance.
 * @param layout - The layout instance.
 * @param node - The node to add handlers for.
 */
export function addAutoMoveToNode(
  cy: CytoCore,
  layout: CyLayout,
  node: NodeSingular
): void {
  const children = node
    .connectedEdges(`edge[source='${node.data().id}']`)
    .targets();

  const rule = cy.automove({
    nodesMatching: children.union(children.successors()),
    reposition: AutoMoveReposition.DRAG,
    dragWith: node,
  });

  for (const eventDefinition of Object.values(layout.autoMoveHandlers)) {
    node.on(eventDefinition.triggers.join("" ""), (event: EventObject) => {
      eventDefinition.action(node, rule, event);
    });
  }
}

/**
 * Adds auto-move handlers to all nodes, so that their children nodes are dragged along with then.
 *
 * @param cy - The cy instance.
 * @param layout - The layout instance.
 */
export const applyAutoMoveEvents: LayoutHook = (
  cy: CytoCore,
  layout: CyLayout
): void => {
  cy.automove(""destroy"");
  cy.nodes().forEach((node) => addAutoMoveToNode(cy, layout, node));
};

/**
 * Applies cytoscape event handlers in the layout.
 *
 * @param cy - The cy instance.
 * @param layout - The layout instance.
 */
export const applyCytoEvents: LayoutHook = (
  cy: CytoCore,
  layout: CyLayout
): void => {
  for (const cytoEvent of Object.values(layout.cytoEventHandlers)) {
    const eventName: string = cytoEvent.events.join("" "");
    const selector = cytoEvent.selector;
    const handler = (event: EventObject) => cytoEvent.action(cy, event);

    if (selector === undefined) {
      cy.off(eventName);
      cy.on(eventName, handler);
    } else {
      cy.off(eventName, selector);
      cy.on(eventName, selector, handler);
    }
  }
};

/**
 * Centers on the selected or root node of the graph.
 */
export const centerViewOnNode: LayoutHook = (): void => {
  const selectedArtifacts = selectionStore.selectedArtifact?.id;

  if (!selectedArtifacts) {
    cyZoomReset();
    cyCenterNodes();
  } else {
    selectionStore.centerOnArtifacts([selectedArtifacts]);
  }
};

/**
 * Post layout hooks for the artifact tree.
 */
export const DefaultPostLayoutHooks: LayoutHook[] = [
  centerViewOnNode,
  applyAutoMoveEvents,
  applyCytoEvents,
];

/**
 * Post layout hooks for the TIM tree.
 */
export const TIMPostLayoutHooks: LayoutHook[] = [
  (): void => cyCenterNodes(false, timTreeCyPromise),
  applyCytoEvents,
];
"
src/cytoscape/hooks/index.ts,"export * from ""./post-layout"";
export * from ""./pre-layout"";
"
src/cytoscape/hooks/pre-layout.ts,"import { EdgeSingular } from ""cytoscape"";
import { CytoCore, LayoutHook } from ""@/types"";
import {
  GENERATED_LINK_SELECTOR,
  GENERATED_TRACE_MAX_WIDTH,
} from ""@/cytoscape/styles"";

/**
 * Applies style changes to graph links.
 *
 * @param cy - The cy instance.
 */
export const styleGeneratedLinks: LayoutHook = (cy: CytoCore): void => {
  cy.edges(GENERATED_LINK_SELECTOR).forEach((edge: EdgeSingular) => {
    const score = edge.data().score;

    edge.style({
      width: Math.min(
        score * GENERATED_TRACE_MAX_WIDTH,
        GENERATED_TRACE_MAX_WIDTH
      ),
    });
  });
};

/**
 * Pre-layout hooks for the artifact tree.
 */
export const DefaultPreLayoutHooks: LayoutHook[] = [styleGeneratedLinks];

/**
 * Pre-layout hooks for the TIM tree.
 */
export const TIMPreLayoutHooks: LayoutHook[] = [];
"
src/cytoscape/graphs/tim-graph.ts,"import klay from ""cytoscape-klay"";

import { CytoCoreGraph } from ""@/types"";
import { layoutStore } from ""@/hooks"";
import { timTreeResolveCy } from ""@/cytoscape/cy"";
import {
  DEFAULT_ARTIFACT_TREE_ZOOM,
  USE_MOTION_BLUR,
  nodeStyles,
  edgeStyles,
} from ""@/cytoscape/styles"";

/**
 * Defines the initialization of the tim graph.
 */
export const timGraph: CytoCoreGraph = {
  name: ""tim-tree-graph"",
  config: {
    style: [...nodeStyles, ...edgeStyles],
    motionBlur: USE_MOTION_BLUR,
    zoom: DEFAULT_ARTIFACT_TREE_ZOOM,
  },
  saveCy: timTreeResolveCy,
  plugins: [
    {
      initialize: klay,
      afterInit: () => undefined,
    },
  ],
  afterInit() {
    // Wait for initialized nodes to be added.
    setTimeout(() => {
      layoutStore.setTimTreeLayout();
    }, 100);
  },
};
"
src/cytoscape/graphs/artifact-graph.ts,"import klay from ""cytoscape-klay"";
import automove from ""cytoscape-automove"";
import edgehandles from ""cytoscape-edgehandles"";

import { CytoCore, CytoCoreGraph } from ""@/types"";
import { artifactTreeCyPromise, artifactTreeResolveCy } from ""@/cytoscape/cy"";
import {
  artifactTreeEdgeHandleOptions,
  setEdgeHandlesCore,
} from ""@/cytoscape/plugins"";
import {
  DEFAULT_ARTIFACT_TREE_ZOOM,
  edgeStyles,
  nodeStyles,
  USE_MOTION_BLUR,
  ZOOM_INCREMENT,
} from ""@/cytoscape/styles"";

/**
 * Defines the initialization of the artifact tree graph.
 */
export const artifactTreeGraph: CytoCoreGraph = {
  name: ""artifact-tree-graph"",
  config: {
    style: [...nodeStyles, ...edgeStyles],
    motionBlur: USE_MOTION_BLUR,
    zoom: DEFAULT_ARTIFACT_TREE_ZOOM,
    boxSelectionEnabled: true,
    wheelSensitivity: ZOOM_INCREMENT,
  },
  saveCy: artifactTreeResolveCy,
  plugins: [
    {
      initialize: klay,
      afterInit: () => undefined,
    },
    {
      initialize: automove,
      afterInit: () => undefined,
    },
    {
      initialize: edgehandles,
      afterInit(cy: CytoCore): Promise<void> {
        return setEdgeHandlesCore(
          artifactTreeCyPromise,
          cy.edgehandles(artifactTreeEdgeHandleOptions)
        );
      },
    },
  ],
  afterInit: () => undefined,
};
"
src/cytoscape/graphs/index.ts,"export * from ""./artifact-graph"";
export * from ""./tim-graph"";
"
src/cytoscape/cy/tim-tree-cy.ts,"import { CyPromise, ResolveCy } from ""@/types"";

export let timTreeResolveCy: ResolveCy = null;

/**
 * Returns a promise for the tim tree cy instance.
 * This promise will only resolve when there is a cytoscape graph.
 */
export const timTreeCyPromise: CyPromise = new Promise(
  (resolve) => (timTreeResolveCy = resolve)
);
"
src/cytoscape/cy/artifact-tree-cy.ts,"import { CyPromise, ResolveCy } from ""@/types"";

export let artifactTreeResolveCy: ResolveCy = null;

/**
 * Returns a promise for the artifact tree cy instance.
 * This promise will only resolve when there is a cytoscape graph.
 */
export const artifactTreeCyPromise: CyPromise = new Promise(
  (resolve) => (artifactTreeResolveCy = resolve)
);
"
src/cytoscape/cy/index.ts,"export * from ""./artifact-tree-cy"";
export * from ""./tim-tree-cy"";
"
src/cytoscape/events/index.ts,"/**
 * Events to apply to a created cytoscape instance.
 */
export const DefaultEvents = {};

export default { DefaultEvents };
"
src/components/index.ts,"export * from ""./common"";
export * from ""./account"";
export * from ""./project"";
export * from ""./settings"";
export * from ""./artifactType"";
export * from ""./traceMatrix"";
export * from ""./artifact"";
export * from ""./traceLink"";
export * from ""./graph"";
export * from ""./navigation"";
export * from ""./jobs"";
export * from ""./models"";
export * from ""./delta"";
export * from ""./attributes"";
export * from ""./search"";
"
src/components/delta/index.ts,"export { default as DeltaPanel } from ""./DeltaPanel.vue"";
"
src/components/settings/index.ts,"export { default as SettingsTabs } from ""./SettingsTabs.vue"";
export * from ""./members"";
"
src/components/settings/members/index.ts,"export { default as ProjectMemberTable } from ""./ProjectMemberTable.vue"";
export { default as ProjectMemberModal } from ""./ProjectMemberModal.vue"";
"
src/components/traceMatrix/index.ts,"export * from ""./panel"";
"
src/components/traceMatrix/panel/index.ts,"export { default as TraceMatrixPanel } from ""./TraceMatrixPanel.vue"";
"
src/components/traceMatrix/display/index.ts,"export { default as TraceMatrixContent } from ""./TraceMatrixContent.vue"";
export { default as TraceMatrixTraces } from ""./TraceMatrixTraces.vue"";
export { default as TraceMatrixArtifacts } from ""./TraceMatrixArtifacts.vue"";
"
src/components/traceLink/index.ts,"export * from ""./display"";
export * from ""./save"";
export * from ""./panels"";
export * from ""./table"";
"
src/components/traceLink/panels/index.ts,"export { default as TraceLinkPanel } from ""./TraceLinkPanel.vue"";
export { default as SaveTraceLinkPanel } from ""./SaveTraceLinkPanel.vue"";
export { default as GenerateTraceLinkPanel } from ""./GenerateTraceLinkPanel.vue"";
"
src/components/traceLink/table/index.ts,"export { default as TraceTable } from ""./TraceTable.vue"";
export { default as ApprovalTable } from ""./ApprovalTable.vue"";
"
src/components/traceLink/display/index.ts,"export { default as TraceLinkDisplay } from ""./TraceLinkDisplay.vue"";
export { default as TraceLinkApproval } from ""./TraceLinkApproval.vue"";
export { default as TraceLinkContent } from ""./TraceLinkContent.vue"";
export { default as TraceLinkButtons } from ""./TraceLinkButtons.vue"";
"
src/components/traceLink/save/index.ts,"export { default as TraceMatrixCreator } from ""../save/TraceMatrixCreator.vue"";
export { default as TraceLinkGenerator } from ""../save/TraceLinkGenerator.vue"";
"
src/components/artifactType/index.ts,"export * from ""./panel"";
"
src/components/artifactType/panel/index.ts,"export { default as ArtifactLevelPanel } from ""./ArtifactLevelPanel.vue"";
export { default as SaveArtifactLevelPanel } from ""./SaveArtifactLevelPanel.vue"";
"
src/components/artifactType/display/index.ts,"export { default as ArtifactLevelButtons } from ""./ArtifactLevelButtons.vue"";
export { default as ArtifactLevelContent } from ""./ArtifactLevelContent.vue"";
export { default as ArtifactLevelTraces } from ""./ArtifactLevelTraces.vue"";
export { default as ArtifactLevelArtifacts } from ""./ArtifactLevelArtifacts.vue"";
"
src/components/graph/index.ts,"export { default as TimTree } from ""./TimTree.vue"";
export { default as ProjectTree } from ""./ProjectTree.vue"";
export { default as GraphFab } from ""./GraphFab.vue"";
"
src/components/graph/tim/index.ts,"export { default as TimNode } from ""./TimNode.vue"";
export { default as TimLink } from ""./TimLink.vue"";
export { default as TimMenu } from ""./TimMenu.vue"";
"
src/components/graph/artifact/index.ts,"export { default as ArtifactNode } from ""./ArtifactNode.vue"";
export { default as TraceLink } from ""./TraceLink.vue"";
export { default as ArtifactMenu } from ""./ArtifactMenu.vue"";
"
src/components/graph/display/index.ts,"export { default as NodeDisplay } from ""./NodeDisplay.vue"";
"
src/components/graph/base/index.ts,"export { default as Cytoscape } from ""./Cytoscape.vue"";
export { default as CyElement } from ""./CyElement.vue"";
export { default as CyContextMenu } from ""./CyContextMenu.vue"";
"
src/components/navigation/index.ts,"export { default as AppNav } from ""./AppNav.vue"";
export { default as PrivatePage } from ""./PrivatePage.vue"";
export * from ""./detailsDrawer"";
"
src/components/navigation/sidebar/index.ts,"export { default as AppNavDrawer } from ""./AppNavDrawer.vue"";
"
src/components/navigation/detailsDrawer/index.ts,"export { default as DetailsDrawer } from ""./DetailsDrawer.vue"";
"
src/components/navigation/topbar/index.ts,"export { default as AppNavBar } from ""./AppNavBar.vue"";
"
src/components/navigation/topbar/graph/index.ts,"export { default as GraphBar } from ""./GraphBar.vue"";
"
src/components/navigation/topbar/header/index.ts,"export { default as HeaderBar } from ""./HeaderBar.vue"";
export { default as LoadingBar } from ""./LoadingBar.vue"";
"
src/components/models/index.ts,"export { default as TracePredictionTabs } from ""./TracePredictionTabs.vue"";
"
src/components/models/training/index.ts,"export { default as ModelTable } from ""./ModelTable.vue"";
"
src/components/models/training/editor/index.ts,"export { default as ModelTraining } from ""./ModelTraining.vue"";
"
src/components/models/training/editor/steps/index.ts,"export { default as ModelDocumentStep } from ""./ModelDocumentStep.vue"";
export { default as ModelRepositoryStep } from ""./ModelRepositoryStep.vue"";
export { default as ModelKeywordsStep } from ""./ModelKeywordsStep.vue"";
export { default as ModelProjectStep } from ""./ModelProjectStep.vue"";
"
src/components/document/index.ts,"export { default as DocumentSelector } from ""./DocumentSelector.vue"";
export { default as DocumentPanel } from ""./DocumentPanel.vue"";
"
src/components/search/index.ts,"export { default as ProjectSearchbar } from ""./ProjectSearchbar.vue"";
"
src/components/project/index.ts,"export * from ""./base"";
export * from ""./creator"";
export * from ""./editor"";
export * from ""./selector"";
"
src/components/project/creator/index.ts,"export { default as ProjectCreator } from ""./ProjectCreator.vue"";
export { default as UploadNewVersion } from ""./UploadNewVersion.vue"";
export { default as CreateVersionModal } from ""./CreateVersionModal.vue"";
"
src/components/project/creator/workflows/index.ts,"export { default as ProjectCreatorStepper } from ""./ProjectCreatorStepper.vue"";
export { default as ProjectBulkUpload } from ""./ProjectBulkUpload.vue"";
"
src/components/project/creator/steps/index.ts,"export { default as FilePanelList } from ""./FilePanelList.vue"";
"
src/components/project/selector/index.ts,"export { default as ProjectLoader } from ""./ProjectLoader.vue"";
export { default as ProjectVersionStepper } from ""./ProjectVersionStepper.vue"";
export * from ""./input"";
"
src/components/project/selector/input/index.ts,"export { default as ProjectSelector } from ""./ProjectSelector.vue"";
export { default as VersionSelector } from ""./VersionSelector.vue"";
"
src/components/project/selector/table/index.ts,"export { default as ProjectSelectorTable } from ""./ProjectSelectorTable.vue"";
export { default as VersionSelectorTable } from ""./VersionSelectorTable.vue"";
"
src/components/project/base/index.ts,"export { default as ProjectIdentifierInput } from ""./ProjectIdentifierInput.vue"";
export { default as ProjectFilesInput } from ""./ProjectFilesInput.vue"";
export { default as ProjectFilesUploader } from ""./ProjectFilesUploader.vue"";
export { default as ProjectDisplay } from ""./ProjectDisplay.vue"";
export { default as ProjectButtons } from ""./ProjectButtons.vue"";
"
src/components/project/editor/index.ts,"export { default as SaveProjectModal } from ""./SaveProjectModal.vue"";
export { default as DeleteProjectModal } from ""./DeleteProjectModal.vue"";
"
src/components/integrations/index.ts,"export * from ""./authentication"";
export * from ""./projects"";
export { default as IntegrationsStepper } from ""./IntegrationsStepper.vue"";
export { default as ProjectInstallationsTable } from ""./ProjectInstallationsTable.vue"";
"
src/components/integrations/organizations/index.ts,"export { default as JiraOrganizationSelector } from ""./JiraOrganizationSelector.vue"";
export { default as GitHubOrganizationSelector } from ""./GitHubOrganizationSelector.vue"";
"
src/components/integrations/projects/index.ts,"export { default as JiraProjectSelector } from ""./JiraProjectSelector.vue"";
export { default as GitHubProjectSelector } from ""./GitHubProjectSelector.vue"";
"
src/components/integrations/authentication/index.ts,"export { default as AuthenticationSelector } from ""./AuthenticationSelector.vue"";
export { default as JiraAuthentication } from ""./JiraAuthentication.vue"";
export { default as GitHubAuthentication } from ""./GitHubAuthentication.vue"";
"
src/components/attributes/index.ts,"export { default as AttributeSettings } from ""./AttributeSettings.vue"";
"
src/components/common/index.ts,"export * from ""./button"";
export * from ""./input"";
export * from ""./display"";
export * from ""./modals"";
export * from ""./stepper"";
export * from ""./table"";
export * from ""./layout"";
export * from ""./public"";
"
src/components/common/input/index.ts,"export { default as PasswordInput } from ""./PasswordInput.vue"";
export { default as ArtifactInput } from ""./ArtifactInput.vue"";
export { default as ArtifactTypeInput } from ""./ArtifactTypeInput.vue"";
export { default as TypeIconInput } from ""./TypeIconInput.vue"";
export { default as TypeDirectionInput } from ""./TypeDirectionInput.vue"";
export { default as TypeColorInput } from ""./TypeColorInput.vue"";
export { default as GenMethodInput } from ""./GenMethodInput.vue"";
export { default as CustomModelInput } from ""./CustomModelInput.vue"";
export { default as ProjectInput } from ""./ProjectInput.vue"";
export { default as AttributeListInput } from ""./AttributeListInput.vue"";
export { default as FileInput } from ""./FileInput.vue"";
export { default as SwitchInput } from ""./SwitchInput.vue"";
export { default as TextInput } from ""./TextInput.vue"";
export { default as Searchbar } from ""./Searchbar.vue"";
export { default as MultiselectInput } from ""./MultiselectInput.vue"";
export { default as SelectInput } from ""./SelectInput.vue"";
"
src/components/common/layout/index.ts,"export { default as PanelCard } from ""./PanelCard.vue"";
export { default as SidebarGrid } from ""./SidebarGrid.vue"";
export { default as DetailsPanel } from ""./DetailsPanel.vue"";
"
src/components/common/modals/index.ts,"export { default as AppConfirmModal } from ""./AppConfirmModal.vue"";
export { default as ServerErrorModal } from ""./ServerErrorModal.vue"";
export { default as Modal } from ""./Modal.vue"";
"
src/components/common/stepper/index.ts,"export { default as Stepper } from ""./Stepper.vue"";
export { default as StepperListStep } from ""./StepperListStep.vue"";
"
src/components/common/public/index.ts,"export { default as CardPage } from ""./CardPage.vue"";
"
src/components/common/button/index.ts,"export { default as IconButton } from ""./IconButton.vue"";
export { default as TextButton } from ""./TextButton.vue"";
export { default as BackButton } from ""./BackButton.vue"";
export { default as CommitButtons } from ""./CommitButtons.vue"";
export { default as TypeButtons } from ""./TypeButtons.vue"";
"
src/components/common/table/index.ts,"export { default as DataTable } from ""./DataTable.vue"";
export { default as SelectorTable } from ""./SelectorTable.vue"";
export { default as GroupableTable } from ""./GroupableTable.vue"";
"
src/components/common/display/index.ts,"export * from ""./content"";
export * from ""./chip"";
export * from ""./attribute"";
export * from ""./list"";
export * from ""./icon"";
export * from ""./alert"";
"
src/components/common/display/attribute/index.ts,"export { default as AttributeGrid } from ""./AttributeGrid.vue"";
export { default as AttributeListDisplay } from ""./AttributeListDisplay.vue"";
"
src/components/common/display/alert/index.ts,"export { default as AlertCard } from ""./AlertCard.vue"";
export { default as FileFormatAlert } from ""./FileFormatAlert.vue"";
export { default as UnderConstructionAlert } from ""./UnderConstructionAlert.vue"";
"
src/components/common/display/chip/index.ts,"export { default as Chip } from ""./Chip.vue"";
export { default as AttributeChip } from ""./AttributeChip.vue"";
"
src/components/common/display/content/index.ts,"export { default as Separator } from ""./Separator.vue"";
export { default as Typography } from ""./Typography.vue"";
export { default as FlexBox } from ""./FlexBox.vue"";
export { default as FlexItem } from ""./FlexItem.vue"";
"
src/components/common/display/list/index.ts,"export { default as List } from ""./List.vue"";
export { default as ListItem } from ""./ListItem.vue"";
export { default as TabList } from ""./TabList.vue"";
export { default as ExpansionItem } from ""./ExpansionItem.vue"";
export { default as ArtifactBodyDisplay } from ""../../../artifact/display/ArtifactBodyDisplay.vue"";
"
src/components/common/display/icon/index.ts,"export { default as Icon } from ""./Icon.vue"";
export { default as SafaIcon } from ""./SafaIcon.vue"";
"
src/components/artifact/index.ts,"export * from ""./display"";
export * from ""./save"";
export * from ""./table"";
export * from ""./panels"";
"
src/components/artifact/panels/index.ts,"export { default as ArtifactPanel } from ""./ArtifactPanel.vue"";
export { default as ArtifactBodyPanel } from ""./ArtifactBodyPanel.vue"";
export { default as SaveArtifactPanel } from ""./SaveArtifactPanel.vue"";
export { default as ArtifactGenerationPanel } from ""./ArtifactGenerationPanel.vue"";
"
src/components/artifact/table/index.ts,"export { default as ArtifactTable } from ""./ArtifactTable.vue"";
"
src/components/artifact/display/index.ts,"export { default as ArtifactButtons } from ""./ArtifactButtons.vue"";
export { default as ArtifactContent } from ""./ArtifactContent.vue"";
export { default as ArtifactDocuments } from ""./ArtifactDocuments.vue"";
export { default as ArtifactErrors } from ""./ArtifactErrors.vue"";
export { default as ArtifactTraces } from ""./ArtifactTraces.vue"";
export { default as ArtifactBody } from ""./ArtifactBody.vue"";
export { default as ArtifactBodyDisplay } from ""./ArtifactBodyDisplay.vue"";
export { default as ArtifactContentDisplay } from ""./ArtifactContentDisplay.vue"";
export { default as ArtifactNameDisplay } from ""./ArtifactNameDisplay.vue"";
"
src/components/artifact/save/index.ts,"export { default as SaveArtifactInputs } from ""./SaveArtifactInputs.vue"";
export { default as SaveArtifactButtons } from ""./SaveArtifactButtons.vue"";
"
src/components/jobs/index.ts,"export { default as JobsTable } from ""./JobsTable.vue"";
"
src/components/account/index.ts,"export { default as ExternalLinks } from ""./ExternalLinks.vue"";
export { default as MyAccount } from ""./MyAccount.vue"";
"
src/hooks/index.ts,"export * from ""./core"";
export * from ""./project"";
export * from ""./graph"";
export * from ""./component"";
export * from ""./composables"";
export * from ""./api"";
"
src/hooks/composables/useTableFilter.ts,"import { computed, ref } from ""vue"";
import { TableFilterHook, TableFilterProps } from ""@/types"";
import { sortRows } from ""@/util"";

/**
 * A hook for sorting and filtering table rows.
 *
 * @param props - The filter props to filter table rows with.
 * @return A hook with the filtered rows.
 */
export function useTableFilter(props: TableFilterProps): TableFilterHook {
  const searchText = ref<string | null>("""");
  const sortBy = ref<string | undefined>(props.defaultSortBy);
  const sortDesc = ref(props.defaultSortDesc || false);

  const searchLabel = computed(() =>
    props.itemName ? `Search ${props.itemName}s` : ""Search""
  );

  const lowercaseSearchText = computed(() =>
    (searchText.value || """").toLowerCase()
  );

  const sortedRows = computed(() =>
    sortRows(props.rows, sortBy.value, sortDesc.value)
  );

  const columnKeys = computed(() => props.columns.map(({ name }) => name));

  const filteredRows = computed(() =>
    sortedRows.value.filter((row) => {
      if (props.filterRow && !props.filterRow(row)) {
        return false;
      }

      for (const key of columnKeys.value) {
        if (
          String(row[key]).toLowerCase().includes(lowercaseSearchText.value)
        ) {
          return true;
        }
      }

      return false;
    })
  );

  return {
    searchText,
    searchLabel,
    sortBy,
    sortDesc,
    filteredRows,
  };
}
"
src/hooks/composables/useClasses.ts,"import { computed, ComputedRef } from ""vue"";

/**
 * Creates a classname based on the given props.
 * @param props - The props to check the existence of.
 * @param classes - A list of key-value pairs, where if they key is truthy in the props, the
 * value will be included in the classname.
 * @return The computed class name.
 */
export function useClasses<T>(
  props: T,
  classes: () => [keyof T | boolean, string | undefined][]
): ComputedRef<string> {
  return computed(() => {
    const classNames: string[] = [];

    classes().forEach(([key, value]) => {
      const keyIsValid = typeof key === ""string"" ? !!props[key] : key;

      if (!keyIsValid || !value) return;

      classNames.push(value);
    });

    return classNames.join("" "");
  });
}
"
src/hooks/composables/useVModel.ts,"import { computed, getCurrentInstance, WritableComputedRef } from ""vue"";

/**
 * Synchronizes a v-model value.
 * @param props - The component props.
 * @param propName - The prop to synchronize with.
 * @emits `update:{propName}` - When the model value is set.
 */
export function useVModel<T extends Record<string, unknown>, K extends keyof T>(
  props: T,
  propName: K
): WritableComputedRef<T[K]> {
  const vm = getCurrentInstance()?.proxy;

  return computed({
    get() {
      return props[propName];
    },
    set(value) {
      vm?.$emit(`update:${String(propName)}`, value);
    },
  });
}
"
src/hooks/composables/useScreen.ts,"import { computed } from ""vue"";
import { useQuasar } from ""quasar"";
import { ScreenHook } from ""@/types"";

/**
 * A hook for managing changes with the screen size.
 */
export function useScreen(): ScreenHook {
  const $q = useQuasar();

  const screen = computed(() => $q.screen);

  const smallWindow = computed(() => $q.screen.lt.lg);

  return {
    screen,
    smallWindow,
  };
}
"
src/hooks/composables/useMargins.ts,"import { ComputedRef } from ""vue"";
import { MarginProps, SizeType } from ""@/types"";
import { useClasses } from ""./useClasses"";

const convertMargin = (value?: SizeType) => {
  switch (value) {
    case ""1"":
      return ""xs"";
    case ""2"":
      return ""sm"";
    case ""3"":
      return ""md"";
    case ""4"":
      return ""lg"";
    case ""5"":
    default:
      return ""xl"";
  }
};

/**
 * Creates a classname based on margin props.
 * @param props - The margins to include.
 * @param classes - Additional classes to include besides the margins classes.
 * @return The computed class name.
 */
export function useMargins<T extends Partial<MarginProps>>(
  props: T,
  classes: () => [keyof T | boolean, string | undefined][] = () => []
): ComputedRef<string> {
  return useClasses(props, () => [
    [""x"", ` q-mx-${convertMargin(props.x)}`],
    [""y"", ` q-my-${convertMargin(props.y)}`],
    [""l"", ` q-ml-${convertMargin(props.l)}`],
    [""r"", ` q-mr-${convertMargin(props.r)}`],
    [""t"", ` q-mt-${convertMargin(props.t)}`],
    [""b"", ` q-mb-${convertMargin(props.b)}`],
    ...classes(),
  ]);
}
"
src/hooks/composables/useTheme.ts,"import { computed } from ""vue"";
import { setCssVar, useQuasar } from ""quasar"";
import { LocalStorageKeys, ThemeHook } from ""@/types"";
import { darkPalette, lightPalette } from ""@/util"";

export function useTheme(): ThemeHook {
  const $q = useQuasar();

  const darkMode = computed({
    get: () => $q.dark.isActive,
    set: (dark) => $q.dark.set(dark),
  });

  function setTheme(): void {
    const theme = darkMode.value ? darkPalette : lightPalette;

    Object.entries(theme).forEach(([key, color]) => {
      setCssVar(key, color);
    });
  }

  function toggleDarkMode(mode?: boolean): void {
    if (mode === undefined) {
      mode = !darkMode.value;
    }

    darkMode.value = mode;
    localStorage.setItem(LocalStorageKeys.darkMode, String(mode));
    setTheme();
  }

  return {
    theme: $q,
    darkMode,
    toggleDarkMode,
  };
}
"
src/hooks/composables/index.ts,"export * from ""./useVModel"";
export * from ""./useTheme"";
export * from ""./useScreen"";
export * from ""./useMargins"";
export * from ""./useClasses"";
export * from ""./useTableFilter"";
"
src/hooks/core/useLog.ts,"import { defineStore } from ""pinia"";

import {
  APIErrorBody,
  ConfirmationType,
  MessageType,
  SnackbarMessage,
} from ""@/types"";
import { createConfirmDialogueMessage, createSnackbarMessage } from ""@/util"";
import { pinia } from ""@/plugins"";

/**
 * This module controls logging and snackbar messages.
 */
export const useLog = defineStore(""log"", {
  state: () => ({
    /**
     * The current snackbar message.
     */
    message: createSnackbarMessage(),
    /**
     * The current confirmation message.
     */
    confirmation: createConfirmDialogueMessage(),
    /**
     * The timestamp of the last message displayed.
     */
    lastMessageTimestamp: 0,
    /**
     * A list of all messages displayed in the current session.
     */
    notifications: [] as SnackbarMessage[],
  }),
  getters: {},
  actions: {
    /**
     * Clears the current snackbar message.
     */
    clearMessage(): void {
      this.message = createSnackbarMessage();
    },
    /**
     * Clears the current snackbar message.
     */
    clearConfirmation(): void {
      this.confirmation = createConfirmDialogueMessage();
    },
    setMessage(message: SnackbarMessage): void {
      if (Date.now() - this.lastMessageTimestamp < 1000) {
        setTimeout(() => {
          this.message = message;
        }, 2000);
      } else {
        this.message = message;
      }

      this.lastMessageTimestamp = Date.now();
      this.notifications = [message, ...this.notifications];
    },
    /**
     * Creates a snackbar with the given message.
     *
     * @param message - The error message encountered.
     */
    onInfo(message: string): void {
      this.setMessage({ message, type: MessageType.info, errors: [] });
    },
    /**
     * Creates a snackbar for updating with the given message.
     *
     * @param message - The error message encountered.
     */
    onUpdate(message: string): void {
      this.setMessage({ message, type: MessageType.update, errors: [] });
    },
    /**
     * Creates a snackbar success with the given message.
     *
     * @param message - The error message encountered.
     */
    onSuccess(message: string): void {
      this.setMessage({ message, type: MessageType.success, errors: [] });
    },
    /**
     * Creates a snackbar warning with the given message.
     *
     * @param message - The error message encountered.
     */
    onWarning(message: string): void {
      this.setMessage({ message, type: MessageType.warning, errors: [] });
    },
    /**
     * Creates a snackbar error with the given message.
     *
     * @param message - The error message encountered.
     */
    onError(message: string): void {
      this.setMessage({ message, type: MessageType.error, errors: [] });
    },
    /**
     * Creates a snackbar error with the given server error.
     *
     * @param error - The error encountered.
     */
    onServerError(error: APIErrorBody | undefined): void {
      this.setMessage({
        message: error?.message || ""An unexpected error occurred."",
        type: MessageType.error,
        errors: error?.errors || [],
      });
    },
    /**
     * Logs and prints message to the console.
     */
    onDevInfo(message: string): void {
      if (process.env.NODE_ENV === ""production"") return;

      console.log(message);
    },
    /**
     * Logs and prints message to the console.
     */
    onDevError(message: string): void {
      if (process.env.NODE_ENV === ""production"") return;

      console.error(message);
    },
    /**
     * Opens a confirm window to run the given callback.
     *
     * @param title - The window's title.
     * @param body - The window's body.
     * @param statusCallback - The callback to run if confirmed or closed.
     */
    confirm(
      title: string,
      body: string,
      statusCallback: (confirmed: boolean) => Promise<void>
    ): void {
      this.$patch({
        confirmation: {
          type: ConfirmationType.INFO,
          title,
          body,
          statusCallback,
        },
      });
    },
  },
});

export default useLog(pinia);
"
src/hooks/core/usePermission.ts,"import { defineStore } from ""pinia"";

import {
  IdentifierSchema,
  OrganizationPermissionType,
  ProjectPermissionType,
  ProjectRole,
} from ""@/types"";
import { projectStore, sessionStore } from ""@/hooks"";
import { pinia } from ""@/plugins"";

/**
 * This module manages user permissions.
 */
export const usePermission = defineStore(""permissionStore"", {
  state() {
    return {
      /**
       * Whether the app is in demo mode.
       */
      isDemo: false,
      /**
       * A mapping from project permission types to project roles.
       */
      projectRoleMap: {
        viewer: [
          ProjectRole.VIEWER,
          ProjectRole.EDITOR,
          ProjectRole.ADMIN,
          ProjectRole.OWNER,
        ],
        editor: [ProjectRole.EDITOR, ProjectRole.ADMIN, ProjectRole.OWNER],
        admin: [ProjectRole.ADMIN, ProjectRole.OWNER],
        owner: [ProjectRole.OWNER],
      } as Record<ProjectPermissionType, ProjectRole[]>,
    };
  },
  actions: {
    /**
     * Checks whether the current user has the given permission for their organization.
     *
     * @param permission - The permission to check.
     * @return Whether the current user has the requested permission.
     */
    organizationAllows(permission: OrganizationPermissionType): boolean {
      return permission !== ""navigation"" || !this.isDemo;
    },
    /**
     * Checks whether the current user has the given permission on the given project.
     *
     * @param permission - The permission to check.
     * @param project - The project to check.
     * @return Whether the current user has the requested permission.
     */
    projectAllows(
      permission: ProjectPermissionType,
      project: IdentifierSchema = projectStore.project
    ): boolean {
      const member = sessionStore.getProjectMember(project);

      return (
        this.organizationAllows(""navigation"") &&
        !!member &&
        this.projectRoleMap[permission].includes(member.role)
      );
    },
  },
});

export default usePermission(pinia);
"
src/hooks/core/useApp.ts,"import { defineStore } from ""pinia"";

import {
  ArtifactCreatorOpenState,
  DetailsOpenState,
  PanelStateMap,
  PanelType,
  TraceCreatorOpenState,
} from ""@/types"";
import { pinia } from ""@/plugins"";
import selectionStore from ""../graph/useSelection"";
import logStore from ""./useLog"";

/**
 * This module defines state shared across the entire app.
 */
export const useApp = defineStore(""app"", {
  state: () => ({
    /**
     * Whether the app is currently loading, as a number of loading processes.
     */
    isLoading: 0,
    /**
     * Whether the app is currently saving.
     */
    isSaving: false,
    /**
     * Whether the app is currently saving.
     */
    runUpdate: undefined as (() => Promise<void>) | undefined,
    /**
     * The open state for each type of panel.
     */
    isOpen: {
      [PanelType.appPanel]: true,
      [PanelType.detailsPanel]: false,
      [PanelType.projectSaver]: false,
      [PanelType.projectDeleter]: false,
      [PanelType.artifactCreator]: false,
      [PanelType.traceCreator]: false,
      [PanelType.errorDisplay]: false,
      [PanelType.traceLinkDraw]: false,
    } as PanelStateMap,
  }),
  getters: {
    /**
     * @return Whether the left app panel is open.
     */
    isAppPanelOpen(): boolean {
      return this.isOpen[PanelType.appPanel];
    },
    /**
     * @return Whether the right details panel is open.
     */
    isDetailsPanelOpen(): DetailsOpenState {
      return this.isOpen[PanelType.detailsPanel];
    },
    /**
     * @return Whether the project creator is open.
     */
    isProjectCreatorOpen(): boolean {
      return this.isOpen[PanelType.projectSaver];
    },
    /**
     * @return Whether the project deleter is open.
     */
    isProjectDeleterOpen(): boolean {
      return this.isOpen[PanelType.projectDeleter];
    },
    /**
     * @return Whether the artifact creator is open.
     */
    isArtifactCreatorOpen(): ArtifactCreatorOpenState {
      return this.isOpen[PanelType.artifactCreator];
    },
    /**
     * @return Whether the trace creator is open.
     */
    isTraceCreatorOpen(): TraceCreatorOpenState {
      return this.isOpen[PanelType.traceCreator];
    },
    /**
     * @return Whether the error display is open.
     */
    isErrorDisplayOpen(): boolean {
      return this.isOpen[PanelType.errorDisplay];
    },
    /**
     * @return Whether trace link drawing is enabled.
     */
    isCreateLinkEnabled(): boolean {
      return this.isOpen[PanelType.traceLinkDraw];
    },
  },
  actions: {
    /**
     * Adds a loading process.
     */
    onLoadStart(): void {
      this.isLoading += 1;
    },
    /**
     * Removes a loading process.
     */
    onLoadEnd(): void {
      this.isLoading -= 1;
    },
    /**
     * Opens the given panel.
     *
     * @param panel - The type of panel.
     */
    openPanel(panel: PanelType): void {
      this.isOpen[panel] = true;
    },
    /**
     * Closes the given panel.
     *
     * @param panel - The type of panel.
     */
    closePanel(panel: PanelType): void {
      this.isOpen[panel] = false;
    },
    /**
     * Toggles the given panel.
     *
     * @param panel - The type of panel.
     */
    togglePanel(panel: PanelType): void {
      this.isOpen[panel] = !this.isOpen[panel];
    },
    /**
     * Toggles whether the right panel is open.
     */
    toggleAppPanel(): void {
      this.togglePanel(PanelType.appPanel);
    },
    /**
     * Closes the side panels.
     */
    closeSidePanels(): void {
      this.closePanel(PanelType.detailsPanel);
      this.closePanel(PanelType.artifactCreator);
    },
    /**
     * Closes the side panels.
     */
    toggleErrorDisplay(): void {
      this.togglePanel(PanelType.errorDisplay);
    },
    /**
     * Opens the details panel.
     * @param state - The type of content to open.
     */
    openDetailsPanel(state: DetailsOpenState): void {
      this.isOpen[PanelType.detailsPanel] = state;
      this.isOpen[PanelType.appPanel] = false;
    },
    /**
     * Enables the draw link mode.
     */
    enableDrawLink(): void {
      this.openPanel(PanelType.traceLinkDraw);
    },
    /**
     * Disables the draw link mode.
     */
    disableDrawLink(): void {
      this.closePanel(PanelType.traceLinkDraw);
    },
    /**
     * Opens the artifact creator to a specific node type.
     *
     * @param openTo - What to open to.
     */
    openArtifactCreatorTo(openTo: {
      type?: ArtifactCreatorOpenState;
      isNewArtifact?: boolean;
    }): void {
      const { type, isNewArtifact } = openTo;

      if (isNewArtifact) selectionStore.clearSelections();

      this.isOpen[PanelType.artifactCreator] = type || true;
      this.openDetailsPanel(""saveArtifact"");
    },
    /**
     * Opens the artifact creator to a specific node type.
     *
     * @param openTo - What to open to.
     */
    openTraceCreatorTo(openTo?: TraceCreatorOpenState): void {
      this.isOpen[PanelType.traceCreator] = openTo || true;
      this.openDetailsPanel(""saveTrace"");
    },
    /**
     * Enqueues a new update to be loaded when the user is ready.
     *
     * @param update - A callback to run the update.
     */
    enqueueChanges(update: () => Promise<void>): void {
      this.runUpdate = update;

      logStore.onUpdate(""Recent changes can be loaded."");
    },
    /**
     * Runs any pending changes to the app.
     */
    async loadAppChanges(): Promise<void> {
      try {
        this.onLoadStart();

        this.runUpdate?.();
      } finally {
        this.runUpdate = undefined;
        this.onLoadEnd();
      }
    },
  },
});

export default useApp(pinia);
"
src/hooks/core/useSession.ts,"import { defineStore } from ""pinia"";

import { IdentifierSchema, MembershipSchema, SessionSchema } from ""@/types"";
import { createSession, createUser } from ""@/util"";
import { pinia } from ""@/plugins"";

/**
 * This module defines the state of the current user session.
 */
export const useSession = defineStore(""session"", {
  state() {
    return {
      /**
       * The current session.
       */
      session: createSession(),
      /**
       * The current user.
       */
      user: createUser(),
    };
  },
  getters: {
    /**
     * @return Whether there is a current session.
     */
    doesSessionExist(): boolean {
      return this.user.userId !== """";
    },
    /**
     * @return The authenticated user, if one exists.
     * @throws If the token does not exist.
     */
    userEmail(): string {
      return this.user.email || """";
    },
  },
  actions: {
    /**
     * Updates the current session.
     */
    updateSession(session: Partial<SessionSchema>) {
      this.session = { ...this.session, ...session };
    },
    /**
     * Clears the current session.
     */
    clearSession() {
      this.session = createSession();
      this.user = createUser();
    },
    /**
     * @return This user's membership within a project.
     */
    getProjectMember(project: IdentifierSchema): MembershipSchema | undefined {
      return project.members.find((member) => member.email === this.userEmail);
    },
  },
});

export default useSession(pinia);
"
src/hooks/core/index.ts,"export { default as logStore } from ""./useLog"";
export { default as sessionStore } from ""./useSession"";
export { default as appStore } from ""./useApp"";
export { default as permissionStore } from ""./usePermission"";
"
src/hooks/graph/useLayout.ts,"import { defineStore } from ""pinia"";

import { LayoutOptions, NodeSingular } from ""cytoscape"";
import {
  LayoutPositionsSchema,
  CyLayout,
  LayoutPayload,
  PositionSchema,
  GraphMode,
} from ""@/types"";
import {
  artifactTreeCyPromise,
  cyApplyAutomove,
  cyCreateLayout,
  cyResetTim,
  cyResetTree,
  disableDrawMode,
  timTreeCyPromise,
  GraphLayout,
} from ""@/cytoscape"";
import { pinia } from ""@/plugins"";
import { appStore } from ""@/hooks/core"";
import selectionStore from ""@/hooks/graph/useSelection"";
import subtreeStore from ""@/hooks/project/useSubtree"";

/**
 * This module handles the layout positions of the graph.
 */
export const useLayout = defineStore(""layout"", {
  state: () => ({
    /**
     * A mapping from artifact ID to its position.
     */
    artifactPositions: {} as LayoutPositionsSchema,
    /**
     * A saved position for a node to be added.
     */
    savedPosition: undefined as PositionSchema | undefined,
    /**
     * The current graph layout.
     */
    layout: undefined as CyLayout | undefined,
    /**
     * The current view mode of the graph.
     */
    mode: GraphMode.tim as GraphMode,
  }),
  getters: {
    /**
     * @return Whether the graph is in tree mode.
     */
    isTreeMode(): boolean {
      return this.mode === GraphMode.tree;
    },
    /**
     * @return Whether the graph is in table mode.
     */
    isTableMode(): boolean {
      return this.mode === GraphMode.table;
    },
    /**
     * @return Layout options for the graph.
     */
    layoutOptions(): LayoutOptions {
      return {
        name: ""preset"",
        fit: false,
        positions: (node: NodeSingular | string) => {
          const id = typeof node === ""string"" ? node : node.data().id;

          return this.artifactPositions[id] || { x: 0, y: 0 };
        },
      };
    },
  },
  actions: {
    /**
     * Sets the position of an artifact to the saved one, and clears the saved position.
     *
     * @param artifactId - The artifact id to set.
     */
    setArtifactToSavedPosition(artifactId: string): void {
      if (!this.savedPosition) return;

      this.$patch({
        savedPosition: undefined,
        artifactPositions: {
          ...this.artifactPositions,
          [artifactId]: this.savedPosition,
        },
      });
    },
    /**
     * Resets all automove events.
     */
    applyAutomove(): void {
      if (!this.layout) return;

      cyApplyAutomove(this.layout);
    },
    /**
     * Resets the graph layout.
     *
     * @param layoutPayload - The cy instance and layout.
     * @param generate - Whether to generate the layout positions.
     */
    setGraphLayout(layoutPayload: LayoutPayload, generate?: boolean): void {
      appStore.onLoadStart();

      this.layout = layoutPayload.layout;
      cyCreateLayout(layoutPayload, generate);
      this.applyAutomove();

      // Wait for the graph to render.
      setTimeout(() => {
        cyResetTim();
        cyResetTree();
        appStore.onLoadEnd();
      }, 200);
    },
    /**
     * Resets the graph layout of the artifact tree.
     * Generates a new layout if in TIM view, or if no positions are set.
     */
    setArtifactTreeLayout(): void {
      const layout = GraphLayout.createArtifactLayout();
      const payload = { layout, cyPromise: artifactTreeCyPromise };
      const generateLayout =
        this.mode === GraphMode.tim ||
        Object.keys(this.artifactPositions).length === 0;

      this.setGraphLayout(payload, generateLayout);
    },
    /**
     * Resets the graph layout of the TIM tree.
     */
    setTimTreeLayout(): void {
      const layout = GraphLayout.createTimLayout();
      const payload = { layout, cyPromise: timTreeCyPromise };

      this.setGraphLayout(payload, true);
    },
    /**
     * Resets the layout of the graph.
     */
    async resetLayout(): Promise<void> {
      appStore.onLoadStart();

      disableDrawMode();
      subtreeStore.resetHiddenNodes();
      selectionStore.clearSelections();
      appStore.closeSidePanels();

      // Wait for graph to render.
      setTimeout(() => {
        this.setArtifactTreeLayout();
        appStore.onLoadEnd();
      }, 200);
    },
    /**
     * Updates artifact positions and resets the layout.
     *
     * @param positions - The new positions to set.
     */
    async updatePositions(positions: LayoutPositionsSchema): Promise<void> {
      this.artifactPositions = positions;

      await this.resetLayout();
    },
  },
});

export default useLayout(pinia);
"
src/hooks/graph/index.ts,"export { default as layoutStore } from ""./useLayout"";
export { default as selectionStore } from ""./useSelection"";
"
src/hooks/graph/useSelection.ts,"import { defineStore } from ""pinia"";

import {
  ArtifactSchema,
  ArtifactTypeSchema,
  FilterAction,
  TraceLinkSchema,
  TraceMatrixSchema,
} from ""@/types"";
import { LARGE_NODE_COUNT, sanitizeNodeId } from ""@/util"";
import { timStore } from ""@/hooks"";
import {
  artifactTreeCyPromise,
  cyCenterOnArtifacts,
  cyIfNotAnimated,
} from ""@/cytoscape"";
import { pinia } from ""@/plugins"";
import subtreeStore from ""../project/useSubtree"";
import artifactStore from ""../project/useArtifacts"";
import traceStore from ""../project/useTraces"";
import appStore from ""../core/useApp"";

/**
 * Manages selection of parts of the project.
 */
export const useSelection = defineStore(""selection"", {
  state: () => ({
    /**
     * A collection of artifact ids currently centered on.
     */
    centeredArtifacts: [] as string[],
    /**
     * The currently selected artifact subtree.
     */
    selectedSubtreeIds: [] as string[],
    /**
     * The currently selected group of artifacts.
     */
    selectedGroupIds: [] as string[],
    /**
     * The artifact types to ignore.
     */
    ignoreTypes: [] as string[],

    /**
     * The currently selected artifact.
     */
    selectedArtifactId: """",
    /**
     * The currently selected trace link.
     */
    selectedTraceLinkIds: ["""", """"] as [string, string],
    /**
     * The currently selected artifact level.
     */
    selectedArtifactLevelType: """",
    /**
     * The currently selected trace matrix.
     */
    selectedTraceMatrixTypes: ["""", """"] as [string, string],
  }),
  getters: {
    /**
     * @return The currently selected artifact.
     */
    selectedArtifact(): ArtifactSchema | undefined {
      return artifactStore.getArtifactById(this.selectedArtifactId);
    },
    /**
     * @return The currently selected trace link.
     */
    selectedTraceLink(): TraceLinkSchema | undefined {
      return traceStore.getTraceLinkByArtifacts(
        this.selectedTraceLinkIds[0],
        this.selectedTraceLinkIds[1]
      );
    },
    /**
     * @return The currently selected artifact level.
     */
    selectedArtifactLevel(): ArtifactTypeSchema | undefined {
      return timStore.getType(this.selectedArtifactLevelType);
    },
    /**
     * @return The currently selected trace matrix.
     */
    selectedTraceMatrix(): TraceMatrixSchema | undefined {
      return timStore.getMatrix(
        this.selectedTraceMatrixTypes[0],
        this.selectedTraceMatrixTypes[1]
      );
    },
    /**
     * @return The ids of artifacts that are in the viewport.
     */
    artifactsInView(): string[] {
      const subtree = this.selectedSubtreeIds;
      const ignoreTypes = this.ignoreTypes;

      const isInSubtree = (id: string) =>
        subtree.length === 0 || subtree.includes(id);
      const doesNotContainType = (type: string) => !ignoreTypes.includes(type);

      return artifactStore.currentArtifacts
        .filter(
          (artifact) =>
            isInSubtree(artifact.id) && doesNotContainType(artifact.type)
        )
        .map(({ id }) => id);
    },
  },
  actions: {
    /**
     * Clears any selected elements in the graph.
     * Each clear is wrapped in an if-statement to help improve performance on large graphs.
     *
     * @param clearFilter - Whether to clear the filter types.
     */
    clearSelections(clearFilter = false): void {
      if (this.ignoreTypes.length > 0) {
        this.ignoreTypes = clearFilter ? [] : this.ignoreTypes;
      }
      if (this.selectedSubtreeIds.length > 0) {
        this.selectedSubtreeIds = [];
      }
      if (this.selectedGroupIds.length > 0) {
        this.selectedGroupIds = [];
      }
      if (this.selectedArtifactId) {
        this.selectedArtifactId = """";
      }
      if (this.selectedTraceLinkIds[0]) {
        this.selectedTraceLinkIds = ["""", """"];
      }
      if (this.selectedArtifactLevelType) {
        this.selectedArtifactLevelType = """";
      }
      if (this.selectedTraceMatrixTypes[0]) {
        this.selectedTraceMatrixTypes = ["""", """"];
      }
      if (appStore.isDetailsPanelOpen) {
        appStore.closeSidePanels();
      }
    },
    /**
     * Moves the viewport such that given set of artifacts is in the middle of the viewport.
     * If no artifacts are given, the entire collection of nodes is centered.
     *
     * @param artifactIds - The artifacts whose average point will be centered.
     * @param cyPromise - A promise returning an instance of cytoscape.
     */
    centerOnArtifacts(
      artifactIds: string[],
      cyPromise = artifactTreeCyPromise
    ): void {
      cyCenterOnArtifacts(
        this.centeredArtifacts,
        artifactIds,
        (ids) => (this.centeredArtifacts = ids || []),
        cyPromise
      );
    },
    /**
     * Sets the given artifact as selected.
     * To improve performance on large graphs, this function does the following:
     * - Clear selected trace links and nothing else.
     * - Only highlight the related artifacts on smaller graphs.
     *
     * @param artifactId - The artifact to select.
     */
    selectArtifact(artifactId: string): void {
      this.selectedTraceLinkIds = ["""", """"];
      this.selectedArtifactId = artifactId;

      if (artifactStore.currentArtifacts.length > LARGE_NODE_COUNT) {
        this.centerOnArtifacts([artifactId]);
      } else {
        this.filterGraph({
          type: ""subtree"",
          nodeIds: [
            ...(subtreeStore.subtreeMap[artifactId]?.neighbors || []),
            artifactId,
          ],
          centerIds: [artifactId],
        });
      }

      appStore.openDetailsPanel(""displayArtifact"");
    },
    /**
     * Sets the given artifact as selected if it is not already,
     * otherwise clears the current selection.
     *
     * @param artifactId - The artifact to select.
     */
    toggleSelectArtifact(artifactId: string): void {
      if (this.selectedArtifact?.id === artifactId) {
        this.clearSelections();
      } else {
        this.selectArtifact(artifactId);
      }
    },
    /**
     * Sets the given trace links as selected.
     *
     * To improve performance on large graphs, this function does the following:
     * - Clear selected artifact and nothing else.
     * - Only highlight the related artifacts on smaller graphs.
     *
     * @param traceLink - The trace link to select.
     */
    selectTraceLink(traceLink: TraceLinkSchema): void {
      const nodeIds: [string, string] = [
        traceLink.sourceId,
        traceLink.targetId,
      ];

      this.selectedArtifactId = """";
      this.selectedTraceLinkIds = nodeIds;

      if (artifactStore.currentArtifacts.length > LARGE_NODE_COUNT) {
        this.centerOnArtifacts(nodeIds);
      } else {
        this.filterGraph({ type: ""subtree"", nodeIds });
      }

      appStore.openDetailsPanel(""displayTrace"");
    },
    /**
     * Sets the given artifact level as selected.
     *
     * @param artifactType - The artifact type to select.
     */
    selectArtifactLevel(artifactType: string): void {
      this.clearSelections();
      this.selectedArtifactLevelType = artifactType;
      this.filterGraph({
        type: ""subtree"",
        nodeIds: [sanitizeNodeId(artifactType)],
      });
      appStore.openDetailsPanel(""displayArtifactLevel"");
    },
    /**
     * Sets the given trace matrix as selected.
     *
     * @param sourceType - The artifact source type to select.
     * @param targetType - The artifact target type to select.
     */
    selectTraceMatrix(sourceType: string, targetType: string): void {
      const nodeIds = [
        sanitizeNodeId(sourceType),
        sanitizeNodeId(targetType),
      ] as [string, string];

      this.clearSelections();
      this.selectedTraceMatrixTypes = nodeIds;
      this.filterGraph({ type: ""subtree"", nodeIds });
      appStore.openDetailsPanel(""displayTraceMatrix"");
    },
    /**
     * Filters the current artifact graph by the given filter type and action.
     *
     * @param filterAction - How to filter the graph.
     */
    filterGraph(filterAction: FilterAction): void {
      if (filterAction.type === ""ignore"") {
        if (filterAction.action === ""add"") {
          this.ignoreTypes = [...this.ignoreTypes, filterAction.ignoreType];
        } else if (filterAction.action === ""remove"") {
          this.ignoreTypes = this.ignoreTypes.filter(
            (type) => type !== filterAction.ignoreType
          );
        }
      } else if (filterAction.type === ""subtree"") {
        this.selectedSubtreeIds = filterAction.nodeIds;

        cyIfNotAnimated(() =>
          this.centerOnArtifacts(filterAction.centerIds || filterAction.nodeIds)
        );
      }
    },
    /**
     * Returns whether an artifact is within those selected.
     *
     * @param artifactId - The artifact to check.
     * @return Whether it is selected.
     */
    isArtifactInSelected(artifactId: string): boolean {
      return (
        artifactId === this.selectedArtifact?.id ||
        this.selectedGroupIds.includes(artifactId)
      );
    },
  },
});

export default useSelection(pinia);
"
src/hooks/component/useSaveAttributeLayout.ts,"import { defineStore } from ""pinia"";

import { AttributeLayoutSchema, AttributeSchema } from ""@/types"";
import { createAttributeLayout, DEFAULT_LAYOUT_ID } from ""@/util"";
import { pinia } from ""@/plugins"";
import attributesStore from ""../project/useAttributes"";

/**
 * The save attribute store assists in creating and editing attribute layouts.
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export const useSaveAttributeLayout = (id: string) =>
  defineStore(`saveAttributeLayout-${id}`, {
    state: () => ({
      /**
       * The stored base attribute layout being edited.
       */
      baseLayout: undefined as AttributeLayoutSchema | undefined,
      /**
       * The attribute layout being created or edited.
       */
      editedLayout: createAttributeLayout(),
    }),
    getters: {
      /**
       * @return Whether the current layout is not the default one.
       */
      isCustom(): boolean {
        return this.baseLayout?.id !== DEFAULT_LAYOUT_ID;
      },
      /**
       * @return Whether an existing attribute layout is being updated.
       */
      isUpdate(): boolean {
        return !!this.baseLayout;
      },
      /**
       * @return An error if this layout's list of types overlaps with another layout.
       */
      typeErrors(): string | undefined {
        const { artifactTypes, id } = this.editedLayout;

        for (const layout of attributesStore.attributeLayouts || []) {
          if (layout.id === id) continue;

          if (artifactTypes.length === 0 && layout.artifactTypes.length === 0) {
            return `A default layout already exists: ${layout.name}.`;
          }

          for (const type of artifactTypes) {
            if (layout.artifactTypes.includes(type)) {
              return `A layout for ""${type}"" already exists: ${layout.name}.`;
            }
          }
        }
      },
      /**
       * @return Whether this attribute layout can be saved.
       */
      canSave(): boolean {
        return !!this.editedLayout.name && !this.typeErrors;
      },
    },
    actions: {
      /**
       * Resets the state of the attribute layout to the selected artifact.
       * @param baseLayout - The layout to reset data to.
       */
      resetLayout(baseLayout: AttributeLayoutSchema | undefined): void {
        this.baseLayout = baseLayout;
        this.editedLayout = createAttributeLayout(this.baseLayout);
      },
      /**
       * Adds an attribute to the bottom of the edited layout.
       * @param key - The attribute key to add to the layout.
       */
      addAttribute(key: string): void {
        const y =
          this.editedLayout.positions.length === 0
            ? 0
            : Math.max(0, ...this.editedLayout.positions.map(({ y }) => y)) + 1;

        this.editedLayout.positions.push({
          key,
          y,
          x: 0,
          width: 1,
          height: 1,
        });
      },
      /**
       * Removes an attribute from the layout.
       * @param attribute - The attribute to add to the layout.
       */
      deleteAttribute(attribute: AttributeSchema): void {
        this.editedLayout.positions = this.editedLayout.positions.filter(
          ({ key }) => key !== attribute.key
        );
      },
    },
  });

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export default (id: string) => useSaveAttributeLayout(id)(pinia);
"
src/hooks/component/useSaveIdentifier.ts,"import { defineStore } from ""pinia"";

import { IdentifierSchema } from ""@/types"";
import { createProjectIdentifier } from ""@/util"";
import { appStore } from ""@/hooks"";
import { pinia } from ""@/plugins"";

/**
 * The save identifier store assists in creating and editing project identifiers.
 */
export const useSaveIdentifier = defineStore(""saveIdentifier"", {
  state: () => ({
    /**
     * A base identifier being edited.
     */
    baseIdentifier: undefined as IdentifierSchema | undefined,
    /**
     * The identifier being created or edited.
     */
    editedIdentifier: createProjectIdentifier(),
  }),
  getters: {
    /**
     * @return Whether an existing identifier is being updated.
     */
    isUpdate(): boolean {
      return !!this.baseIdentifier;
    },
    /**
     * @return Whether the identifier can be saved.
     */
    canSave(): boolean {
      return this.editedIdentifier.name.length > 0;
    },
  },
  actions: {
    /**
     * Resets the identifier value to the given base value.
     */
    resetIdentifier(): void {
      this.editedIdentifier = createProjectIdentifier(this.baseIdentifier);
    },
    /**
     * Selects an identifier and opens the edit or delete modal.
     *
     * @param identifier - The identifier to select.
     * @param mode - The type of action to open a modal for.
     */
    selectIdentifier(
      identifier: IdentifierSchema | undefined,
      mode: ""save"" | ""delete""
    ): void {
      this.baseIdentifier = identifier;
      this.resetIdentifier();

      appStore.isOpen[mode === ""save"" ? ""projectSaver"" : ""projectDeleter""] =
        true;
    },
  },
});

export default useSaveIdentifier(pinia);
"
src/hooks/component/useSaveTrace.ts,"import { defineStore } from ""pinia"";

import { ArtifactSchema } from ""@/types"";
import { appStore, subtreeStore, timStore, traceStore } from ""@/hooks"";
import { pinia } from ""@/plugins"";
import artifactStore from ""../project/useArtifacts"";

/**
 * The save trace store assists in creating batches of trace links.
 */
export const useSaveTrace = defineStore(""saveTrace"", {
  state: () => ({
    /**
     * The source artifact ids.
     */
    sourceIds: null as string[] | null,
    /**
     * The target artifact ids.
     */
    targetIds: null as string[] | null,
  }),
  getters: {
    /**
     * @return The number of source artifacts.
     */
    sourceCount(): number {
      return this.sourceIds?.length || 0;
    },
    /**
     * @return The number of target artifacts.
     */
    targetCount(): number {
      return this.targetIds?.length || 0;
    },
    /**
     * @return The source artifacts.
     */
    sources(): (ArtifactSchema | undefined)[] {
      return (
        this.sourceIds?.map((id) => artifactStore.getArtifactById(id)) || []
      );
    },
    /**
     * @return The target artifacts.
     */
    targets(): (ArtifactSchema | undefined)[] {
      return (
        this.targetIds?.map((id) => artifactStore.getArtifactById(id)) || []
      );
    },
    /**
     * @return The default artifact types hidden from source artifacts.
     * - If source artifacts are set, the default filter will be set to their types.
     * - If target artifacts are set, the default filter will be set to the types
     *   of the source artifacts that can be linked to the target artifacts.
     * - If neither are set, the default filter will be set to all types.
     */
    defaultHiddenSourceTypes(): string[] {
      const allTypes = timStore.typeNames;
      let hiddenTypes: string[] = [];

      if (this.sourceCount > 0) {
        const sourceTypes = this.sources
          .map((source) => source?.type || """")
          .filter((type) => !!type);

        hiddenTypes = allTypes.filter((type) => !sourceTypes.includes(type));
      } else if (this.targetCount > 0) {
        const targetTypes = this.targets
          .map((target) => target?.type || """")
          .filter((type) => !!type);
        const sourceTypes = timStore.traceMatrices
          .map((matrix) =>
            targetTypes.includes(matrix.targetType) ? matrix.sourceType : """"
          )
          .filter((type) => !!type);

        hiddenTypes = allTypes.filter((type) => !sourceTypes.includes(type));
      }

      if (hiddenTypes.length === allTypes.length) {
        hiddenTypes = [];
      }

      return hiddenTypes;
    },
    /**
     * @return The default artifact types hidden from target artifacts.
     * - If target artifacts are set, the default filter will be set to their types.
     * - If source artifacts are set, the default filter will be set to the types
     *   of the target artifacts that can be linked to the source artifacts.
     * - If neither are set, the default filter will be set to all types.
     */
    defaultHiddenTargetTypes(): string[] {
      const allTypes = timStore.typeNames;
      let hiddenTypes: string[] = [];

      if (this.targetCount > 0) {
        const targetTypes = this.targets
          .map((target) => target?.type || """")
          .filter((type) => !!type);

        hiddenTypes = allTypes.filter((type) => !targetTypes.includes(type));
      } else if (this.sourceCount > 0) {
        const sourceTypes = this.sources
          .map((source) => source?.type || """")
          .filter((type) => !!type);
        const targetTypes = timStore.traceMatrices
          .map((matrix) =>
            sourceTypes.includes(matrix.sourceType) ? matrix.targetType : """"
          )
          .filter((type) => !!type);

        hiddenTypes = allTypes.filter((type) => !targetTypes.includes(type));
      }

      if (hiddenTypes.length === allTypes.length) {
        hiddenTypes = [];
      }

      return hiddenTypes;
    },
    /**
     * @return The default artifact ids hidden from target artifacts,
     * as they are already traced to source artifacts.
     */
    hiddenTargetIds(): string[] {
      if (this.sourceCount === 0) return [];

      return (this.sourceIds || [])
        .map((id) => subtreeStore.getSubtreeItem(id).parents)
        .reduce((acc, cur) => [...acc, ...cur], []);
    },
    /**
     * @return The default artifact ids hidden from source artifacts,
     * as they are already traced to target artifacts.
     */
    hiddenSourceIds(): string[] {
      if (this.targetCount === 0) return [];

      return (this.targetIds || [])
        .map((id) => subtreeStore.getSubtreeItem(id).children)
        .reduce((acc, cur) => [...acc, ...cur], []);
    },
    /**
     * @return If the source and target ids are valid, returns empty, else returns an error message.
     */
    errorMessage(): string {
      if (this.sourceCount > 1 && this.targetCount > 1) {
        return ""Cannot create a trace link between multiple source and multiple target artifacts."";
      }

      for (const target of this.targets) {
        for (const source of this.sources) {
          if (!source) {
            return ""Child artifact does not exist."";
          } else if (!target) {
            return ""Parent artifact does not exist."";
          }

          const isLinkAllowed = traceStore.isLinkAllowed(source, target);

          if (isLinkAllowed !== true) {
            return isLinkAllowed || ""Cannot create a trace link."";
          }
        }
      }

      return """";
    },
    /**
     * @return Whether the links to be created are valid and can be saved.
     */
    canSave(): boolean {
      return this.sourceCount > 0 && this.targetCount > 0 && !this.errorMessage;
    },
  },
  actions: {
    /**
     * Resets the state of the trace based on selected artifacts.
     */
    resetTrace(): void {
      const openState = appStore.isTraceCreatorOpen;

      this.sourceIds = [];
      this.targetIds = [];

      if (typeof openState !== ""object"") return;

      if (openState.type === ""source"") {
        this.sourceIds = [openState.artifactId];
      } else if (openState.type === ""target"") {
        this.targetIds = [openState.artifactId];
      } else {
        this.sourceIds = [openState.sourceId];
        this.targetIds = [openState.targetId];
      }
    },
  },
});

export default useSaveTrace(pinia);
"
src/hooks/component/useSaveAttribute.ts,"import { defineStore } from ""pinia"";

import { AttributeSchema, AttributeType } from ""@/types"";
import { createAttribute } from ""@/util"";
import { pinia } from ""@/plugins"";

/**
 * The save attribute store assists in creating and editing attributes.
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export const useSaveAttribute = (id: string) =>
  defineStore(`saveAttribute-${id}`, {
    state: () => ({
      /**
       * The stored base attribute being edited.
       */
      baseAttribute: undefined as AttributeSchema | undefined,
      /**
       * The attribute being created or edited.
       */
      editedAttribute: createAttribute(),
    }),
    getters: {
      /**
       * @return Whether an existing attribute is being updated.
       */
      isUpdate(): boolean {
        return !!this.baseAttribute;
      },
      /**
       * @return Whether this attribute can be edited.
       */
      isReadOnly(): boolean {
        return this.baseAttribute?.key.startsWith(""~"") || false;
      },
      /**
       * @return The data type of this attribute.
       */
      type(): AttributeType {
        return this.editedAttribute.type;
      },
      /**
       * @return Whether this attribute value has selectable options.
       */
      showOptions(): boolean {
        return [AttributeType.select, AttributeType.multiselect].includes(
          this.type
        );
      },
      /**
       * @return Whether this attribute value has min and max bounds.
       */
      showBounds(): boolean {
        return [
          AttributeType.text,
          AttributeType.paragraph,
          AttributeType.int,
          AttributeType.float,
        ].includes(this.type);
      },
      /**
       * @return The hint for the min bound.
       */
      minBoundHint(): string {
        return [AttributeType.int, AttributeType.float].includes(this.type)
          ? ""The minimum value of this number.""
          : ""The minimum length of this value."";
      },
      /**
       * @return The hint for the max bound.
       */
      maxBoundHint(): string {
        return [AttributeType.int, AttributeType.float].includes(this.type)
          ? ""The maximum value of this number.""
          : ""The maximum length of this value."";
      },
      /**
       * @return The error message for the key.
       */
      keyError(): string {
        return this.editedAttribute.key.startsWith(""~"")
          ? ""Key cannot start with ~""
          : """";
      },
      /**
       * @return Whether this attribute can be saved.
       */
      canSave(): boolean {
        return (
          !!this.editedAttribute.key &&
          !!this.editedAttribute.label &&
          !!this.editedAttribute.type &&
          !this.keyError
        );
      },
    },
    actions: {
      /**
       * Resets the state of the attribute to the selected artifact.
       */
      resetAttribute(baseAttribute: AttributeSchema | undefined): void {
        this.baseAttribute = baseAttribute;
        this.editedAttribute = createAttribute(this.baseAttribute);
      },
    },
  });

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export default (id: string) => useSaveAttribute(id)(pinia);
"
src/hooks/component/useSaveDocument.ts,"import { defineStore } from ""pinia"";

import { DocumentSchema } from ""@/types"";
import { createDocument } from ""@/util"";
import { pinia } from ""@/plugins"";
import artifactStore from ""../project/useArtifacts"";
import documentStore from ""../project/useDocuments"";
import subtreeStore from ""../project/useSubtree"";

/**
 * The save document store assists in creating and editing documents.
 */
export const useSaveDocument = defineStore(""saveDocument"", {
  state: () => ({
    /**
     * A base document being edited.
     */
    baseDocument: undefined as DocumentSchema | undefined,
    /**
     * The document being created or edited.
     */
    editedDocument: createDocument(),
    /**
     * The types of included artifacts.
     */
    includedTypes: [] as string[],
    /**
     * Whether to include child artifacts.
     */
    includeChildren: false,
    /**
     * The types of included child artifacts.
     */
    includedChildTypes: [] as string[],
    /**
     * The ids of included child artifacts.
     */
    childIds: [] as string[],
  }),
  getters: {
    /**
     * @return Whether an existing document is being updated.
     */
    isUpdate(): boolean {
      return !!this.baseDocument;
    },
    /**
     * @return Whether the current document name is valid.
     */
    isNameValid(): boolean {
      return (
        !documentStore.doesDocumentExist(this.editedDocument?.name) ||
        this.baseDocument?.name === this.editedDocument.name
      );
    },
    /**
     * @return Document name errors to display.
     */
    nameError(): string | false {
      return this.isNameValid || this.editedDocument.name === """"
        ? false
        : ""This name is already used, please select another."";
    },
    /**
     * @return Whether the document can be saved.
     */
    canSave(): boolean {
      return this.editedDocument.name.length > 0 && this.isNameValid;
    },
    /**
     * @return The finalized document being saved.
     */
    finalizedDocument(): DocumentSchema {
      return {
        ...this.editedDocument,
        artifactIds: this.includeChildren
          ? [...this.editedDocument.artifactIds, ...this.childIds]
          : this.editedDocument.artifactIds,
      };
    },
  },
  actions: {
    /**
     * Resets the document value to the given base value.
     */
    resetDocument(): void {
      this.editedDocument = createDocument(this.baseDocument);
      this.includedTypes = [];
      this.includeChildren = false;
      this.includedChildTypes = [];
      this.childIds = [];
    },
    /**
     * Generates artifacts to save on this document.
     */
    updateArtifacts(): void {
      const baseArtifacts = this.baseDocument?.artifactIds || [];

      this.editedDocument.artifactIds =
        this.includedTypes.length > 0
          ? artifactStore.allArtifacts
              .filter(
                ({ id, type }) =>
                  this.includedTypes.includes(type) ||
                  baseArtifacts.includes(id)
              )
              .map(({ id }) => id)
          : baseArtifacts;
    },
    /**
     * Generates child artifacts to save on this document.
     */
    updateChildArtifacts(): void {
      this.childIds = subtreeStore.getMatchingChildren(
        this.editedDocument.artifactIds,
        this.includedChildTypes
      );
    },
  },
});

export default useSaveDocument(pinia);
"
src/hooks/component/useSaveModel.ts,"import { defineStore } from ""pinia"";

import { GenerationModelSchema } from ""@/types"";
import { createModel } from ""@/util"";
import { pinia } from ""@/plugins"";

/**
 * The save model store assists in creating and editing project models.
 */
export const useSaveModel = defineStore(""saveModel"", {
  state: () => ({
    /**
     * A base model being edited.
     */
    baseModel: undefined as GenerationModelSchema | undefined,
    /**
     * The model being created or edited.
     */
    editedModel: createModel(),
  }),
  getters: {
    /**
     * @return Whether an existing model is being updated.
     */
    isUpdate(): boolean {
      return !!this.baseModel;
    },
    /**
     * @return Whether the model can be saved.
     */
    canSave(): boolean {
      return this.editedModel.name.length > 0;
    },
  },
  actions: {
    /**
     * Resets the model value to the given base value.
     */
    resetModel(): void {
      this.editedModel = createModel(this.baseModel);
    },
  },
});

export default useSaveModel(pinia);
"
src/hooks/component/index.ts,"export { default as artifactSaveStore } from ""./useSaveArtifact"";
export { default as traceSaveStore } from ""./useSaveTrace"";
export { default as identifierSaveStore } from ""./useSaveIdentifier"";
export { default as projectSaveStore } from ""./useSaveProject"";
export { default as modelSaveStore } from ""./useSaveModel"";
export { default as documentSaveStore } from ""./useSaveDocument"";
export { default as attributeSaveStore } from ""./useSaveAttribute"";
export { default as attributeLayoutSaveStore } from ""./useSaveAttributeLayout"";
"
src/hooks/component/useSaveProject.ts,"import { defineStore } from ""pinia"";

import {
  ArtifactMap,
  CreateProjectByJsonSchema,
  CreatorFilePanel,
  MembershipSchema,
  ProjectRole,
} from ""@/types"";
import { createProject } from ""@/util"";
import sessionStore from ""@/hooks/core/useSession"";
import { pinia } from ""@/plugins"";

const createEmptyPanel = (variant: ""artifact"" | ""trace""): CreatorFilePanel => ({
  variant,
  name: """",
  type: """",
  open: true,
  valid: false,
  loading: false,
  ignoreErrors: false,
  itemNames: [],
  isGenerated: false,
  generateMethod: undefined,
});

/**
 * The save project store assists in creating new projects.
 */
export const useSaveProject = defineStore(""saveProject"", {
  state: () => ({
    name: """",
    description: """",
    artifactPanels: [createEmptyPanel(""artifact"")] as CreatorFilePanel[],
    tracePanels: [createEmptyPanel(""trace"")] as CreatorFilePanel[],
    artifactMap: {} as ArtifactMap,
  }),
  getters: {
    /**
     * @return All artifact types.
     */
    artifactTypes(): string[] {
      return this.artifactPanels.map(({ type }) => type);
    },
    /**
     * @return A project creation request with the uploaded data.
     */
    creationRequest(): CreateProjectByJsonSchema {
      const artifacts = this.artifactPanels
        .map(({ artifacts = [] }) => artifacts)
        .reduce((acc, cur) => [...acc, ...cur], []);
      const traces = this.tracePanels
        .map(({ traces = [] }) => traces)
        .reduce((acc, cur) => [...acc, ...cur], []);
      const requests = this.tracePanels
        .filter(({ isGenerated }) => isGenerated)
        .map(({ type, toType = """", generateMethod }) => ({
          artifactLevels: [
            {
              source: type,
              target: toType,
            },
          ],
          method: generateMethod,
        }));
      const user: MembershipSchema = {
        projectMembershipId: """",
        email: sessionStore.userEmail,
        role: ProjectRole.OWNER,
      };
      const project = createProject({
        name: this.name,
        description: this.description,
        owner: user.email,
        members: [user],
        artifacts,
        traces,
      });

      return { project, requests };
    },
  },
  actions: {
    /**
     * Resets the created project state.
     */
    resetProject(): void {
      this.name = """";
      this.description = """";
      this.artifactPanels = [createEmptyPanel(""artifact"")];
      this.tracePanels = [createEmptyPanel(""trace"")];
      this.artifactMap = {};
    },
    /**
     * Adds a new creator panel.
     * @param variant - The type of panel to add.
     */
    addPanel(variant: ""artifact"" | ""trace""): void {
      if (variant === ""artifact"") {
        this.artifactPanels.push(createEmptyPanel(""artifact""));
      } else {
        this.tracePanels.push(createEmptyPanel(""trace""));
      }
    },
    /**
     * Removes a creator panel.
     * @param variant - The type of panel to remove.
     * @param index - The panel index to remove.
     */
    removePanel(variant: ""artifact"" | ""trace"", index: number): void {
      if (variant === ""artifact"") {
        this.artifactPanels = this.artifactPanels.filter((_, i) => i !== index);
      } else {
        this.tracePanels = this.tracePanels.filter((_, i) => i !== index);
      }
    },
  },
});

export default useSaveProject(pinia);
"
src/hooks/component/useSaveArtifact.ts,"import { defineStore } from ""pinia"";

import { ArtifactSchema, DocumentType } from ""@/types"";
import { createArtifact, createArtifactOfType } from ""@/util"";
import { pinia } from ""@/plugins"";
import selectionStore from ""../graph/useSelection"";
import artifactStore from ""../project/useArtifacts"";
import documentStore from ""../project/useDocuments"";

/**
 * The save artifact store assists in creating and editing artifacts.
 */
export const useSaveArtifact = defineStore(""saveArtifact"", {
  state: () => ({
    /**
     * The artifact being created or edited.
     */
    editedArtifact: createArtifact(selectionStore.selectedArtifact),
    /**
     * The id of the parent artifact to connect to, if there is one.
     */
    parentId: """",
    /**
     * Whether the artifact's name is valid.
     */
    isNameValid: false,
  }),
  getters: {
    /**
     * @return Whether an existing artifact is being updated.
     */
    isUpdate(): boolean {
      return !!selectionStore.selectedArtifact;
    },
    /**
     * @return Whether the artifact name has changed.
     */
    hasNameChanged(): boolean {
      return selectionStore.selectedArtifact?.name !== this.editedArtifact.name;
    },
    /**
     * @return Whether the base artifact has a summary.
     */
    hasSummary(): boolean {
      return !!selectionStore.selectedArtifact?.summary;
    },
    /**
     * @return Whether the artifact type is for an FTA node.
     */
    isFTA(): boolean {
      return this.editedArtifact.documentType === DocumentType.FTA;
    },
    /**
     * @return Whether the artifact type is for a safety case node.
     */
    isSafetyCase(): boolean {
      return this.editedArtifact.documentType === DocumentType.SAFETY_CASE;
    },
    /**
     * @return Whether the artifact type is for an FMEA node.
     */
    isFMEA(): boolean {
      return this.editedArtifact.documentType === DocumentType.FMEA;
    },
    /**
     * @return The parent artifact of a logic node.
     */
    parentArtifact(): ArtifactSchema | undefined {
      return this.parentId
        ? artifactStore.getArtifactById(this.parentId)
        : undefined;
    },
    /**
     * @return The computed type based on the artifact's document type.
     */
    computedArtifactType(): string {
      if (this.isFTA) {
        return this.parentArtifact?.type || this.editedArtifact.type;
      } else {
        return this.editedArtifact.type;
      }
    },
    /**
     * @return The computed name based on the artifact's document type.
     */
    computedName(): string {
      const { name, logicType } = this.editedArtifact;

      return this.isFTA
        ? `${this.parentArtifact?.name || this.parentId}-${logicType}`
        : name;
    },
    /**
     * @return Any errors to report on the name.
     */
    nameError(): string | false {
      return this.isNameValid || this.editedArtifact.name === """"
        ? false
        : ""This name is already used, please select another."";
    },
    /**
     * @return Whether the artifact is valid and can be saved.
     */
    canSave(): boolean {
      const { logicType, safetyCaseType, type, body } = this.editedArtifact;

      if (this.isFTA) {
        return !!(logicType && this.parentId);
      } else if (this.isSafetyCase) {
        return !!(this.isNameValid && body && safetyCaseType);
      } else if (this.isFMEA) {
        return !!(this.isNameValid && body);
      } else {
        return !!(this.isNameValid && body && type);
      }
    },
    /**
     * @return The savable artifact data based on the edited artifact's fields.
     */
    finalizedArtifact(): ArtifactSchema {
      const { documentId } = documentStore.currentDocument;
      const { logicType, safetyCaseType } = this.editedArtifact;

      return createArtifact({
        ...this.editedArtifact,
        name: this.computedName,
        type: this.computedArtifactType,
        documentIds: documentId ? [documentId] : [],
        logicType: this.isFTA ? logicType : undefined,
        safetyCaseType: this.isSafetyCase ? safetyCaseType : undefined,
      });
    },
  },
  actions: {
    /**
     * Resets the state of the artifact to the selected artifact.
     *
     * @param type - The type of artifact creation to open to.
     */
    resetArtifact(type: true | string | undefined): void {
      const artifact = selectionStore.selectedArtifact;

      this.editedArtifact = createArtifactOfType(artifact, type);
      this.isNameValid = !!artifact?.name;
      this.parentId = """";
    },
    /**
     * Updates the edited artifact to a new type.
     */
    updateArtifactType(): void {
      this.editedArtifact = createArtifactOfType(
        this.editedArtifact,
        this.editedArtifact.type
      );
    },
  },
});

export default useSaveArtifact(pinia);
"
src/hooks/project/useJobs.ts,"import { defineStore } from ""pinia"";

import { JobSchema, JobStatus } from ""@/types"";
import { pinia } from ""@/plugins"";

/**
 * This module tracks the jobs submitted by the user.
 */
export const useJobs = defineStore(""jobs"", {
  state: () => ({
    /**
     * The list of user jobs.
     */
    jobs: [] as JobSchema[],
    /**
     * The index of the selected job.
     */
    selectedJob: undefined as JobSchema | undefined,
    /**
     * The ids of any jobs completed during this session.
     */
    completedJobIds: [] as string[],
  }),
  getters: {
    /**
     * Returns in progress jobs.
     */
    inProgressJobs(): JobSchema[] {
      return this.jobs.filter(({ status }) => status === JobStatus.IN_PROGRESS);
    },
    /**
     * Returns in progress jobs, as well as any completed within this session.
     */
    recentJobs(): JobSchema[] {
      return this.jobs.filter(
        ({ status, id }) =>
          status === JobStatus.IN_PROGRESS || this.completedJobIds.includes(id)
      );
    },
  },
  actions: {
    /**
     * Toggles whether a job is selected.
     * @param job - The job to select.
     */
    selectJob(job: JobSchema): void {
      this.selectedJob = this.selectedJob === job ? undefined : job;
    },
    /**
     * Adds job to list of jobs if new job, otherwise updates previous one.
     * New or updated job will be first element of the list of jobs.
     *
     * @param job - The job to update.
     */
    updateJob(job: JobSchema): void {
      if (job.status === JobStatus.COMPLETED) {
        this.completedJobIds.push(job.id);
      }

      this.jobs = [job, ...this.jobs.filter(({ id }) => id !== job.id)];
    },
    /**
     * Removes job matching id of given job.
     *
     * @param job - The job, or id, to delete.
     */
    deleteJob(job: JobSchema | string): void {
      const deleteId = typeof job === ""string"" ? job : job.id;
      const jobs = this.jobs.filter(({ id }) => id !== deleteId);

      this.$patch({
        jobs,
        selectedJob: jobs[0],
      });
    },
  },
});

export default useJobs(pinia);
"
src/hooks/project/useDelta.ts,"import { defineStore } from ""pinia"";

import {
  ApprovalType,
  ArtifactDeltaState,
  ArtifactSchema,
  EntityModificationSchema,
  GraphMode,
  VersionDeltaSchema,
  TraceLinkSchema,
  VersionSchema,
} from ""@/types"";
import { createProjectDelta } from ""@/util"";
import { disableDrawMode } from ""@/cytoscape"";
import { pinia } from ""@/plugins"";
import layoutStore from ""../graph/useLayout"";
import appStore from ""../core/useApp"";
import subtreeStore from ""./useSubtree"";
import artifactStore from ""./useArtifacts"";
import traceStore from ""./useTraces"";

/**
 * This module tracks the delta state of a project.
 */
export const useDelta = defineStore(""delta"", {
  state: () => ({
    /**
     * Whether the artifact delta view is currently enabled.
     */
    inDeltaView: false,
    /**
     * The version that artifact deltas have been made to.
     */
    afterVersion: undefined as VersionSchema | undefined,
    /**
     * A collection of all added artifacts.
     */
    projectDelta: createProjectDelta(),
  }),
  getters: {
    /**
     * @return A collection of all added artifacts.
     */
    addedArtifacts(): Record<string, ArtifactSchema> {
      return this.projectDelta.artifacts.added;
    },
    /**
     * @return A collection of all removed artifacts.
     */
    removedArtifacts(): Record<string, ArtifactSchema> {
      return this.projectDelta.artifacts.removed;
    },
    /**
     * @return A collection of all modified artifacts.
     */
    modifiedArtifacts(): Record<
      string,
      EntityModificationSchema<ArtifactSchema>
    > {
      return this.projectDelta.artifacts.modified;
    },
    /**
     * @return A collection of all added traces.
     */
    addedTraces(): Record<string, TraceLinkSchema> {
      return this.projectDelta.traces.added;
    },
    /**
     * @return A collection of all removed traces.
     */
    removedTraces(): Record<string, TraceLinkSchema> {
      return this.projectDelta.traces.removed;
    },
  },
  actions: {
    /**
     * Sets whether the delta view is enabled.
     *
     * @param isDeltaViewEnabled - Whether to enable this view.
     */
    setIsDeltaViewEnabled(isDeltaViewEnabled: boolean): void {
      if (this.inDeltaView && !isDeltaViewEnabled) {
        layoutStore.mode = GraphMode.tim;
        this.afterVersion = undefined;
      } else {
        appStore.closeSidePanels();
      }

      this.inDeltaView = isDeltaViewEnabled;

      disableDrawMode();
    },
    /**
     * Clears the current delta and resets the graph state.
     */
    clear(): void {
      this.setIsDeltaViewEnabled(false);
      this.$reset();
    },
    /**
     * Sets the current artifact deltas.
     *
     * @param payload - All artifact deltas.
     * @param afterVersion - The version that artifact deltas have been made to.
     */
    async setDeltaPayload(
      payload: VersionDeltaSchema,
      afterVersion?: VersionSchema
    ): Promise<void> {
      this.projectDelta = payload;
      this.afterVersion = afterVersion;

      const artifacts = [
        ...Object.values(payload.artifacts.added),
        ...Object.values(payload.artifacts.modified).map(({ after }) => after),
        ...Object.values(payload.artifacts.removed),
      ];

      const removedTraces = Object.values(payload.traces.removed);
      const traces = [
        ...Object.values(payload.traces.added),
        ...Object.values(payload.traces.modified).map(({ after }) => after),
        ...removedTraces,
      ];

      // Add all updated artifacts and traces to the store.
      artifactStore.addOrUpdateArtifacts(artifacts);
      traceStore.addOrUpdateTraceLinks(traces);

      // Add removed traces back into the subtree.
      removedTraces.forEach((trace) => subtreeStore.addTraceSubtree(trace));

      // Switch the current artifact & trace store to only show artifacts in the delta.
      const currentArtifactIds = artifacts.flatMap(({ id }) => [
        id,
        // Add all neighbors of the artifact to the list of artifacts to show.
        ...(subtreeStore.subtreeMap[id]?.neighbors || []),
      ]);

      artifactStore.initializeArtifacts({ currentArtifactIds });
      traceStore.initializeTraces({ currentArtifactIds });

      // Switch to tree view and generate the graph layout for the unique set of delta artifacts.
      await subtreeStore.restoreHiddenNodesAfter(async () => {
        layoutStore.mode = GraphMode.tree;
        await layoutStore.updatePositions({});
        layoutStore.setArtifactTreeLayout();
      });
      this.setIsDeltaViewEnabled(true);
    },
    /**
     * Returns the delta states of all of the given artifacts.
     *
     * @param artifactIds - The artifacts to find the state of.
     * @return All unique change states found within the artifacts.
     */
    getArtifactDeltaStates(artifactIds: string[]): ArtifactDeltaState[] {
      const deltaStates = new Set<ArtifactDeltaState>();

      for (const id of artifactIds) {
        if (id in this.projectDelta.artifacts.added) {
          deltaStates.add(ArtifactDeltaState.ADDED);
        } else if (id in this.projectDelta.artifacts.modified) {
          deltaStates.add(ArtifactDeltaState.MODIFIED);
        } else if (id in this.projectDelta.artifacts.removed) {
          deltaStates.add(ArtifactDeltaState.REMOVED);
        }
      }

      return Array.from(deltaStates);
    },

    /**
     * Finds the delta state of a trace link.
     *
     * @param id - The trace link id to find.
     * @return The trace links delta state, if one exists.
     */
    getTraceDeltaType(id: string): ArtifactDeltaState {
      if (!this.inDeltaView) {
        return ArtifactDeltaState.NO_CHANGE;
      } else if (id in this.projectDelta.traces.added) {
        return ArtifactDeltaState.ADDED;
      } else if (id in this.projectDelta.traces.modified) {
        if (
          this.projectDelta.traces.modified[id].after.approvalStatus ===
          ApprovalType.DECLINED
        ) {
          return ArtifactDeltaState.REMOVED;
        } else {
          return ArtifactDeltaState.MODIFIED;
        }
      } else if (id in this.projectDelta.traces.removed) {
        return ArtifactDeltaState.REMOVED;
      } else {
        return ArtifactDeltaState.NO_CHANGE;
      }
    },
    /**
     * Finds the delta state of an artifact.
     *
     * @param id - The artifact id to find.
     * @return The artifact delta state, if one exists.
     */
    getArtifactDeltaType(id: string): ArtifactDeltaState {
      if (!this.inDeltaView) {
        return ArtifactDeltaState.NO_CHANGE;
      } else if (id in this.projectDelta.artifacts.added) {
        return ArtifactDeltaState.ADDED;
      } else if (id in this.projectDelta.artifacts.modified) {
        return ArtifactDeltaState.MODIFIED;
      } else if (id in this.projectDelta.artifacts.removed) {
        return ArtifactDeltaState.REMOVED;
      } else {
        return ArtifactDeltaState.NO_CHANGE;
      }
    },
  },
});

export default useDelta(pinia);
"
src/hooks/project/useProject.ts,"import { defineStore } from ""pinia"";
import {
  IdentifierSchema,
  ProjectSchema,
  GenerationModelSchema,
  VersionSchema,
} from ""@/types"";
import { createProject, createProjectIdentifier } from ""@/util"";
import { pinia } from ""@/plugins"";
import selectionStore from ""../graph/useSelection"";
import logStore from ""../core/useLog"";
import membersStore from ""./useMembers"";
import warningStore from ""./useWarnings"";
import documentStore from ""./useDocuments"";
import subtreeStore from ""./useSubtree"";
import attributesStore from ""./useAttributes"";
import timStore from ""./useTIM"";

/**
 * Manages the selected project.
 */
export const useProject = defineStore(""project"", {
  state: () => ({
    /**
     * The currently loaded project.
     */
    project: createProject(),
  }),
  getters: {
    /**
     * @return The full project identifier.
     */
    projectIdentifier(): IdentifierSchema {
      return createProjectIdentifier(this.project);
    },
    /**
     * @return The current project id.
     */
    projectId(): string {
      return this.project.projectId;
    },
    /**
     * @return The current version.
     */
    version(): VersionSchema | undefined {
      return this.project.projectVersion;
    },
    /**
     * @return The current version id.
     */
    versionId(): string {
      return this.version?.versionId || """";
    },
    /**
     * @returns Whether the project is defined.
     */
    isProjectDefined(): boolean {
      return this.projectId !== """";
    },
    /**
     * @returns Whether the version is defined.
     */
    isVersionDefined(): boolean {
      return this.versionId !== """";
    },
    /**
     * @return Returns the version ID, and logs an error if there isn't one.
     */
    versionIdWithLog(): string {
      if (!this.versionId) {
        logStore.onWarning(""Please select a project version."");
      }

      return this.versionId;
    },
    /**
     * @return The current project's models.
     */
    models(): GenerationModelSchema[] {
      return this.project.models;
    },
  },
  actions: {
    /**
     * Updates the current project.
     *
     * @param project - The new project fields.
     */
    updateProject(project: Partial<ProjectSchema>): void {
      this.project = {
        ...this.project,
        ...project,
      };
    },
    /**
     * Initializes the current project.
     */
    initializeProject(project: ProjectSchema): void {
      this.project = project;

      selectionStore.clearSelections();
      membersStore.initializeProject(project);
      timStore.initializeProject(project);
      documentStore.initializeProject(project);
      subtreeStore.initializeProject(project);
      attributesStore.initializeProject(project);
      warningStore.artifactWarnings = project.warnings;
    },
  },
});

export default useProject(pinia);
"
src/hooks/project/useAttributes.ts,"import { defineStore } from ""pinia"";

import { AttributeLayoutSchema, AttributeSchema, ProjectSchema } from ""@/types"";
import { removeMatches } from ""@/util"";
import { projectStore } from ""@/hooks"";
import { pinia } from ""@/plugins"";

/**
 * This module defines the state of artifact attributes and their layouts.
 */
export const useAttributes = defineStore(""attributes"", {
  state: () => ({
    /**
     * A list of custom attributes used on this project.
     */
    attributes: [] as AttributeSchema[],
    /**
     * Layouts for displaying this project's custom attributes.
     */
    attributeLayouts: [] as AttributeLayoutSchema[],
    /**
     * The id of the current layout selected for editing.
     */
    selectedLayoutId: """",
  }),
  getters: {
    /**
     * The first layout with empty artifact types will be used as the default for all artifacts.
     *
     * @return The default layout for artifact attributes.
     */
    defaultLayout(): AttributeLayoutSchema | undefined {
      return this.attributeLayouts.find(
        ({ artifactTypes }) => artifactTypes.length === 0
      );
    },
  },
  actions: {
    /**
     * Initializes the current project.
     */
    initializeProject(project: ProjectSchema): void {
      this.attributes = project.attributes || [];
      this.attributeLayouts = project.attributeLayouts || [];
      this.selectedLayoutId = project.attributeLayouts?.[0]?.id || """";
    },

    /**
     * Updates the stored custom attributes.
     *
     * @param updatedAttributes - The updated attributes.
     */
    updateAttributes(updatedAttributes: AttributeSchema[]): void {
      const ids = updatedAttributes.map(({ key }) => key);

      this.attributes = [
        ...removeMatches(this.attributes, ""key"", ids),
        ...updatedAttributes,
      ];

      projectStore.project.attributes = this.attributes;
    },
    /**
     * Deletes from the stored custom attributes.
     *
     * @param deletedAttributes - The keys of attributes to delete.
     */
    deleteAttributes(deletedAttributes: string[]): void {
      this.attributes = removeMatches(
        this.attributes,
        ""key"",
        deletedAttributes
      );

      projectStore.project.attributes = this.attributes;
    },

    /**
     * Updates the stored custom attribute layouts.
     *
     * @param updatedLayouts - The updated layouts.
     */
    updateAttributeLayouts(updatedLayouts: AttributeLayoutSchema[]): void {
      const ids = updatedLayouts.map(({ id }) => id);

      this.attributeLayouts = [
        ...removeMatches(this.attributeLayouts, ""id"", ids),
        ...updatedLayouts,
      ];

      projectStore.project.attributeLayouts = this.attributeLayouts;
    },
    /**
     * Deletes from the stored custom attribute layouts.
     *
     * @param deletedLayouts - The ids of layouts to delete.
     */
    deleteAttributeLayouts(deletedLayouts: string[]): void {
      this.attributeLayouts = removeMatches(
        this.attributeLayouts,
        ""id"",
        deletedLayouts
      );

      projectStore.project.attributeLayouts = this.attributeLayouts;
    },
    /**
     * Returns the attribute grid layout for the given artifact type.
     *
     * @param type - The type to find.
     * @return The attribute layout.
     */
    getLayoutByType(type: string): AttributeLayoutSchema | undefined {
      return (
        this.attributeLayouts.find(({ artifactTypes }) =>
          artifactTypes.includes(type)
        ) || this.defaultLayout
      );
    },
    /**
     * Adds or updates an attribute.
     * @param attribute - The attribute to add.
     */
    updateAttribute(attribute: AttributeSchema): void {
      const existingIndex = this.attributes.findIndex(
        ({ key }) => key === attribute.key
      );

      if (existingIndex === -1) {
        this.attributes.push(attribute);
      } else {
        this.attributes.splice(existingIndex, 1, attribute);
      }
    },
    /**
     * Deletes an attribute.
     * @param attribute - The attribute to delete.
     */
    deleteAttribute(attribute: AttributeSchema): void {
      this.attributes = this.attributes.filter(
        ({ key }) => key !== attribute.key
      );
    },
    /**
     * Adds or updates an attribute layout.
     * @param layout - The attribute layout to add.
     */
    updateLayout(layout: AttributeLayoutSchema): void {
      const existingIndex = this.attributeLayouts.findIndex(
        ({ id }) => id === layout.id
      );

      if (existingIndex === -1) {
        this.attributeLayouts.push(layout);
      } else {
        this.attributeLayouts.splice(existingIndex, 1, layout);
      }
    },
    /**
     * Deletes an attribute layout.
     * @param layout - The attribute layout to delete.
     */
    deleteLayout(layout: AttributeLayoutSchema): void {
      this.attributeLayouts = this.attributeLayouts.filter(
        ({ id }) => id !== layout.id
      );

      if (this.selectedLayoutId !== layout.id) return;

      this.selectedLayoutId = this.attributeLayouts[0]?.id || """";
    },
  },
});

export default useAttributes(pinia);
"
src/hooks/project/useTraceApproval.ts,"import { defineStore } from ""pinia"";

import {
  ApprovalType,
  FlatTraceLink,
  GeneratedLinksSchema,
  TraceLinkSchema,
} from ""@/types"";
import { pinia } from ""@/plugins"";

/**
 * A module for managing generated trace link approval.
 */
export const useTraceApproval = defineStore(""traceApproval"", {
  state: () => ({
    /**
     * All generated links.
     */
    traceLinks: [] as FlatTraceLink[],
    /**
     * Approved generated link ids.
     */
    approvedIds: [] as string[],
    /**
     * Declined generated link ids.
     */
    declinedIds: [] as string[],
    /**
     * Expanded generated link ids.
     */
    expandedIds: [] as string[],
  }),
  getters: {
    /**
     * @return All unreviewed links.
     */
    unreviewedLinks(): FlatTraceLink[] {
      return this.traceLinks.filter(
        ({ approvalStatus }) => approvalStatus === ApprovalType.UNREVIEWED
      );
    },
  },
  actions: {
    /**
     * Initializes the state of generated traces.
     *
     * @param generated - The generated links and their states.
     */
    initializeTraces(generated: GeneratedLinksSchema) {
      this.expandedIds = [];
      this.$patch(generated);
    },
    /**
     * Updates the status of a flat link.
     *
     * @param traceLink - The link to update.
     * @param status - The status to update to.
     */
    updateLinkStatus(traceLink: TraceLinkSchema, status: ApprovalType): void {
      const flatLink = this.traceLinks.find(
        ({ traceLinkId }) => traceLinkId === traceLink.traceLinkId
      );

      if (!flatLink) return;

      flatLink.approvalStatus = status;
    },
    /**
     * Deselects a link.
     *
     * @param traceLinkId - The link id to deselect.
     */
    deselectLink(traceLinkId: string) {
      this.expandedIds = this.expandedIds.filter((id) => id !== traceLinkId);
    },
    /**
     * Updates the stored links with a new approved status.
     *
     * @param traceLink - The link to approve.
     */
    approveLink(traceLink: TraceLinkSchema): void {
      this.declinedIds = this.declinedIds.filter(
        (declinedId) => declinedId != traceLink.traceLinkId
      );
      this.approvedIds = [...this.approvedIds, traceLink.traceLinkId];
      this.deselectLink(traceLink.traceLinkId);
      this.updateLinkStatus(traceLink, ApprovalType.APPROVED);
    },
    /**
     * Updates the stored links with a new declined status.
     *
     * @param traceLink - The link to decline.
     */
    declineLink(traceLink: TraceLinkSchema): void {
      this.approvedIds = this.approvedIds.filter(
        (approvedId) => approvedId != traceLink.traceLinkId
      );
      this.declinedIds = [...this.declinedIds, traceLink.traceLinkId];
      this.deselectLink(traceLink.traceLinkId);
      this.updateLinkStatus(traceLink, ApprovalType.DECLINED);
    },
    /**
     * Updates the stored links with a new un-reviewed status.
     *
     * @param traceLink - The link to reset.
     */
    resetLink(traceLink: TraceLinkSchema): void {
      this.approvedIds = this.approvedIds.filter(
        (approvedId) => approvedId != traceLink.traceLinkId
      );
      this.declinedIds = this.declinedIds.filter(
        (declinedId) => declinedId != traceLink.traceLinkId
      );
      this.deselectLink(traceLink.traceLinkId);
      this.updateLinkStatus(traceLink, ApprovalType.UNREVIEWED);
    },
    /**
     * Expands all matching links.
     * @param filter - The filter to select which links to expand.
     */
    expandLinks(filter: (traceLink: FlatTraceLink) => boolean): void {
      this.expandedIds = this.traceLinks
        .filter(filter)
        .map((link) => link.traceLinkId);
    },
    /**
     * Collapses all matching links.
     * @param filter - The filter to select which links to preserve.
     */
    collapseLinks(filter: (traceLink: FlatTraceLink) => boolean): void {
      this.expandedIds = this.traceLinks
        .filter(
          (link) => this.expandedIds.includes(link.traceLinkId) && filter(link)
        )
        .map((link) => link.traceLinkId);
    },
  },
});

export default useTraceApproval(pinia);
"
src/hooks/project/useWarnings.ts,"import { defineStore } from ""pinia"";

import { WarningCollectionSchema } from ""@/types"";
import { pinia } from ""@/plugins"";

/**
 * This module defines the state of warnings generated for
 * artifacts in this version.
 */
export const useWarnings = defineStore(""warnings"", {
  state: () => ({
    /**
     * A collection of warnings keyed by the associated artifact.
     */
    artifactWarnings: {} as WarningCollectionSchema,
  }),
  getters: {},
  actions: {
    /**
     * Returns all warnings for the given artifacts.
     *
     * @param artifactIds - The ids of artifacts to get warnings for.
     * @return All warnings.
     */
    getArtifactWarnings(artifactIds: string[]) {
      return artifactIds
        .map((id) => this.artifactWarnings[id] || [])
        .reduce((acc, cur) => [...acc, ...cur], []);
    },
  },
});

export default useWarnings(pinia);
"
src/hooks/project/useTIM.ts,"import { defineStore } from ""pinia"";

import {
  ArtifactCytoElementData,
  ArtifactSchema,
  ArtifactTypeSchema,
  ProjectSchema,
  SafetyCaseType,
  TraceMatrixSchema,
} from ""@/types"";
import {
  convertTypeToColor,
  DefaultTypeIcon,
  isLinkAllowedByType,
  removeMatches,
  sanitizeNodeId,
} from ""@/util"";
import { pinia } from ""@/plugins"";
import projectStore from ""@/hooks/project/useProject"";

/**
 * This store manages the state of project TIM data,
 * including artifact types and trace matrices.
 */
export const useTIM = defineStore(""tim"", {
  state: () => ({
    /**
     * The artifact types in the project.
     */
    artifactTypes: [] as ArtifactTypeSchema[],
    /**
     * The trace matrices in the project.
     */
    traceMatrices: [] as TraceMatrixSchema[],
  }),
  getters: {
    /**
     * @returns all type names of artifacts.
     */
    typeNames(): string[] {
      const safetyCaseTypes = Object.values(SafetyCaseType) as string[];

      return this.artifactTypes
        .map(({ name }) => name)
        .filter((name) => !safetyCaseTypes.includes(name));
    },
  },
  actions: {
    /**
     * Initializes project data.
     *
     * @param project - The project to load.
     */
    initializeProject(project: ProjectSchema): void {
      this.artifactTypes = project.artifactTypes;
      this.traceMatrices = project.traceMatrices;
    },
    /**
     * Adds new artifact types.
     *
     * @param artifactTypes - The artifact types to add.
     */
    addOrUpdateArtifactTypes(artifactTypes: ArtifactTypeSchema[]): void {
      const ids = artifactTypes.map(({ name }) => name);
      const updatedArtifactTypes = [
        ...removeMatches(this.artifactTypes, ""name"", ids),
        ...artifactTypes,
      ];

      this.artifactTypes = updatedArtifactTypes;
      projectStore.updateProject({ artifactTypes: updatedArtifactTypes });
    },
    /**
     * Adds a new placeholder artifact type if it does not yet exist.
     *
     * @param newArtifacts - The artifact to add types from.
     */
    addTypesFromArtifacts(newArtifacts: ArtifactSchema[]): void {
      newArtifacts.forEach(({ type }) => {
        if (this.artifactTypes.find(({ name }) => name === type)) return;

        this.artifactTypes = [
          ...this.artifactTypes,
          {
            typeId: """",
            name: type,
            icon: DefaultTypeIcon,
            color: ""base"",
            count: 1,
          },
        ];
      });
    },
    /**
     * Removes artifact types.
     *
     * @param removedTypeIds - The artifact type ids to remove.
     */
    deleteArtifactTypes(removedTypeIds: string[]): void {
      const preservedArtifactTypes = removeMatches(
        this.artifactTypes,
        ""typeId"",
        removedTypeIds
      );

      this.artifactTypes = preservedArtifactTypes;
      projectStore.updateProject({ artifactTypes: preservedArtifactTypes });
    },
    /**
     * Adds new trace matrices.
     *
     * @param traceMatrices - The trace matrices to add.
     */
    addOrUpdateTraceMatrices(traceMatrices: TraceMatrixSchema[]): void {
      const ids = traceMatrices.map(({ id }) => id);
      const updatedTraceMatrices = [
        ...removeMatches(this.traceMatrices, ""id"", ids),
        ...traceMatrices,
      ];

      this.traceMatrices = updatedTraceMatrices;
      projectStore.updateProject({ traceMatrices: updatedTraceMatrices });
    },
    /**
     * Adds a placeholder trace matrix between these types.
     * @param sourceType - The source type.
     * @param targetType - The target type.
     */
    addTraceMatrix(sourceType: string, targetType: string): void {
      this.addOrUpdateTraceMatrices([
        {
          id: """",
          sourceType,
          targetType,
          count: 1,
          generatedCount: 0,
          approvedCount: 0,
        },
      ]);
    },
    /**
     * Removes trace matrices.
     *
     * @param removedMatrixIds - The trace matrix ids to remove.
     */
    deleteTraceMatrices(removedMatrixIds: string[]): void {
      const preservedTraceMatrices = removeMatches(
        this.traceMatrices,
        ""id"",
        removedMatrixIds
      );

      this.traceMatrices = preservedTraceMatrices;
      projectStore.updateProject({ traceMatrices: preservedTraceMatrices });
    },
    /**
     * Removes a trace matrix between these types.
     *
     * @param sourceType - The source type.
     * @param targetType - The target type.
     */
    deleteTraceMatrix(sourceType: string, targetType: string): void {
      this.traceMatrices = this.traceMatrices.filter(
        (matrix) =>
          matrix.sourceType !== sourceType || matrix.targetType !== targetType
      );
    },
    /**
     * Gets the artifact type with the given name.
     *
     * @param name - The name of the artifact type to get.
     * @returns The artifact type with the given name, or undefined if it does not exist.
     */
    getType(name: string): ArtifactTypeSchema | undefined {
      return this.artifactTypes.find((type) => type.name === name);
    },
    /**
     * TODO: This is a placeholder for when we use the type id as the reference, instead of the name.
     * Returns the display name for a given artifact type.
     *
     * @param name - The name of the artifact type to get the display name
     * @returns An icon id to display for the type.
     */
    getTypeName(name: string): string {
      return name;
    },
    /**
     * Returns the color code for a given artifact type.
     *
     * @param name - The name of the artifact type to get the color of.
     * @param dontConvert - If true, the color will not be converted to a hex code.
     * @returns A color code to display for the type.
     */
    getTypeColor(name: string, dontConvert?: boolean): string {
      const artifactType = this.getType(name);

      return dontConvert
        ? artifactType?.color || ""primary""
        : convertTypeToColor(artifactType?.color || """");
    },
    /**
     * Returns the icon id for a given artifact type.
     *
     * @param name - The name of the artifact type to get the icon of.
     * @returns An icon id to display for the type.
     */
    getTypeIcon(name: string): string {
      const artifactType = this.getType(name);

      return artifactType?.icon.includes(""help"")
        ? DefaultTypeIcon
        : artifactType?.icon || DefaultTypeIcon;
    },
    /**
     * Gets the trace matrix with the given source and target types.
     *
     * @param sourceName - The source artifact type name.
     * @param targetName - The target artifact type name.
     * @returns The matching trace matrix, or undefined if it does not exist.
     */
    getMatrix(
      sourceName: string,
      targetName: string
    ): TraceMatrixSchema | undefined {
      return this.traceMatrices.find(
        ({ sourceType, targetType }) =>
          sanitizeNodeId(sourceType) === sourceName &&
          sanitizeNodeId(targetType) === targetName
      );
    },
    /**
     * Gets all trace matrices that are a parent of the given one.
     *
     * @param sourceName - The source artifact type name.
     * @returns All  artifact types that are a parent to this type.
     */
    getParentMatrices(sourceName: string): ArtifactTypeSchema[] {
      return this.traceMatrices
        .filter(({ sourceType }) => sourceType === sourceName)
        .map(({ targetType }) => this.getType(targetType))
        .filter((type) => type !== undefined) as ArtifactTypeSchema[];
    },
    /**
     * Gets all trace matrices that are a child of the given one.
     *
     * @param targetName - The target artifact type name.
     * @returns All artifact types that are a child to this type.
     */
    getChildMatrices(targetName: string): ArtifactTypeSchema[] {
      return this.traceMatrices
        .filter(({ targetType }) => targetType === targetName)
        .map(({ sourceType }) => this.getType(sourceType))
        .filter((type) => type !== undefined) as ArtifactTypeSchema[];
    },
    /**
     * Determines if the trace link is allowed based on the type of the nodes.
     *
     * @param source - The source artifact.
     * @param target - The target artifact.
     * @return Whether the link is allowed.
     */
    canBeTraced(
      source: ArtifactSchema | ArtifactCytoElementData,
      target: ArtifactSchema | ArtifactCytoElementData
    ): boolean {
      return isLinkAllowedByType(source, target, this.traceMatrices);
    },
  },
});

export default useTIM(pinia);
"
src/hooks/project/useDocuments.ts,"import { defineStore } from ""pinia"";

import {
  LayoutPositionsSchema,
  DocumentSchema,
  DocumentType,
  ProjectSchema,
  GraphMode,
  ArtifactSchema,
} from ""@/types"";
import {
  createDocument,
  DEFAULT_VIEW_NAME,
  isTableDocument,
  removeMatches,
} from ""@/util"";
import { subtreeStore } from ""@/hooks"";
import { pinia } from ""@/plugins"";
import layoutStore from ""../graph/useLayout"";
import projectStore from ""./useProject"";
import traceStore from ""./useTraces"";
import artifactStore from ""./useArtifacts"";

/**
 * This module keeps track of the different document views for a project.
 */
export const useDocuments = defineStore(""documents"", {
  state() {
    const baseDocument = createDocument();

    return {
      /**
       * The base document with all artifacts.
       */
      baseDocument,
      /**
       * The currently visible document.
       */
      currentDocument: baseDocument,
      /**
       * All custom project documents.
       */
      allDocuments: [baseDocument],
    };
  },
  getters: {
    /**
     * @return All custom documents & the base document.
     */
    projectDocuments(): DocumentSchema[] {
      return [...this.allDocuments, this.baseDocument];
    },
    /**
     * @return The current document id.
     */
    currentId(): string {
      return this.currentDocument.documentId;
    },
    /**
     * @return The current document type.
     */
    currentType(): DocumentType {
      return this.currentDocument.type;
    },
    /**
     * @return The current artifact ids.
     */
    currentArtifactIds(): string[] {
      return this.currentDocument.artifactIds;
    },
    /**
     * @return Whether the selected document is the base document.
     */
    isBaseDocument(): boolean {
      return this.currentId === """";
    },
    /**
     * @return Whether the current document type is for editing a table.
     */
    isTableOnlyDocument(): boolean {
      return isTableDocument(this.currentDocument.type);
    },
  },
  actions: {
    /**
     * Initializes the current artifacts and traces visible in the current document.
     */
    initializeProject(project: ProjectSchema): void {
      const {
        artifacts,
        traces,
        currentDocumentId = this.currentDocument.documentId,
        documents = [],
        layout,
      } = project;

      const defaultDocument = createDocument({
        name: DEFAULT_VIEW_NAME,
        project,
        artifactIds: artifacts.map(({ id }) => id),
        layout,
      });

      const loadedDocument =
        documents.find(({ documentId }) => documentId === currentDocumentId) ||
        defaultDocument;
      const currentArtifactIds = loadedDocument.artifactIds;

      this.allDocuments = documents;
      this.baseDocument = defaultDocument;
      this.currentDocument = loadedDocument;

      artifactStore.initializeArtifacts({ artifacts, currentArtifactIds });
      traceStore.initializeTraces({ traces, currentArtifactIds });
      layoutStore.updatePositions(loadedDocument.layout);
    },
    /**
     * Updates the given document's layout, and reruns the layout if on the base document.
     * @param documentId - The document to update.
     * @param layout - The new layout to set.
     */
    updateDocumentLayout(
      documentId: string,
      layout: LayoutPositionsSchema
    ): void {
      const document = this.allDocuments.find(
        (document) => documentId === document.documentId
      );

      if (!document) return;

      document.layout = layout;

      if (document.documentId !== this.currentId) return;

      layoutStore.updatePositions(layout);
    },
    /**
     * Updates the base document's layout, and reruns the layout if on the base document.
     * @param layout - The new layout to set.
     */
    updateBaseLayout(layout: LayoutPositionsSchema): void {
      projectStore.updateProject({ layout });

      this.baseDocument.layout = layout;

      if (!this.isBaseDocument) return;

      layoutStore.updatePositions(layout);
    },
    /**
     * Updates matching documents.
     *
     * @param updatedDocuments - The updated documents.
     */
    async updateDocuments(updatedDocuments: DocumentSchema[]): Promise<void> {
      const updatedIds = updatedDocuments.map((d) => d.documentId);
      const currentDocument = updatedDocuments.find(
        ({ documentId }) => documentId === this.currentId
      );

      if (currentDocument) {
        await this.switchDocuments(currentDocument);
      }

      this.allDocuments = [
        ...removeMatches(this.allDocuments, ""documentId"", updatedIds),
        ...updatedDocuments,
      ];
    },
    /**
     * Sets the current document and initializes its artifacts and traces.
     *
     * @param document - The document to switch to.
     */
    async switchDocuments(document: DocumentSchema): Promise<void> {
      const currentArtifactIds = document.artifactIds;

      this.currentDocument = document;
      artifactStore.initializeArtifacts({ currentArtifactIds });
      traceStore.initializeTraces({ currentArtifactIds });
      layoutStore.updatePositions(document.layout);

      if (isTableDocument(document.type)) {
        layoutStore.mode = GraphMode.table;
      }
    },
    /**
     * Adds a new document.
     *
     * @param document - The document to add.
     */
    async addDocument(document: DocumentSchema): Promise<void> {
      this.allDocuments = [...this.allDocuments, document];

      await this.switchDocuments(document);
    },
    /**
     * Creates and adds a new document based on the neighborhood of an artifact.
     *
     * @param artifact - The artifact to display the neighborhood of.
     */
    async addDocumentOfNeighborhood(
      artifact: Pick<ArtifactSchema, ""name"" | ""id"">
    ): Promise<void> {
      const document = createDocument({
        project: projectStore.projectIdentifier,
        name: artifact.name,
        artifactIds: [
          artifact.id,
          ...subtreeStore.subtreeMap[artifact.id].neighbors,
        ],
      });

      await this.removeDocument("""");
      await this.addDocument(document);
      layoutStore.mode = GraphMode.tree;
    },
    /**
     * Creates and adds a new document for multiple types of artifacts.
     *
     * @param types - The artifact types to include in the document.
     */
    async addDocumentOfTypes(types: string[]): Promise<void> {
      const artifactsByType = artifactStore.allArtifactsByType;
      const document = createDocument({
        project: projectStore.projectIdentifier,
        name: types.join("", ""),
        artifactIds: types
          .map((type) => artifactsByType[type].map(({ id }) => id))
          .reduce((acc, cur) => [...acc, ...cur], []),
      });

      await this.removeDocument("""");
      await this.addDocument(document);
      layoutStore.mode = GraphMode.tree;
    },
    /**
     * Adds artifacts to the current document.
     *
     * @param newIds - The new artifacts to add.
     */
    addDocumentArtifacts(newIds: string[]): void {
      this.currentDocument.artifactIds = [
        ...this.currentDocument.artifactIds.filter(
          (id) => !newIds.includes(id)
        ),
        ...newIds,
      ];
    },
    /**
     * Removes an existing document.
     *
     * @param document - The document, or document id, to delete.
     */
    async removeDocument(document: string | DocumentSchema): Promise<void> {
      const deleteDocumentId =
        typeof document === ""string"" ? document : document.documentId;

      const remainingDocuments = this.allDocuments.filter(
        ({ documentId }) => documentId !== deleteDocumentId
      );

      this.allDocuments = remainingDocuments;

      if (this.currentDocument.documentId !== deleteDocumentId) return;

      await this.switchDocuments(remainingDocuments[0] || this.baseDocument);
    },
    /**
     * Returns whether the given document name already exists.
     *
     * @param name - The name to search for.
     * @return Whether the name exists.
     */
    doesDocumentExist(name: string): boolean {
      return !!this.projectDocuments.find((document) => document.name === name);
    },
  },
});

export default useDocuments(pinia);
"
src/hooks/project/useSubtree.ts,"import { defineStore } from ""pinia"";

import {
  ProjectSchema,
  SubtreeItemSchema,
  SubtreeMapSchema,
  TraceLinkSchema,
} from ""@/types"";
import { getMatchingChildren } from ""@/util"";
import { cyDisplayAll, cySetDisplay } from ""@/cytoscape"";
import { pinia } from ""@/plugins"";
import artifactStore from ""./useArtifacts"";

/**
 * This module keeps track of the tree of artifacts.
 */
export const useSubtree = defineStore(""subtrees"", {
  state: () => ({
    /**
     * A map containing root artifact names as keys and children names are values.
     */
    subtreeMap: {} as SubtreeMapSchema,
    /**
     * List of artifact ids currently hidden within subtrees.
     */
    hiddenSubtreeNodes: [] as string[],
    /**
     * List of artifact ids whose children are currently hidden.
     */
    collapsedParentNodes: [] as string[],
  }),
  getters: {},
  actions: {
    /**
     * Updates the subtree map.
     */
    initializeProject(project: ProjectSchema): void {
      this.subtreeMap = project.subtrees;
    },
    /**
     * Returns the subtree information of an artifact, creating one if none exists.
     *
     * @param artifactId - The artifact to add for.
     *
     */
    getSubtreeItem(artifactId: string): SubtreeItemSchema {
      if (!this.subtreeMap[artifactId]) {
        this.subtreeMap[artifactId] = {
          parents: [],
          children: [],
          subtree: [],
          supertree: [],
          neighbors: [],
        };
      }

      return this.subtreeMap[artifactId];
    },
    /**
     * Returns the subtree of an artifact.
     *
     * @param artifactId - The artifact to get.
     * @return The artifact's subtree.
     */
    getSubtree(artifactId: string): string[] {
      return this.getSubtreeItem(artifactId).subtree;
    },
    /**
     * Returns the parents of an artifact.
     *
     * @param artifactId - The artifact to get.
     * @return The artifact's parents.
     */
    getParents(artifactId: string): string[] {
      return this.getSubtreeItem(artifactId).parents;
    },
    /**
     * Returns the children of an artifact.
     *
     * @param artifactId - The artifact to get.
     * @return The artifact's children.
     */
    getChildren(artifactId: string): string[] {
      return this.getSubtreeItem(artifactId).children;
    },
    /**
     * Returns the relationship between artifacts.
     *
     * @param sourceId - The source artifact's id.
     * @param targetId - The target artifact's id.
     * @return The relationship between these artifacts.
     */
    getRelationship(
      sourceId: string,
      targetId: string
    ): ""parent"" | ""child"" | undefined {
      if (this.getParents(sourceId).includes(targetId)) {
        return ""parent"";
      } else if (this.getChildren(sourceId).includes(targetId)) {
        return ""child"";
      } else {
        return undefined;
      }
    },
    /**
     * Finds the id of all child artifacts that are hidden.
     * If there are hidden child artifacts, the entire number of hidden subtree artifacts will be returned.
     *
     * @param parentId - The parent artifact to search under.
     * @return The ids of all hidden child artifacts.
     */
    getHiddenChildren(parentId: string): string[] {
      const nodeIsHidden = (id: string) => this.hiddenSubtreeNodes.includes(id);

      return this.getChildren(parentId).filter(nodeIsHidden).length > 0
        ? this.getSubtree(parentId).filter(nodeIsHidden)
        : [];
    },
    /**
     * Finds all children of the parent nodes matching the child types.
     *
     * @param parentIds - The artifact ids to search under.
     * @param childTypes - The child artifact types to filter children by.
     * @return The ids of all matching children.
     */
    getMatchingChildren(parentIds: string[], childTypes: string[]): string[] {
      return getMatchingChildren(
        parentIds,
        childTypes,
        (id) => this.getSubtree(id),
        artifactStore.getArtifactById
      );
    },
    /**
     * Updates the subtree of an artifact, creating one if none exists.
     *
     * @param artifactId - The artifact to update.
     * @param getUpdatedSubtree - The subtree changes to update with.
     */
    updateSubtree(
      artifactId: string,
      getUpdatedSubtree: (item: SubtreeItemSchema) => Partial<SubtreeItemSchema>
    ): void {
      const existingSubtree = this.getSubtreeItem(artifactId);

      this.subtreeMap[artifactId] = {
        ...existingSubtree,
        ...getUpdatedSubtree(existingSubtree),
      };
    },
    /**
     * Adds a trace to the subtree.
     * Note: Only updates the source and target subtrees.
     *       Does not update the subtree of all neighbors.
     *
     * @param traceLink - The trace link to add the subtree for.
     */
    addTraceSubtree(traceLink: TraceLinkSchema): void {
      this.updateSubtree(traceLink.sourceId, (subtree) => ({
        parents: [...subtree.parents, traceLink.targetId],
        neighbors: [...subtree.neighbors, traceLink.targetId],
        supertree: [...subtree.supertree, traceLink.targetId],
      }));
      this.updateSubtree(traceLink.targetId, (subtree) => ({
        children: [...subtree.children, traceLink.sourceId],
        neighbors: [...subtree.neighbors, traceLink.sourceId],
        subtree: [...subtree.subtree, traceLink.sourceId],
      }));
    },
    /**
     * Deletes a trace from the subtree.
     * Note: Only updates the source and target subtrees.
     *       Does not update the subtree of all neighbors.
     *
     * @param traceLink - The trace link to delete the subtree for.
     */
    deleteTraceSubtree(traceLink: TraceLinkSchema): void {
      this.updateSubtree(traceLink.sourceId, (subtree) => ({
        parents: subtree.parents.filter((id) => id !== traceLink.targetId),
        neighbors: subtree.neighbors.filter((id) => id !== traceLink.targetId),
        supertree: subtree.supertree.filter((id) => id !== traceLink.targetId),
      }));
      this.updateSubtree(traceLink.targetId, (subtree) => ({
        children: subtree.children.filter((id) => id !== traceLink.sourceId),
        neighbors: subtree.neighbors.filter((id) => id !== traceLink.sourceId),
        subtree: subtree.subtree.filter((id) => id !== traceLink.sourceId),
      }));
    },
    /**
     * Resets all hidden nodes.
     */
    resetHiddenNodes(): void {
      this.collapsedParentNodes = [];
      this.hiddenSubtreeNodes = [];
      cyDisplayAll();
    },
    /**
     * Hides the given artifact's subtree and add replaces child links with
     * phantom links. For any child link leaving a node, a phantom link is added
     * between the target and root node. Similarly, for any linking incoming to a
     * child node, a phantom link is added from the link source to the root node.
     *
     * @param rootId - The Id of the root artifact whose subtree is being hidden.
     */
    async hideSubtree(rootId: string): Promise<void> {
      const childrenInSubtree = this.getSubtree(rootId);
      const visibleChildren = childrenInSubtree.filter(
        (id) => !this.hiddenSubtreeNodes.includes(id)
      );

      this.$patch({
        hiddenSubtreeNodes: [...this.hiddenSubtreeNodes, ...visibleChildren],
        collapsedParentNodes: [...this.collapsedParentNodes, rootId],
      });

      cySetDisplay(visibleChildren, false);
    },
    /**
     * Un-hides the given artifact's subtree if hidden.
     *
     * @param rootId - The Id of artifact whose subtree showed by un-hidden.
     */
    async showSubtree(rootId: string): Promise<void> {
      const subtreeNodes = this.getSubtree(rootId);
      const hiddenSubtreeNodes = this.hiddenSubtreeNodes.filter(
        (id) => !subtreeNodes.includes(id)
      );

      this.$patch({
        hiddenSubtreeNodes,
        collapsedParentNodes: this.collapsedParentNodes.filter(
          (id) => id !== rootId
        ),
      });

      cySetDisplay(subtreeNodes, true);
    },
    /**
     * Temporarily removes all hidden nodes, runs the callback, then restores the hidden nodes.
     *
     * @param cb - The callback run in between.
     */
    async restoreHiddenNodesAfter(cb: () => Promise<void>): Promise<void> {
      const collapsedParents = this.collapsedParentNodes;

      await this.resetHiddenNodes();
      await cb();

      for (const id of collapsedParents) {
        if (this.hiddenSubtreeNodes.includes(id)) continue;

        await this.hideSubtree(id);
      }
    },
  },
});

export default useSubtree(pinia);
"
src/hooks/project/useSearch.ts,"import { defineStore } from ""pinia"";

import {
  ArtifactSchema,
  GenerationModelSchema,
  SearchMode,
  SearchQuerySchema,
} from ""@/types"";
import { searchModeOptions } from ""@/util"";
import { pinia } from ""@/plugins"";

/**
 * This module defines the state of the project searchbar.
 */
export const useSearch = defineStore(""search"", {
  state: () => ({
    /**
     * The type of information to predict traces to.
     */
    mode: searchModeOptions()[2],
    /**
     * The selected search items, used as the search artifacts and types.
     */
    searchItems: null as ArtifactSchema[] | string[] | null,
    /**
     * The inputted search text, used as the search prompt.
     */
    searchText: """",
    /**
     * What type(s) of artifacts to predict links from the search artifacts to.
     */
    searchTypes: [] as string[],
    /**
     * The generation model to use for the search.
     */
    searchModel: undefined as GenerationModelSchema | undefined,
    /**
     * How many of the top predictions to include.
     */
    maxResults: 5,
    /**
     * What other type(s) of artifacts should I import.
     */
    relatedTypes: [] as string[],
  }),
  getters: {
    /**
     * Whether the search mode searches for artifacts.
     */
    artifactLikeMode(): boolean {
      return !!this.mode.artifactSearch;
    },
    /**
     * Whether the search mode searches for artifact types.
     */
    artifactTypeMode(): boolean {
      return this.mode.id === SearchMode.artifactTypes;
    },
    /**
     * Whether the search mode is basic search.
     */
    basicSearchMode(): boolean {
      return this.mode.id === SearchMode.search;
    },
    /**
     * The number of search items selected.
     */
    selectionCount(): number {
      return this.searchItems?.length || 0;
    },
    /**
     * The ids of selected artifacts or types.
     */
    selectionIds(): string[] {
      return (
        this.searchItems?.map((item) =>
          typeof item === ""object"" ? item.id : item || """"
        ) || []
      );
    },
    /**
     * Builds the search query based on entered information.
     */
    searchQuery(): SearchQuerySchema {
      const searchQuery: SearchQuerySchema = {
        mode: this.mode.id,
        searchTypes: this.searchTypes,
        maxResults: this.maxResults,
        relatedTypes: this.relatedTypes,
        model: this.searchModel?.id,
      };

      if (this.mode.id === SearchMode.prompt) {
        searchQuery.prompt = this.searchText;
      } else if (this.mode.id === SearchMode.artifacts) {
        searchQuery.artifactIds = this.selectionIds;
      } else {
        searchQuery.artifactTypes = this.selectionIds;
      }

      return searchQuery;
    },
  },
  actions: {
    /**
     * Clears the search inputs.
     */
    clearSearch(): void {
      this.searchItems = [];
      this.searchText = """";
      this.searchTypes = [];
      this.relatedTypes = [];
    },
  },
});

export default useSearch(pinia);
"
src/hooks/project/useIntegrations.ts,"import { defineStore } from ""pinia"";

import {
  GitHubImportSchema,
  GitHubOrganizationSchema,
  GitHubProjectSchema,
  JiraOrganizationSchema,
  JiraProjectSchema,
} from ""@/types"";
import { pinia } from ""@/plugins"";

/**
 * This module defines the state of 3rd party integrations.
 */
export const useIntegrations = defineStore(""integrations"", {
  state: () => ({
    /**
     * Whether this user is connected to Jira.
     */
    validJiraCredentials: false,
    /**
     * A selected Jira installation to import from.
     */
    jiraOrganization: undefined as JiraOrganizationSchema | undefined,
    /**
     * A selected Jira project to import.
     */
    jiraProject: undefined as JiraProjectSchema | undefined,
    /**
     * Whether this user is connected to GitHub.
     */
    validGitHubCredentials: false,
    /**
     * A selected GitHub installation to import from.
     */
    gitHubOrganization: undefined as GitHubOrganizationSchema | undefined,
    /**
     * A selected GitHub project to import.
     */
    gitHubProject: undefined as GitHubProjectSchema | undefined,
    /**
     * The configuration for the GitHub import.
     */
    gitHubConfig: {} as GitHubImportSchema,
  }),
  getters: {},
  actions: {
    /**
     * Selects a Jira organization.
     *
     * @param organization - The organization to select.
     */
    selectJiraOrganization(
      organization: JiraOrganizationSchema | undefined
    ): void {
      if (
        !this.jiraOrganization ||
        this.jiraOrganization?.id !== organization?.id
      ) {
        this.jiraOrganization = organization;
      } else {
        this.jiraOrganization = undefined;
      }
    },
    /**
     * Selects a Jira project.
     *
     * @param project - The project to select.
     */
    selectJiraProject(project: JiraProjectSchema | undefined): void {
      if (!this.jiraProject || this.jiraProject?.id !== project?.id) {
        this.jiraProject = project;
      } else {
        this.jiraProject = undefined;
      }
    },
    /**
     * Selects a GitHub organization.
     *
     * @param organization - The organization to select.
     */
    selectGitHubOrganization(
      organization: GitHubOrganizationSchema | undefined
    ): void {
      if (
        !this.gitHubOrganization ||
        this.gitHubOrganization?.id !== organization?.id
      ) {
        this.gitHubOrganization = organization;
      } else {
        this.gitHubOrganization = undefined;
      }
    },
    /**
     * Selects a GitHub project.
     *
     * @param project - The project to select.
     */
    selectGitHubProject(project: GitHubProjectSchema | undefined): void {
      this.gitHubConfig = {};

      if (!this.gitHubProject || this.gitHubProject?.id !== project?.id) {
        this.gitHubProject = project;
      } else {
        this.gitHubProject = undefined;
      }
    },
  },
});

export default useIntegrations(pinia);
"
src/hooks/project/index.ts,"export { default as jobStore } from ""./useJobs"";
export { default as timStore } from ""./useTIM"";
export { default as artifactStore } from ""./useArtifacts"";
export { default as traceStore } from ""./useTraces"";
export { default as warningStore } from ""./useWarnings"";
export { default as documentStore } from ""./useDocuments"";
export { default as commitStore } from ""./useCommits"";
export { default as subtreeStore } from ""./useSubtree"";
export { default as projectStore } from ""./useProject"";
export { default as deltaStore } from ""./useDelta"";
export { default as approvalStore } from ""./useTraceApproval"";
export { default as integrationsStore } from ""./useIntegrations"";
export { default as attributesStore } from ""./useAttributes"";
export { default as membersStore } from ""./useMembers"";
export { default as searchStore } from ""./useSearch"";
"
src/hooks/project/useCommits.ts,"import { defineStore } from ""pinia"";

import {
  ArtifactSchema,
  CommitSchema,
  CommitHistory,
  TraceLinkSchema,
} from ""@/types"";
import { createCommit } from ""@/util"";
import { pinia } from ""@/plugins"";
import traceStore from ""./useTraces"";
import artifactStore from ""./useArtifacts"";

/**
 * This module tracks commits and allows for undoing them.
 */
export const useCommits = defineStore(""commits"", {
  state: () => ({
    /**
     * The ordered tuples of commits that have occurred
     * during the current session.
     */
    commits: [] as CommitHistory[],
    /**
     * The list of recently reverted commits.
     */
    revertedCommits: [] as CommitHistory[],
  }),
  getters: {
    /**
     * @return True if at least one commit exists.
     */
    canUndo(): boolean {
      return this.commits.length > 0;
    },
    /**
     * @return True if at least one commit has been reverted.
     */
    canRedo(): boolean {
      return this.revertedCommits.length > 0;
    },
  },
  actions: {
    /**
     * Given a commit, all added entities are deleted, all deleted entities are
     * re-added, and modified entities are reverted to their state before the last
     * client change.
     *
     * @param commit - The commit to create a reversion for.
     * @return The reversion commit.
     */
    getRevert(commit: CommitSchema): CommitSchema {
      return {
        ...createCommit(commit.commitVersion),
        artifacts: {
          added: commit.artifacts.removed,
          removed: commit.artifacts.added,
          modified: commit.artifacts.modified
            .map(({ id }) => artifactStore.getArtifactById(id))
            .filter((artifact) => !!artifact) as ArtifactSchema[],
        },
        traces: {
          added: commit.traces.removed,
          removed: commit.traces.added,
          modified: commit.traces.modified
            .map((link) =>
              traceStore.getTraceLinkByArtifacts(link.sourceId, link.targetId)
            )
            .filter((link) => !!link) as TraceLinkSchema[],
        },
      };
    },
    /**
     * Saves commit to the application store.
     *
     * @param commit - The commit to save.
     */
    saveCommit(commit: CommitSchema): void {
      this.$patch({
        commits: [...this.commits, { commit, revert: this.getRevert(commit) }],
        revertedCommits: [],
      });
    },
    /**
     * Removes the last commit from the store and attempts to revert the changes.
     * If successful, the commit is stored in previously reverted commits.
     *
     * @return The undone commit.
     */
    undoLastCommit(): CommitSchema | undefined {
      if (!this.canUndo) return;

      const lastCommitIndex = this.commits.length - 1;
      const lastCommitHistory = this.commits[lastCommitIndex];

      this.$patch({
        commits: this.commits.filter((c, idx) => idx !== lastCommitIndex),
        revertedCommits: [...this.revertedCommits, lastCommitHistory],
      });

      return lastCommitHistory.revert;
    },
    /**
     * Removes and returns the last reverted commit.
     *
     * @return The redone commit.
     */
    redoLastUndoneCommit(): CommitSchema | undefined {
      if (!this.canRedo) return;

      const lastCommitIndex = this.revertedCommits.length - 1;
      const lastCommitHistory = this.revertedCommits[lastCommitIndex];

      this.$patch({
        commits: [...this.commits, lastCommitHistory],
        revertedCommits: this.revertedCommits.filter(
          (c, idx) => idx !== lastCommitIndex
        ),
      });

      return lastCommitHistory.commit;
    },
  },
});

export default useCommits(pinia);
"
src/hooks/project/useMembers.ts,"import { defineStore } from ""pinia"";

import { MembershipSchema, ProjectSchema } from ""@/types"";
import { removeMatches } from ""@/util"";
import { pinia } from ""@/plugins"";
import projectStore from ""./useProject"";

/**
 * This module defines the state of the current project's members.
 */
export const useMembers = defineStore(""members"", {
  state: () => ({
    /**
     * List of members and their roles in the project.
     */
    members: [] as MembershipSchema[],
  }),
  getters: {},
  actions: {
    /**
     * Initializes the current project.
     */
    initializeProject(project: ProjectSchema): void {
      this.members = project.members;
    },
    /**
     * Updates the current project members.
     *
     * @param updatedMembers - The updated members.
     */
    updateMembers(updatedMembers: MembershipSchema[]): void {
      const ids = updatedMembers.map((member) => member.projectMembershipId);

      this.members = [
        ...removeMatches(this.members, ""projectMembershipId"", ids),
        ...updatedMembers,
      ];

      projectStore.project.members = this.members;
    },
    /**
     * Deletes from the current project members.
     *
     * @param deletedMembers - The member ids to delete.
     */
    deleteMembers(deletedMembers: string[]): void {
      this.members = removeMatches(
        this.members,
        ""projectMembershipId"",
        deletedMembers
      );

      projectStore.project.members = this.members;
    },
  },
});

export default useMembers(pinia);
"
src/hooks/project/useTraces.ts,"import { defineStore } from ""pinia"";

import {
  ApprovalType,
  ArtifactCytoElementData,
  ArtifactSchema,
  DocumentTraces,
  TraceLinkSchema,
  TraceType,
} from ""@/types"";
import { matchTrace, removeMatches, standardizeValueArray } from ""@/util"";
import { timStore } from ""@/hooks"";
import { pinia } from ""@/plugins"";
import documentStore from ""@/hooks/project/useDocuments"";
import layoutStore from ""@/hooks/graph/useLayout"";
import projectStore from ""@/hooks/project/useProject"";

/**
 * This module defines the state of the current project's trace links.
 */
export const useTraces = defineStore(""traces"", {
  state: () => ({
    /**
     * All trace links in the project.
     */
    allTraces: [] as TraceLinkSchema[],
    /**
     * The visible trace links.
     */
    currentTraces: [] as TraceLinkSchema[],
  }),
  getters: {
    /**
     * @return All visible trace links.
     */
    visibleTraces(): TraceLinkSchema[] {
      return this.currentTraces.filter(
        (t) => t.approvalStatus != ApprovalType.DECLINED
      );
    },
  },
  actions: {
    /**
     * Initializes the trace links visible in the current document.
     */
    initializeTraces(documentTraces: DocumentTraces): void {
      const { traces = this.allTraces, currentArtifactIds } = documentTraces;

      this.$patch({
        allTraces: traces,
        currentTraces: currentArtifactIds
          ? traces.filter(
              ({ sourceId, targetId }) =>
                currentArtifactIds.includes(sourceId) &&
                currentArtifactIds.includes(targetId)
            )
          : traces,
      });
    },
    /**
     * Updates the current trace links in the project, preserving any that already existed.
     *
     * @param newTraces - The trace links to add.
     */
    addOrUpdateTraceLinks(newTraces: TraceLinkSchema[]): void {
      const newIds = newTraces.map(({ traceLinkId }) => traceLinkId);
      const updatedTraces = [
        ...removeMatches(this.allTraces, ""traceLinkId"", newIds),
        ...newTraces,
      ];

      this.initializeTraces({
        traces: updatedTraces,
        currentArtifactIds: documentStore.currentDocument.artifactIds,
      });
      projectStore.updateProject({ traces: updatedTraces });
      layoutStore.applyAutomove();
    },
    /**
     * Deletes the given trace links.
     *
     * @param deletedTraces - The trace links, or ids, to remove.
     */
    deleteTraceLinks(deletedTraces: TraceLinkSchema[] | string[]): void {
      if (deletedTraces.length === 0) return;

      const ids = standardizeValueArray(deletedTraces, ""traceLinkId"");
      const allTraces = removeMatches(this.allTraces, ""traceLinkId"", ids);

      this.$patch({
        allTraces,
        currentTraces: removeMatches(this.currentTraces, ""traceLinkId"", ids),
      });
      projectStore.updateProject({ traces: allTraces });
      layoutStore.applyAutomove();
    },
    /**
     * Returns the trace link that matches an id.
     *
     * @param id - The trace link id.
     * @return The trace link, if one exists.
     */
    getTraceLinkById(id: string): TraceLinkSchema | undefined {
      return this.allTraces.find(({ traceLinkId }) => traceLinkId === id);
    },
    /**
     * Returns the trace link between artifacts.
     *
     * @param sourceId - The source artifact id.
     * @param targetId - The target artifact id.
     * @param ignoreDirection - If true, will match traces in both directions.
     * @return The trace link between artifacts, if one exists.
     */
    getTraceLinkByArtifacts(
      sourceId: string,
      targetId: string,
      ignoreDirection = false
    ): TraceLinkSchema | undefined {
      return this.allTraces.find(
        matchTrace(sourceId, targetId, ignoreDirection)
      );
    },
    /**
     * Returns the trace link between sets of artifacts.
     *
     * @param sources - The source artifacts.
     * @param targets - The target artifacts.
     * @param filters - Whether to additionally filter by manual or approved links.
     * @return All trace links from source to target artifacts.
     */
    getTraceLinksByArtifactSets(
      sources: ArtifactSchema[],
      targets: ArtifactSchema[],
      filters: (""manual"" | ""approved"")[] = []
    ): TraceLinkSchema[] {
      const linksBetweenSets = this.allTraces.filter(
        ({ sourceId, targetId }) =>
          !!sources.find(({ id }) => id === sourceId) &&
          !!targets.find(({ id }) => id === targetId)
      );

      if (filters.includes(""manual"") && filters.includes(""approved"")) {
        return linksBetweenSets.filter(
          ({ approvalStatus }) => approvalStatus === ApprovalType.APPROVED
        );
      } else if (filters.includes(""manual"")) {
        return linksBetweenSets.filter(
          ({ traceType }) => traceType === TraceType.MANUAL
        );
      } else if (filters.includes(""approved"")) {
        return linksBetweenSets.filter(
          ({ traceType, approvalStatus }) =>
            traceType === TraceType.GENERATED &&
            approvalStatus === ApprovalType.APPROVED
        );
      } else {
        return linksBetweenSets;
      }
    },
    /**
     * Returns whether the link exists.
     *
     * @param sourceId - The source artifact id.
     * @param targetId - The target artifact id.
     * @return Whether a link exists.
     */
    doesLinkExist(sourceId: string, targetId: string): boolean {
      return !!this.allTraces.find(matchTrace(sourceId, targetId, true));
    },
    /**
     * Returns whether the link is allowed.
     *
     * @param source - The source artifact.
     * @param target - The target artifact.
     * @return Whether a link can be created, or a reason why it cant.
     */
    isLinkAllowed(
      source: ArtifactSchema | ArtifactCytoElementData,
      target: ArtifactSchema | ArtifactCytoElementData
    ): string | boolean {
      if (source.id === target.id) {
        return ""An artifact cannot link to itself."";
      } else if (
        this.doesLinkExist(source.id, target.id) ||
        this.doesLinkExist(target.id, source.id)
      ) {
        return ""This trace link already exists."";
      } else if (!timStore.canBeTraced(source, target)) {
        return `The type ""${source.type}"" cannot trace to ""${target.type}"".`;
      }

      return true;
    },
  },
});

export default useTraces(pinia);
"
src/hooks/project/useArtifacts.ts,"import { defineStore } from ""pinia"";

import { ArtifactSchema, DocumentArtifacts, FlatArtifact } from ""@/types"";
import {
  standardizeValueArray,
  flattenArtifact,
  preserveMatches,
  removeMatches,
  collectByField,
} from ""@/util"";
import { timStore } from ""@/hooks"";
import { pinia } from ""@/plugins"";
import documentStore from ""@/hooks/project/useDocuments"";
import projectStore from ""@/hooks/project/useProject"";
import layoutStore from ""@/hooks/graph/useLayout"";
import selectionStore from ""@/hooks/graph/useSelection"";

/**
 * This module defines the state of the current project's artifacts.
 */
export const useArtifacts = defineStore(""artifacts"", {
  state: () => ({
    allArtifacts: [] as ArtifactSchema[],
    currentArtifacts: [] as ArtifactSchema[],
  }),
  getters: {
    /**
     * @return The flattened artifacts for the current document.
     */
    flatArtifacts(): FlatArtifact[] {
      return this.currentArtifacts.map(flattenArtifact);
    },
    /**
     * @return A collection of current artifact lists, keyed by their type.
     */
    allArtifactsByType(): Record<string, ArtifactSchema[]> {
      return collectByField(this.allArtifacts, ""type"");
    },
  },
  actions: {
    /**
     * Initializes the artifacts visible in the current document.
     */
    initializeArtifacts(documentArtifacts: DocumentArtifacts): void {
      const { artifacts = this.allArtifacts, currentArtifactIds } =
        documentArtifacts;

      this.$patch({
        allArtifacts: artifacts,
        currentArtifacts: currentArtifactIds
          ? preserveMatches(artifacts, ""id"", currentArtifactIds)
          : artifacts,
      });
    },
    /**
     * Updates the current artifacts in the project, preserving any that already existed.
     *
     * @param newArtifacts - The new artifacts to add.
     */
    addOrUpdateArtifacts(newArtifacts: ArtifactSchema[]): void {
      const newIds = newArtifacts.map(({ id }) => id);
      const updatedArtifacts = [
        ...removeMatches(this.allArtifacts, ""id"", newIds),
        ...newArtifacts,
      ];

      documentStore.addDocumentArtifacts(newIds);
      this.initializeArtifacts({
        artifacts: updatedArtifacts,
        currentArtifactIds: documentStore.currentArtifactIds,
      });
      projectStore.updateProject({
        artifacts: updatedArtifacts,
      });
    },
    /**
     * Adds a created artifact and updates the layout.
     *
     * @param artifact - The newly created artifact.
     */
    addCreatedArtifact(artifact: ArtifactSchema): void {
      layoutStore.setArtifactToSavedPosition(artifact.id);
      this.addOrUpdateArtifacts([artifact]);
      selectionStore.selectArtifact(artifact.id);
      timStore.addTypesFromArtifacts([artifact]);
    },
    /**
     * Deletes the artifacts with the given names.
     *
     * @param deletedArtifacts - The artifacts, or ids, to delete.
     */
    deleteArtifacts(deletedArtifacts: ArtifactSchema[] | string[]): void {
      if (deletedArtifacts.length === 0) return;

      const ids = standardizeValueArray(deletedArtifacts, ""id"");
      const allArtifacts = removeMatches(this.allArtifacts, ""id"", ids);

      this.$patch({
        allArtifacts,
        currentArtifacts: removeMatches(this.currentArtifacts, ""id"", ids),
      });
      projectStore.updateProject({ artifacts: allArtifacts });

      if (ids.includes(selectionStore.selectedArtifact?.id || """")) {
        selectionStore.clearSelections();
      }
    },
    /**
     * Finds the given artifact by name.
     *
     * @param name - The name to find.
     * @return The matching artifact, if one exists.
     */
    getArtifactByName(name: string): ArtifactSchema | undefined {
      return this.allArtifacts.find((artifact) => artifact.name === name);
    },
    /**
     * Finds the given artifact by id.
     *
     * @param id - The id to find.
     * @return The matching artifact, if one exists.
     */
    getArtifactById(id: string): ArtifactSchema | undefined {
      return this.allArtifacts.find((artifact) => artifact.id === id);
    },
    /**
     * Finds all artifacts of the given type.
     *
     * @param type - The type to find.
     * @return The matching artifacts.
     */
    getArtifactsByType(type: string): ArtifactSchema[] {
      return this.allArtifacts.filter((artifact) => artifact.type === type);
    },
  },
});

export default useArtifacts(pinia);
"
src/hooks/api/index.ts,"export * from ""./core"";
export * from ""./commit"";
export * from ""./project"";
export * from ""./version"";
export * from ""./settings"";
export * from ""./integrations"";
export * from ""./data"";
export * from ""./generation"";
export * from ""./notifications"";
"
src/hooks/api/commit/useTraceCommitApi.ts,"import { defineStore } from ""pinia"";

import { ApprovalType, TraceLinkSchema } from ""@/types"";
import { commitApiStore } from ""@/hooks"";
import { pinia } from ""@/plugins"";

export const useTraceCommitApi = defineStore(""traceCommitApi"", () => {
  /**
   * Creates new trace links.
   *
   * @param traceLink - The trace link to persist.
   * @return The created trace links.
   */
  async function handleCreate(
    traceLink: TraceLinkSchema
  ): Promise<TraceLinkSchema[]> {
    traceLink = {
      ...traceLink,
      approvalStatus: ApprovalType.APPROVED,
    };

    return commitApiStore
      .handleSave((builder) => builder.withNewTraceLink(traceLink))
      .then((commit) => commit?.traces.added || []);
  }

  /**
   * Approves the given trace link ID.
   *
   * @param traceLink - The trace link to approve.
   * @return The modified trace links.
   */
  async function handleApprove(
    traceLink: TraceLinkSchema
  ): Promise<TraceLinkSchema[]> {
    traceLink = {
      ...traceLink,
      approvalStatus: ApprovalType.APPROVED,
    };

    return commitApiStore
      .handleSave((builder) => builder.withModifiedTraceLink(traceLink))
      .then((commit) => commit?.traces.modified || []);
  }

  /**
   * Declines the given trace link ID.
   *
   * @param traceLink - The trace link to decline.
   * @return The removed trace links.
   */
  async function handleDecline(
    traceLink: TraceLinkSchema
  ): Promise<TraceLinkSchema[]> {
    traceLink = {
      ...traceLink,
      approvalStatus: ApprovalType.DECLINED,
    };

    return commitApiStore
      .handleSave((builder) => builder.withModifiedTraceLink(traceLink))
      .then((commit) => commit?.traces.modified || []);
  }

  /**
   * Declines all given links.
   *
   * @param traceLinks - The trace links to decline.
   * @return The removed trace links.
   */
  async function handleDeclineAll(
    traceLinks: TraceLinkSchema[]
  ): Promise<TraceLinkSchema[]> {
    traceLinks = traceLinks.map((link) => ({
      ...link,
      approvalStatus: ApprovalType.DECLINED,
    }));

    return commitApiStore
      .handleSave((builder) => builder.withModifiedTraceLink(...traceLinks))
      .then((commit) => commit?.traces.modified || []);
  }

  /**
   * Declines the given trace link ID.
   *
   * @param traceLink - The trace link to decline.
   * @return The removed trace links.
   */
  async function handleUnreview(
    traceLink: TraceLinkSchema
  ): Promise<TraceLinkSchema[]> {
    traceLink = {
      ...traceLink,
      approvalStatus: ApprovalType.UNREVIEWED,
    };

    return commitApiStore
      .handleSave((builder) => builder.withModifiedTraceLink(traceLink))
      .then((commit) => commit?.traces.modified || []);
  }

  return {
    handleCreate,
    handleApprove,
    handleDecline,
    handleDeclineAll,
    handleUnreview,
  };
});

export default useTraceCommitApi(pinia);
"
src/hooks/api/commit/useCommitApi.ts,"import { defineStore } from ""pinia"";

import { CommitSchema } from ""@/types"";
import { CommitBuilder } from ""@/util"";
import {
  appStore,
  commitStore,
  traceStore,
  artifactStore,
  traceGenerationApiStore,
  projectStore,
  useApi,
} from ""@/hooks"";
import { persistCommit } from ""@/api"";
import { pinia } from ""@/plugins"";

export const useCommitApi = defineStore(""commitApi"", () => {
  const commitApi = useApi(""commitApi"");

  /**
   * Creates a new commit based on the current project version.
   */
  function buildCommit(): CommitBuilder {
    const version = projectStore.version;

    if (version === undefined) {
      throw Error(""No project version is selected."");
    }

    return new CommitBuilder(version);
  }

  /**
   * Saves commit to the application store, and persist the commit.
   *
   * @param commitOrCb - The commit to save, or a callback to create it.
   * @return The saved commit.
   */
  async function handleSave(
    commitOrCb: CommitSchema | ((builder: CommitBuilder) => CommitBuilder)
  ): Promise<CommitSchema | undefined> {
    return commitApi.handleRequest(
      async () => {
        appStore.isSaving = true;

        const commit =
          typeof commitOrCb === ""function""
            ? commitOrCb(buildCommit()).commit
            : commitOrCb;

        const commitResponse = await persistCommit(commit);

        const fullCommit = {
          ...commitResponse,
          artifacts: {
            added: commitResponse.artifacts.added,
            modified: commitResponse.artifacts.modified,
            removed: commit.artifacts.removed,
          },
          traces: {
            added: commitResponse.traces.added,
            modified: commitResponse.traces.modified,
            removed: commit.traces.removed,
          },
        };

        commitStore.saveCommit(fullCommit);

        return fullCommit;
      },
      {
        onComplete: () => (appStore.isSaving = false),
      }
    );
  }

  /**
   * Undoes the last commit.
   */
  async function handleUndo(): Promise<void> {
    await commitApi.handleRequest(
      async () => {
        appStore.isSaving = true;

        const commit = await commitStore.undoLastCommit();

        if (!commit) return;

        const commitResponse = await persistCommit(commit);

        await applyArtifactChanges(commitResponse);
      },
      {
        onComplete: () => (appStore.isSaving = false),
      }
    );
  }

  /**
   * Reattempts the last undone commit.
   */
  async function handleRedo(): Promise<void> {
    await commitApi.handleRequest(
      async () => {
        appStore.isSaving = true;

        const commit = await commitStore.redoLastUndoneCommit();

        if (!commit) return;

        const commitResponse = await persistCommit(commit);

        await applyArtifactChanges(commitResponse);
      },
      {
        onComplete: () => (appStore.isSaving = false),
      }
    );
  }

  /**
   * Applies all artifact changes from a commit.
   *
   * @param commit - The commit to apply.
   */
  async function applyArtifactChanges(commit: CommitSchema): Promise<void> {
    artifactStore.addOrUpdateArtifacts([
      ...commit.artifacts.added,
      ...commit.artifacts.modified,
    ]);
    artifactStore.deleteArtifacts(commit.artifacts.removed);
    traceStore.addOrUpdateTraceLinks([
      ...commit.traces.added,
      ...commit.traces.modified,
    ]);
    traceStore.deleteTraceLinks(commit.traces.removed);

    if (commit.traces.modified.length === 0) return;

    // Reload generated links if any are modified.
    await traceGenerationApiStore.handleReload();
  }

  return {
    handleSave,
    handleUndo,
    handleRedo,
  };
});

export default useCommitApi(pinia);
"
src/hooks/api/commit/index.ts,"export { default as commitApiStore } from ""./useCommitApi"";
export { default as artifactCommitApiStore } from ""./useArtifactCommitApi"";
export { default as traceCommitApiStore } from ""./useTraceCommitApi"";
"
src/hooks/api/commit/useArtifactCommitApi.ts,"import { defineStore } from ""pinia"";

import { ApprovalType, ArtifactSchema, TraceLinkSchema } from ""@/types"";
import { commitApiStore } from ""@/hooks"";
import { pinia } from ""@/plugins"";

export const useArtifactCommitApi = defineStore(""artifactCommitApi"", () => {
  /**
   * Creates a new artifact in the given version.
   *
   * @param versionId - The version that the artifact is stored within.
   * @param artifact - The artifact to create.
   * @return The created artifact.
   */
  async function handleCreate(
    versionId: string,
    artifact: ArtifactSchema
  ): Promise<ArtifactSchema[]> {
    return commitApiStore
      .handleSave((builder) => builder.withNewArtifact(artifact))
      .then((commit) => commit?.artifacts.added || []);
  }

  /**
   * Updates the artifact in the given version.
   *
   * @param versionId - The version that the artifact is stored within.
   * @param artifact - The artifact to updated.
   * @return The updated artifact.
   */
  async function handleUpdate(
    versionId: string,
    artifact: ArtifactSchema
  ): Promise<ArtifactSchema[]> {
    return commitApiStore
      .handleSave((builder) => builder.withModifiedArtifact(artifact))
      .then((commit) => commit?.artifacts.modified || []);
  }

  /**
   * Deletes artifact in project version specified.
   *
   * @param artifact - The artifact to delete.
   * @param traceLinks - Any related trace links to also delete.
   * @return The deleted artifact.
   */
  async function handleDelete(
    artifact: ArtifactSchema,
    traceLinks: TraceLinkSchema[]
  ): Promise<ArtifactSchema> {
    traceLinks = traceLinks.map((link) => ({
      ...link,
      approvalStatus: ApprovalType.DECLINED,
    }));

    return commitApiStore
      .handleSave((builder) =>
        builder
          .withRemovedArtifact(artifact)
          .withModifiedTraceLink(...traceLinks)
      )
      .then(() => artifact);
  }

  return { handleCreate, handleUpdate, handleDelete };
});

export default useArtifactCommitApi(pinia);
"
src/hooks/api/settings/useAttributeApi.ts,"import { defineStore } from ""pinia"";

import {
  AttributeLayoutSchema,
  AttributeSchema,
  IOHandlerCallback,
} from ""@/types"";
import { useApi, attributesStore, logStore, projectStore } from ""@/hooks"";
import {
  createAttribute,
  createAttributeLayout,
  deleteAttribute,
  deleteAttributeLayout,
  editAttribute,
  editAttributeLayout,
} from ""@/api"";
import { pinia } from ""@/plugins"";
export const useAttributeApi = defineStore(""attributeApi"", () => {
  const attributeApi = useApi(""attributeApi"");
  const attributeLayoutApi = useApi(""attributeLayoutApi"");

  /**
   * Creates or edits an attribute and updates the store.
   *
   * @param attribute - The attribute to save.
   * @param isUpdate - Whether an existing attribute is being updated.
   * @param callbacks - Callbacks to call after the action.
   */
  async function handleSaveAttribute(
    attribute: AttributeSchema,
    isUpdate: boolean,
    callbacks: IOHandlerCallback = {}
  ): Promise<void> {
    await attributeApi.handleRequest(
      async () => {
        const projectId = projectStore.projectId;

        if (isUpdate) {
          const updatedAttribute = await editAttribute(projectId, attribute);

          attributesStore.updateAttribute(updatedAttribute);
        } else {
          const createdAttribute = await createAttribute(projectId, attribute);

          attributesStore.updateAttribute(createdAttribute);
        }
      },
      callbacks,
      {
        success: isUpdate
          ? `Edited attribute: ${attribute.label}`
          : `Created attribute: ${attribute.label}`,
        error: `Unable to save attribute: ${attribute.label}`,
      }
    );
  }

  /**
   * Deletes an attribute and updates the store.
   *
   * @param attribute - The attribute to delete.
   * @param callbacks - Callbacks to call after the action.
   */
  async function handleDeleteAttribute(
    attribute: AttributeSchema,
    callbacks: IOHandlerCallback = {}
  ): Promise<void> {
    await logStore.confirm(
      ""Delete Attribute"",
      `Are you sure you would like to delete ""${attribute.label}""?`,
      async (isConfirmed: boolean) => {
        if (!isConfirmed) return;

        await attributeApi.handleRequest(
          async () => {
            await deleteAttribute(projectStore.projectId, attribute);

            attributesStore.deleteAttribute(attribute);
          },
          callbacks,
          {
            success: `Deleted attribute: ${attribute.label}`,
            error: `Unable to delete attribute: ${attribute.label}`,
          }
        );
      }
    );
  }

  /**
   * Creates or edits an attribute layout and updates the store.
   *
   * @param layout - The attribute layout to save.
   * @param isUpdate - Whether an existing attribute layout is being updated.
   * @param callbacks - Callbacks to call after the action.
   */
  async function handleSaveAttributeLayout(
    layout: AttributeLayoutSchema,
    isUpdate: boolean,
    callbacks: IOHandlerCallback<AttributeLayoutSchema> = {}
  ): Promise<void> {
    await attributeLayoutApi.handleRequest(
      async () => {
        const projectId = projectStore.projectId;

        const savedLayout = isUpdate
          ? await editAttributeLayout(projectId, layout)
          : await createAttributeLayout(projectId, layout);

        attributesStore.updateLayout(savedLayout);

        return savedLayout;
      },
      callbacks,
      {
        success: isUpdate
          ? `Edited attribute layout: ${layout.name}`
          : `Created attribute layout: ${layout.name}`,
        error: `Unable to save attribute layout: ${layout.name}`,
      }
    );
  }

  /**
   * Deletes an attribute layout and updates the store.
   *
   * @param layout - The attribute layout to delete.
   * @param callbacks - Callbacks to call after the action.
   */
  async function handleDeleteAttributeLayout(
    layout: AttributeLayoutSchema,
    callbacks: IOHandlerCallback = {}
  ): Promise<void> {
    await logStore.confirm(
      ""Delete Attribute Layout"",
      `Are you sure you would like to delete ""${layout.name}""?`,
      async (isConfirmed: boolean) => {
        if (!isConfirmed) return;

        await attributeLayoutApi.handleRequest(
          async () => {
            await deleteAttributeLayout(projectStore.projectId, layout);

            attributesStore.deleteLayout(layout);
          },
          callbacks,
          {
            success: `Deleted attribute layout: ${layout.name}`,
            error: `Unable to delete attribute layout: ${layout.name}`,
          }
        );
      }
    );
  }

  return {
    handleSaveAttribute,
    handleDeleteAttribute,
    handleSaveAttributeLayout,
    handleDeleteAttributeLayout,
  };
});

export default useAttributeApi(pinia);
"
src/hooks/api/settings/useMemberApi.ts,"import { defineStore } from ""pinia"";

import { computed } from ""vue"";
import { IOHandlerCallback, MembershipSchema, ProjectRole } from ""@/types"";
import {
  useApi,
  getProjectApiStore,
  logStore,
  membersStore,
  projectStore,
  sessionStore,
} from ""@/hooks"";
import {
  deleteProjectMember,
  getProjectMembers,
  saveProjectMember,
} from ""@/api"";
import { pinia } from ""@/plugins"";

export const useMemberApi = defineStore(""memberApi"", () => {
  const memberApi = useApi(""memberApi"");

  const loading = computed(() => memberApi.loading);

  /**
   * Returns the current project's members.
   */
  async function handleReload(): Promise<void> {
    await memberApi.handleRequest(
      async () => {
        const members = await getProjectMembers(projectStore.projectId);

        membersStore.updateMembers(members);
      },
      {},
      { error: `Unable to get members` }
    );
  }

  /**
   * Adds a user to a project and logs the status.
   *
   * @param projectId - The project to add this user to.
   * @param memberEmail - The email of the given user.
   * @param projectRole - The role to set for the given user.
   * @param callbacks - Callbacks for the request.
   */
  async function handleInvite(
    projectId: string,
    memberEmail: string,
    projectRole: ProjectRole,
    callbacks: IOHandlerCallback
  ): Promise<void> {
    await memberApi.handleRequest(
      async () => {
        const member = await saveProjectMember(
          projectId,
          memberEmail,
          projectRole
        );

        membersStore.updateMembers([...membersStore.members, member]);
      },
      callbacks,
      {
        success: `Member has been added: ${memberEmail}`,
        error: `Unable save member: ${memberEmail}`,
      }
    );
  }

  /**
   * Opens a confirmation modal to delete the given member.
   *
   * @param member - The member to delete.
   */
  function handleDelete(member: MembershipSchema): void {
    const email =
      sessionStore.user?.email === member.email
        ? ""yourself""
        : `""${member.email}""`;

    logStore.confirm(
      ""Remove User from Project"",
      `Are you sure you want to remove ${email} from this project?`,
      async (isConfirmed: boolean) => {
        if (!isConfirmed) return;

        await memberApi.handleRequest(
          async () => {
            await deleteProjectMember(member);
            membersStore.deleteMembers([member.projectMembershipId]);
            await getProjectApiStore.handleReload();
          },
          {},
          {
            success: `Deleted a member: ${member.email}`,
            error: `Unable to delete member: ${member.email}`,
          }
        );
      }
    );
  }

  return {
    loading,
    handleReload,
    handleInvite,
    handleDelete,
  };
});

export default useMemberApi(pinia);
"
src/hooks/api/settings/index.ts,"export { default as memberApiStore } from ""./useMemberApi"";
export { default as attributeApiStore } from ""./useAttributeApi"";
"
src/hooks/api/core/useApi.ts,"import { defineStore } from ""pinia"";

import { ref, computed } from ""vue"";
import { IOHandlerCallback } from ""@/types"";
import { LOGOUT_ERROR } from ""@/util"";
import { appStore, logStore, sessionApiStore } from ""@/hooks"";
import { pinia } from ""@/plugins"";

/**
 * Creates a store for handling API requests.
 *
 * @param id - The unique store id to use.
 */
export const useApi = (id: string) =>
  defineStore(`apiStore-${id}`, () => {
    const loading = ref(false);
    const error = ref(false);

    /**
     * Resets the API state.
     */
    function handleReset(): void {
      loading.value = false;
      error.value = false;
    }

    /**
     * Creates a reactive error message for inputs.
     * @param message - The message to display.
     */
    function errorMessage(message: string) {
      return computed(() => (error.value ? message : false));
    }

    /**
     * Runs a request and handles the loading and error states,
     * as well as optionally reporting success and error messages.
     *
     * @param cb - The callback to run.
     * @param config - The success & error messages to display.
     * @param onSuccess - The callback to run on success.
     * @param onError - The callback to run on error.
     * @param onComplete - The callback to run on completion.
     */
    async function handleRequest<T = void>(
      cb: () => Promise<T>,
      { onSuccess, onError, onComplete }: IOHandlerCallback<T> = {},
      config: { success?: string; error?: string; useAppLoad?: boolean } = {}
    ): Promise<T | undefined> {
      loading.value = true;
      error.value = false;

      try {
        if (config.useAppLoad) {
          appStore.onLoadStart();
        }

        const res = await cb();

        onSuccess?.(res);

        if (config.success) {
          logStore.onSuccess(config.success);
        }

        return res;
      } catch (e) {
        error.value = true;

        if ((e as Error)?.message === LOGOUT_ERROR) {
          // If the user's token has expired, log them out.
          await sessionApiStore.handleLogout();
          logStore.onWarning(LOGOUT_ERROR);
          return;
        }

        onError?.(e as Error);
        logStore.onDevError(String(e));

        if (config.error) {
          logStore.onError(config.error);
        }
      } finally {
        loading.value = false;

        if (config.useAppLoad) {
          appStore.onLoadEnd();
        }

        onComplete?.();
      }
    }

    return { loading, error, errorMessage, handleRequest, handleReset };
  });

export default (id: string) => useApi(id)(pinia);
"
src/hooks/api/core/index.ts,"export { default as useApi } from ""./useApi"";
export { default as sessionApiStore } from ""./useSessionApi"";
"
src/hooks/api/core/useSessionApi.ts,"import { defineStore } from ""pinia"";

import { computed, ref } from ""vue"";
import {
  IOHandlerCallback,
  PasswordChangeSchema,
  UserPasswordSchema,
} from ""@/types"";
import { DEMO_ACCOUNT } from ""@/util"";
import {
  getProjectApiStore,
  setProjectApiStore,
  sessionStore,
  logStore,
  permissionStore,
} from ""@/hooks"";
import { getParam, getParams, navigateTo, QueryParams, Routes } from ""@/router"";
import {
  createLoginSession,
  savePassword,
  deleteAccount,
  getCurrentUser,
  deleteSession,
  createUser,
  createPasswordReset,
  updatePassword,
} from ""@/api"";
import { pinia } from ""@/plugins"";
import { useApi } from ""@/hooks/api/core/useApi"";

/**
 * Creates a store for handling session API requests.
 */
export const useSessionApi = defineStore(""sessionApi"", () => {
  const createdAccount = ref(false);
  const passwordSubmitted = ref(false);
  const sessionApi = useApi(""sessionApi"")();

  const loading = computed(() => sessionApi.loading);
  const error = computed(() => sessionApi.error);

  const loginErrorMessage = sessionApi.errorMessage(
    ""Invalid username or password.""
  );

  const createErrorMessage = sessionApi.errorMessage(
    ""Unable to create an account.""
  );

  const passwordErrorMessage = sessionApi.errorMessage(
    ""Unable to update password.""
  );

  /**
   * Resets the session API state.
   */
  function handleReset(): void {
    createdAccount.value = false;
    passwordSubmitted.value = false;
    sessionApi.handleReset();
  }

  /**
   * Attempts to create a new account.
   *
   * @param user - The user to create.
   */
  async function handleCreateAccount(user: UserPasswordSchema): Promise<void> {
    await sessionApi.handleRequest(async () => {
      await createUser(user);

      createdAccount.value = true;
    });
  }

  /**
   * Attempts to send a password reset email.
   *
   * @param email - The email to send the reset to.
   */
  async function handlePasswordReset(email: string): Promise<void> {
    await sessionApi.handleRequest(async () => {
      await createPasswordReset({ email });

      passwordSubmitted.value = true;
    });
  }

  /**
   * Attempts to reset a user's password.
   *
   * @param newPassword - The password and token to reset with.
   * @param resetToken - The token to reset with.
   */
  async function handlePasswordUpdate(
    newPassword: string,
    resetToken: string
  ): Promise<void> {
    await sessionApi.handleRequest(async () => {
      await updatePassword({
        newPassword,
        resetToken,
      });

      passwordSubmitted.value = true;
    });
  }

  /**
   * Attempts to log a user in.
   *
   * @param user - The user to log in.
   */
  async function handleLogin(user: UserPasswordSchema): Promise<void> {
    await sessionApi.handleRequest(async () => {
      const session = await createLoginSession(user);
      const goToPath = getParam(QueryParams.LOGIN_PATH);
      const query = { ...getParams() };

      console.log({ goToPath, query });

      delete query[QueryParams.LOGIN_PATH];

      sessionStore.user = await getCurrentUser();
      sessionStore.updateSession(session);

      await getProjectApiStore.handleReload({
        onComplete: async () => {
          if (goToPath === Routes.ARTIFACT) {
            await getProjectApiStore.handleLoadRecent();
          } else if (typeof goToPath === ""string"") {
            await navigateTo(goToPath, query);
          } else {
            await navigateTo(Routes.HOME, query);
          }
        },
      });
    });
  }

  /**
   * Logs in to the demo account and opens the demo project.
   */
  async function handleDemoLogin(): Promise<void> {
    permissionStore.isDemo = true;

    await handleLogin(DEMO_ACCOUNT).then(() =>
      navigateTo(Routes.ARTIFACT, {
        [QueryParams.VERSION]: ""cf354d4b-21d7-4f8e-8951-e447ddf77997"",
      })
    );
  }

  /**
   * Logs a user out to the login screen.
   *
   * @param sendLogoutRequest - Whether to send the API request to log out.
   */
  async function handleLogout(sendLogoutRequest = false): Promise<void> {
    await sessionApi.handleRequest(async () => {
      document.cookie = """";

      await setProjectApiStore.handleClear();
      await navigateTo(Routes.LOGIN_ACCOUNT);
      sessionStore.clearSession();
      logStore.notifications = [];

      if (sendLogoutRequest) {
        await deleteSession();
      }
    });
  }

  /**
   * Verifies the stored authentication token, and loads the last project if routing to the artifact tree.
   * @throws If the authentication token is invalid.
   */
  async function handleAuthentication(): Promise<void> {
    sessionStore.user = await getCurrentUser();

    if (sessionStore.user.email === DEMO_ACCOUNT.email) {
      permissionStore.isDemo = true;
    }

    await getProjectApiStore.handleReload({});
  }

  /**
   * Updates a user's password.
   *
   * @param password - The old and new password.
   * @param callbacks - The callbacks to run on success or error.
   */
  async function handleChangePassword(
    password: PasswordChangeSchema,
    callbacks: IOHandlerCallback
  ): Promise<void> {
    await sessionApi.handleRequest(() => savePassword(password), callbacks, {
      success: ""Your password has been updated."",
      error: ""Unable to update your password."",
    });
  }

  /**
   * Confirms and deletes a user's account.
   *
   * @param password - The user's current password.
   */
  function handleDeleteAccount(password: string): void {
    logStore.confirm(
      ""Delete your account?"",
      ""This action cannot be undone."",
      async (isConfirmed) => {
        if (!isConfirmed) return;

        await sessionApi.handleRequest(
          () => deleteAccount(password),
          {
            onSuccess: () => handleLogout(),
          },
          { error: ""Unable to delete your account."" }
        );
      }
    );
  }

  return {
    loading,
    error,
    createdAccount,
    passwordSubmitted,
    createErrorMessage,
    passwordErrorMessage,
    loginErrorMessage,
    handleReset,
    handleCreateAccount,
    handlePasswordReset,
    handlePasswordUpdate,
    handleLogin,
    handleDemoLogin,
    handleLogout,
    handleAuthentication,
    handleChangePassword,
    handleDeleteAccount,
  };
});

export default useSessionApi(pinia);
"
src/hooks/api/project/useSetProjectApi.ts,"import { defineStore } from ""pinia"";

import { ProjectSchema } from ""@/types"";
import { createProject } from ""@/util"";
import {
  deltaStore,
  documentStore,
  getVersionApiStore,
  integrationsApiStore,
  notificationApiStore,
  projectStore,
  subtreeStore,
  useApi,
} from ""@/hooks"";
import { QueryParams, removeParams, updateParam } from ""@/router"";
import { pinia } from ""@/plugins"";

export const useSetProjectApi = defineStore(""setProjectApi"", () => {
  const setProjectApi = useApi(""setProjectApi"");

  /**
   * Moves user to the document if one is set by currentDocumentId.
   * Otherwise default document would continue to be in view.
   *
   * @param project The project possibly containing a currentDocumentId.
   */
  async function setCurrentDocument(project: ProjectSchema): Promise<void> {
    if (!project.currentDocumentId) return;

    const document = project.documents.find(
      (d) => d.documentId === project.currentDocumentId
    );

    if (!document) return;

    await documentStore.switchDocuments(document);
  }

  /**
   * Clears project store data.
   */
  async function handleClear(): Promise<void> {
    const project = createProject();

    projectStore.initializeProject(project);
    subtreeStore.$reset();
    await removeParams();
  }

  /**
   * Sets a newly created project.
   *
   * @param project - Project created containing entities.
   */
  async function handleSet(project: ProjectSchema): Promise<void> {
    await setProjectApi.handleRequest(async () => {
      const projectId = project.projectId;
      const versionId = project.projectVersion?.versionId || """";

      projectStore.initializeProject(project);

      await notificationApiStore.handleSubscribeVersion(projectId, versionId);
      await integrationsApiStore.handleReload();
      await setCurrentDocument(project);
      await updateParam(QueryParams.VERSION, versionId);
    });
  }

  /**
   * Reloads the current project.
   */
  async function handleReload(): Promise<void> {
    deltaStore.setIsDeltaViewEnabled(false);
    await getVersionApiStore.handleLoad(
      projectStore.versionId,
      documentStore.currentDocument
    );
  }

  return { handleClear, handleSet, handleReload };
});

export default useSetProjectApi(pinia);
"
src/hooks/api/project/useParseApi.ts,"import { defineStore } from ""pinia"";

import { ArtifactMap, CreatorFilePanel, TraceLinkSchema } from ""@/types"";
import { extractTraceId } from ""@/util"";
import { useApi } from ""@/hooks"";
import { parseArtifactFile, parseTraceFile } from ""@/api"";
import { pinia } from ""@/plugins"";

export const useParseApi = defineStore(""useParseApi"", () => {
  const parseApi = useApi(""parseApi"");

  /**
   * Parses a file for the project creator.
   *
   * @param panel - The panel to parse the file of.
   * @param artifactMap - A collection of all parsed artifacts, keyed by name.
   */
  async function handleParseProjectFile(
    panel: CreatorFilePanel,
    artifactMap: ArtifactMap
  ): Promise<void> {
    await parseApi.handleRequest(
      async () => {
        if (!panel.file) return;

        const [fileType = """", fileTargetType = """"] =
          panel.file.name?.split(""."")[0]?.split(""2"") || [];

        panel.loading = true;
        panel.type = panel.type || fileType;

        if (panel.variant === ""artifact"") {
          await parseArtifactFile(panel.type, panel.file).then(
            ({ entities, errors }) => {
              panel.artifacts = entities;
              panel.errorMessage =
                errors.length === 0 ? undefined : errors.join("", "");
              panel.itemNames = entities.map(({ name }) => name);

              entities.forEach((artifact) => {
                artifactMap[artifact.name] = artifact;
              });
            }
          );
        } else {
          panel.toType = panel.toType || fileTargetType;

          await parseTraceFile(panel.file).then(({ entities, errors }) => {
            panel.traces = entities;

            errors.push(...getTraceErrors(panel, artifactMap, entities));

            panel.errorMessage =
              errors.length === 0 ? undefined : errors.join("", "");
            panel.itemNames = entities.map(extractTraceId);
          });
        }
      },
      {
        onError: () => (panel.errorMessage = ""Unable to parse this file""),
        onComplete: () => (panel.loading = false),
      }
    );
  }

  /**
   * Returns any errors for the given trace links.
   *
   * @param panel - The panel for uploading trace links.
   * @param artifactMap - A collection of all artifacts.
   * @param traces - The traces to check for errors.
   * @return The error message, if there is one.
   */
  function getTraceErrors(
    panel: CreatorFilePanel,
    artifactMap: ArtifactMap,
    traces: TraceLinkSchema[]
  ): string[] {
    const errors: string[] = [];

    traces.forEach(({ sourceName, targetName }) => {
      if (!(sourceName in artifactMap)) {
        errors.push(`Artifact ${sourceName} does not exist`);
      } else if (!(targetName in artifactMap)) {
        errors.push(`Artifact ${targetName} does not exist`);
      } else {
        const sourceArtifact = artifactMap[sourceName];
        const targetArtifact = artifactMap[targetName];

        if (sourceArtifact.type !== panel.type) {
          errors.push(`${sourceArtifact.name} is not of type ${panel.type}`);
        }

        if (targetArtifact.type !== panel.toType) {
          errors.push(`${targetArtifact.name} is not of type ${panel.toType}`);
        }
      }
    });

    return errors;
  }

  return { handleParseProjectFile };
});

export default useParseApi(pinia);
"
src/hooks/api/project/useProjectApi.ts,"import { defineStore } from ""pinia"";
import { computed } from ""vue"";
import { saveAs } from ""file-saver"";

import { IOHandlerCallback, ProjectSchema, VersionSchema } from ""@/types"";
import { versionToString } from ""@/util"";
import {
  getProjectApiStore,
  identifierSaveStore,
  logStore,
  projectStore,
  setProjectApiStore,
  useApi,
} from ""@/hooks"";
import {
  deleteProject,
  deleteProjectVersion,
  saveProject,
  getProjectFiles,
} from ""@/api"";
import { pinia } from ""@/plugins"";

export const useProjectApi = defineStore(""projectApi"", () => {
  const saveProjectApi = useApi(""saveProjectApi"");
  const deleteProjectApi = useApi(""deleteProjectApi"");
  const deleteVersionApi = useApi(""deleteVersionApi"");

  const saveProjectLoading = computed(() => saveProjectApi.loading);
  const deleteProjectLoading = computed(() => deleteProjectApi.loading);
  const deleteVersionLoading = computed(() => deleteVersionApi.loading);

  /**
   * Saves a project, updates app state, and logs the status.
   *
   * @param callbacks - Callbacks for the action.
   */
  async function handleSave(
    callbacks: IOHandlerCallback<ProjectSchema> = {}
  ): Promise<void> {
    const identifier = identifierSaveStore.editedIdentifier;

    await saveProjectApi.handleRequest(
      async () => {
        const project = await saveProject(identifier);

        getProjectApiStore.addProject(
          identifier.projectId ? identifier : project
        );

        return project;
      },
      callbacks,
      {
        success: `Project has been saved: ${identifier.name}`,
        error: `Unable to save project: ${identifier.name}`,
      }
    );
  }

  /**
   * Creates a file download for project files, either in csv for json format.
   *
   * @param fileType - The file format to download.
   */
  async function handleDownload(
    fileType: ""csv"" | ""json"" = ""csv""
  ): Promise<void> {
    await saveProjectApi.handleRequest(async () => {
      const data = await getProjectFiles(projectStore.versionId, fileType);

      const fileName = `${projectStore.project.name}-${versionToString(
        projectStore.version
      )}.zip`;
      const blob = new Blob([data], {
        type: ""application/octet-stream"",
      });

      saveAs(blob, fileName);
    });
  }

  /**
   * Deletes a project, updates app state, and logs the status.
   *
   * @param callbacks - Callbacks for the action.
   */
  async function handleDeleteProject(
    callbacks: IOHandlerCallback
  ): Promise<void> {
    const project = identifierSaveStore.baseIdentifier;

    if (!project) return;

    await deleteProjectApi.handleRequest(
      async () => {
        await deleteProject(project.projectId);

        getProjectApiStore.allProjects = getProjectApiStore.allProjects.filter(
          ({ projectId }) => projectId !== project.projectId
        );

        if (project.name !== projectStore.project.name) return;

        // Clear the current project if it has been deleted.
        await setProjectApiStore.handleClear();
      },
      callbacks,
      {
        success: `Project has been deleted: ${project.name}`,
        error: `Unable to delete project: ${project.name}`,
      }
    );
  }

  /**
   * Deletes a version, updates app state, and logs the status.
   *
   * @param version - The version to delete.
   * @param callbacks - Callbacks for the action.
   */
  function handleDeleteVersion(
    version: VersionSchema,
    callbacks: IOHandlerCallback
  ): void {
    const name = versionToString(version);

    logStore.confirm(
      `Delete Version`,
      `Are you sure you would like to delete ""${name}""?`,
      async (isConfirmed: boolean) => {
        if (!isConfirmed) return;

        await deleteVersionApi.handleRequest(
          async () => deleteProjectVersion(version.versionId),
          callbacks,
          {
            success: `Version has been deleted: ${name}`,
            error: `Unable to delete version: ${name}`,
          }
        );
      }
    );
  }

  return {
    saveProjectLoading,
    deleteProjectLoading,
    deleteVersionLoading,
    handleSave,
    handleDownload,
    handleDeleteProject,
    handleDeleteVersion,
  };
});

export default useProjectApi(pinia);
"
src/hooks/api/project/index.ts,"export { default as parseApiStore } from ""./useParseApi"";
export { default as createProjectApiStore } from ""./useCreateProjectApi"";
export { default as getProjectApiStore } from ""./useGetProjectApi"";
export { default as setProjectApiStore } from ""./useSetProjectApi"";
export { default as projectApiStore } from ""./useProjectApi"";
"
src/hooks/api/project/useGetProjectApi.ts,"import { defineStore } from ""pinia"";

import { computed, ref } from ""vue"";
import { IdentifierSchema, IOHandlerCallback } from ""@/types"";
import { removeMatches } from ""@/util"";
import {
  getVersionApiStore,
  projectStore,
  sessionStore,
  useApi,
} from ""@/hooks"";
import { getParam, navigateTo, QueryParams, Routes } from ""@/router"";
import { getCurrentVersion, getProjects } from ""@/api"";
import { pinia } from ""@/plugins"";

export const useGetProjectApi = defineStore(""getProjectApi"", () => {
  const getProjectApi = useApi(""getProjectApi"");

  const allProjects = ref<IdentifierSchema[]>([]);

  const unloadedProjects = computed(() =>
    allProjects.value.filter(
      ({ projectId }) => projectId !== projectStore.projectId
    )
  );

  const loading = computed(() => getProjectApi.loading);

  const currentProject = computed({
    get: () => (projectStore.projectId ? projectStore.project : undefined),
    set(identifier: IdentifierSchema | undefined) {
      if (!identifier) return;

      getVersionApiStore.handleLoadCurrent(identifier);
    },
  });

  /**
   * Adds or replaces a project in the project list.
   *
   * @param project - The project to add.
   */
  function addProject(project: IdentifierSchema): void {
    allProjects.value = [
      project,
      ...removeMatches(allProjects.value, ""projectId"", [project.projectId]),
    ];
  }

  /**
   * Stores all projects for the current user.
   *
   * @param callbacks - The callbacks to call after the action.
   */
  async function handleReload(
    callbacks: IOHandlerCallback = {}
  ): Promise<void> {
    if (!sessionStore.doesSessionExist) {
      callbacks.onSuccess?.();
      return;
    }

    await getProjectApi.handleRequest(
      async () => {
        allProjects.value = await getProjects();
      },
      callbacks,
      { error: ""Unable to load your projects."" }
    );
  }

  /**
   * Loads the last stored project.
   */
  async function handleLoadRecent(): Promise<void> {
    if (!sessionStore.doesSessionExist) return;

    let versionId = getParam(QueryParams.VERSION);

    if (!versionId) {
      if (allProjects.value.length > 0) {
        versionId = (await getCurrentVersion(allProjects.value[0].projectId))
          .versionId;
      }
    }
    if (typeof versionId === ""string"") {
      await getVersionApiStore.handleLoad(versionId).catch(() => {
        navigateTo(Routes.HOME);
      });
    } else {
      await navigateTo(Routes.HOME);
    }
  }

  return {
    loading,
    allProjects,
    unloadedProjects,
    currentProject,
    addProject,
    handleReload,
    handleLoadRecent,
  };
});

export default useGetProjectApi(pinia);
"
src/hooks/api/project/useCreateProjectApi.ts,"import { defineStore } from ""pinia"";

import { computed } from ""vue"";
import { IOHandlerCallback, ProjectSchema } from ""@/types"";
import {
  integrationsStore,
  jobApiStore,
  projectSaveStore,
  useApi,
} from ""@/hooks"";
import { navigateTo, Routes } from ""@/router"";
import {
  createGitHubProject,
  createJiraProject,
  createProjectCreationJob,
  createProjectUploadJob,
} from ""@/api"";
import { pinia } from ""@/plugins"";

export const useCreateProjectApi = defineStore(""createProjectApi"", () => {
  const createProjectApi = useApi(""createProjectApi"");

  const loading = computed(() => createProjectApi.loading);

  /**
   * Creates a new project, sets related app state, and logs the status.
   *
   * @param onSuccess - Called if the action is successful.
   * @param onError - Called if the action fails.
   */
  async function handleImport({
    onSuccess,
    onError,
  }: IOHandlerCallback): Promise<void> {
    const projectCreationRequest = projectSaveStore.creationRequest;
    const name = projectCreationRequest.project.name;

    await createProjectApi.handleRequest(
      async () => createProjectCreationJob(projectCreationRequest),
      {
        onSuccess: async (job) => {
          await jobApiStore.handleCreate(job);
          await navigateTo(Routes.UPLOAD_STATUS);

          onSuccess?.();
        },
        onError,
      },
      {
        useAppLoad: true,
        success: `Project is being created: ${name}`,
        error: `Unable to import project: ${name}`,
      }
    );
  }

  /**
   * Creates a new project from files, sets related app state, and logs the status.
   *
   * @param project - The project to create.
   * @param files - The files to upload.
   * @param summarize - Whether to summarize artifacts.
   * @param callbacks - The callbacks to use on success, error, and complete.
   */
  async function handleBulkImport(
    project: Pick<
      ProjectSchema,
      ""projectId"" | ""name"" | ""description"" | ""projectVersion""
    >,
    files: File[],
    summarize: boolean,
    callbacks: IOHandlerCallback
  ): Promise<void> {
    await createProjectApi.handleRequest(
      async () => {
        const formData = new FormData();

        formData.append(""name"", project.name);
        formData.append(""description"", project.description);
        formData.append(""summarize"", summarize.toString());

        files.forEach((file: File) => {
          formData.append(""files"", file);
        });

        const job = await createProjectUploadJob(formData);

        await jobApiStore.handleCreate(job);
      },
      {
        ...callbacks,
        onComplete: async () => {
          await navigateTo(Routes.UPLOAD_STATUS);
          callbacks.onSuccess?.();
        },
      },
      {
        useAppLoad: true,
        success: `Project has been created: ${project.name}`,
        error: `Unable to create project: ${project.name}`,
      }
    );
  }

  /**
   * Imports a Jira project, sets related app state, and moves to the upload page.
   *
   * @param onSuccess - Called if the action is successful.
   * @param onError - Called if the action fails.
   */
  async function handleJiraImport({
    onSuccess,
    onError,
  }: IOHandlerCallback): Promise<void> {
    const installationId = integrationsStore.jiraOrganization?.id;
    const projectId = integrationsStore.jiraProject?.id;

    if (!installationId || !projectId) return;

    await createProjectApi.handleRequest(
      () => createJiraProject(installationId, projectId),
      {
        onSuccess: async (job) => {
          integrationsStore.jiraProject = undefined;

          await jobApiStore.handleCreate(job);
          await navigateTo(Routes.UPLOAD_STATUS);

          onSuccess?.();
        },
        onError,
      },
      {
        useAppLoad: true,
        success: `Jira project has been created: ${projectId}`,
        error: `Unable to import jira project: ${projectId}`,
      }
    );
  }

  /**
   * Imports a GitHub project, sets related app state, and moves to the upload page.
   *
   * @param onSuccess - Called if the action is successful.
   * @param onError - Called if the action fails.
   */
  async function handleGitHubImport({
    onSuccess,
    onError,
  }: IOHandlerCallback): Promise<void> {
    const repositoryName = integrationsStore.gitHubProject?.name;
    const owner = integrationsStore.gitHubProject?.owner;

    if (!repositoryName || !owner) return;

    await createProjectApi.handleRequest(
      () =>
        createGitHubProject(
          owner,
          repositoryName,
          integrationsStore.gitHubConfig
        ),
      {
        onSuccess: async (job) => {
          integrationsStore.gitHubProject = undefined;

          await jobApiStore.handleCreate(job);
          await navigateTo(Routes.UPLOAD_STATUS);

          onSuccess?.();
        },
        onError,
      },
      {
        useAppLoad: true,
        success: `GitHub project has been created: ${repositoryName}`,
        error: `Unable to import GitHub project: ${repositoryName}`,
      }
    );
  }

  return {
    loading,
    handleImport,
    handleBulkImport,
    handleJiraImport,
    handleGitHubImport,
  };
});

export default useCreateProjectApi(pinia);
"
src/hooks/api/integrations/useGitHubApi.ts,"import { defineStore } from ""pinia"";

import { computed, ref } from ""vue"";
import {
  GitHubOrganizationSchema,
  GitHubProjectSchema,
  IOHandlerCallback,
} from ""@/types"";
import { useApi, integrationsStore } from ""@/hooks"";
import { getParam, QueryParams } from ""@/router"";
import {
  getGitHubCredentials,
  getGitHubProjects,
  refreshGitHubCredentials,
  saveGitHubCredentials,
  authorizeGitHub,
  deleteGitHubCredentials,
} from ""@/api"";
import { pinia } from ""@/plugins"";

export const useGitHubApi = defineStore(""gitHubApi"", () => {
  const githubApi = useApi(""githubApi"");

  const organizationList = ref<GitHubOrganizationSchema[]>([]);
  const projectList = ref<GitHubProjectSchema[]>([]);

  const loading = computed(() => githubApi.loading);

  /**
   * Opens the GitHub authentication window.
   */
  function handleAuthRedirect(): void {
    authorizeGitHub();
  }

  /**
   * Clears the saved GitHub credentials.
   */
  async function handleDeleteCredentials(): Promise<void> {
    await githubApi.handleRequest(async () => {
      await deleteGitHubCredentials();
      integrationsStore.validGitHubCredentials = false;
    });
  }

  /**
   * Handles GitHub authentication when the app loads.
   *
   * @param callbacks - Called once the action is complete.
   */
  async function handleVerifyCredentials(
    callbacks: IOHandlerCallback = {}
  ): Promise<void> {
    const accessCode =
      getParam(QueryParams.TAB) === ""github""
        ? getParam(QueryParams.GITHUB_TOKEN)
        : """";

    const onSuccess = () => {
      integrationsStore.validGitHubCredentials = true;
      callbacks.onSuccess?.();
    };
    const onError = (e: Error) => {
      integrationsStore.validGitHubCredentials = false;
      callbacks.onError?.(e);
    };

    await githubApi.handleRequest(
      async () => {
        if (accessCode) {
          await saveGitHubCredentials(String(accessCode));
        } else {
          const valid = await getGitHubCredentials();

          if (valid) return;

          const refreshValid = await refreshGitHubCredentials();

          if (!refreshValid) {
            throw new Error(""Invalid refresh"");
          }
        }
      },
      { onSuccess, onError },
      {
        error: accessCode ? ""Unable to save GitHub access code."" : undefined,
      }
    );
  }

  /**
   * Loads GitHub projects and creates related organizations.
   *
   * @param callbacks - Called once the action is complete.
   */
  async function handleLoadProjects(
    callbacks: IOHandlerCallback<GitHubProjectSchema[]> = {}
  ): Promise<void> {
    await githubApi.handleRequest(async () => {
      integrationsStore.gitHubOrganization = undefined;
      organizationList.value = [];

      const projects = await getGitHubProjects();

      // Add organizations to the list based on the projects.
      projects.forEach(({ owner }) => {
        if (organizationList.value.find(({ id }) => id === owner)) return;

        organizationList.value.push({
          id: owner,
          name: owner,
        });
      });

      projectList.value = projects;

      return projects;
    }, callbacks);
  }

  return {
    organizationList,
    projectList,
    loading,
    handleAuthRedirect,
    handleDeleteCredentials,
    handleVerifyCredentials,
    handleLoadProjects,
  };
});

export default useGitHubApi(pinia);
"
src/hooks/api/integrations/useJiraApi.ts,"import { defineStore } from ""pinia"";

import { computed, ref } from ""vue"";
import {
  IOHandlerCallback,
  JiraOrganizationSchema,
  JiraProjectSchema,
} from ""@/types"";
import { useApi, integrationsStore } from ""@/hooks"";
import { getParam, QueryParams } from ""@/router"";
import {
  getJiraCredentials,
  getJiraProjects,
  refreshJiraCredentials,
  saveJiraCredentials,
  getJiraInstallations,
  authorizeJira,
  deleteJiraCredentials,
} from ""@/api"";
import { pinia } from ""@/plugins"";

export const useJiraApi = defineStore(""jiraApi"", () => {
  const jiraApi = useApi(""jiraApi"");

  const organizationList = ref<JiraOrganizationSchema[]>([]);
  const projectList = ref<JiraProjectSchema[]>([]);

  const loading = computed(() => jiraApi.loading);

  /**
   * Opens the Jira authentication window.
   */
  function handleAuthRedirect(): void {
    authorizeJira();
  }

  /**
   * Clears the saved Jira credentials.
   */
  async function handleDeleteCredentials(): Promise<void> {
    await deleteJiraCredentials();
    integrationsStore.validJiraCredentials = false;
  }

  /**
   * Handles Jira authentication when the app loads.
   *
   * @param callbacks - Called once the action is complete.
   */
  async function handleVerifyCredentials(
    callbacks: IOHandlerCallback = {}
  ): Promise<void> {
    const accessCode =
      getParam(QueryParams.TAB) === ""jira""
        ? getParam(QueryParams.JIRA_TOKEN)
        : """";

    const onSuccess = () => {
      integrationsStore.validJiraCredentials = true;
      callbacks.onSuccess?.();
    };
    const onError = (e: Error) => {
      integrationsStore.validJiraCredentials = false;
      callbacks.onError?.(e);
    };

    await jiraApi.handleRequest(
      async () => {
        if (accessCode) {
          await saveJiraCredentials(String(accessCode));
        } else {
          const valid = await getJiraCredentials();

          if (valid) return;

          const refreshValid = await refreshJiraCredentials().catch(
            () => false
          );

          if (!refreshValid) {
            throw new Error(""Invalid refresh"");
          }
        }
      },
      { onSuccess, onError },
      {
        error: accessCode ? ""Unable to save Jira access code."" : undefined,
      }
    );
  }

  /**
   * Loads Jira installations.
   *
   * @param callbacks - Called once the action is complete.
   */
  async function handleLoadOrganizations(
    callbacks: IOHandlerCallback = {}
  ): Promise<void> {
    await jiraApi.handleRequest(async () => {
      integrationsStore.jiraOrganization = undefined;
      organizationList.value = await getJiraInstallations();
    }, callbacks);
  }

  /**
   * Loads Jira projects and sets the currently selected cloud id.
   *
   * @param callbacks - Called once the action is complete.
   */
  async function handleLoadProjects(
    callbacks: IOHandlerCallback = {}
  ): Promise<void> {
    const installationId = integrationsStore.jiraOrganization?.id;

    if (!installationId) return;

    await jiraApi.handleRequest(async () => {
      integrationsStore.jiraProject = undefined;
      projectList.value = await getJiraProjects(installationId);
    }, callbacks);
  }

  return {
    organizationList,
    projectList,
    loading,
    handleAuthRedirect,
    handleDeleteCredentials,
    handleVerifyCredentials,
    handleLoadOrganizations,
    handleLoadProjects,
  };
});

export default useJiraApi(pinia);
"
src/hooks/api/integrations/useIntegrationsApi.ts,"import { defineStore } from ""pinia"";

import { ref } from ""vue"";
import { InstallationSchema, IOHandlerCallback } from ""@/types"";
import { useApi, integrationsStore, jobApiStore, projectStore } from ""@/hooks"";
import {
  getProjectInstallations,
  createGitHubProjectSync,
  createJiraProjectSync,
} from ""@/api"";
import { pinia } from ""@/plugins"";

export const useIntegrationsApi = defineStore(""integrationsApi"", () => {
  const integrationsApi = useApi(""integrationsApi"");

  const installations = ref<InstallationSchema[]>([]);

  /**
   * Handles loading installations affiliated with the current project.
   *
   * @param callbacks - Called once the action is complete.
   */
  async function handleReload(
    callbacks: IOHandlerCallback = {}
  ): Promise<void> {
    await integrationsApi.handleRequest(async () => {
      installations.value = await getProjectInstallations(
        projectStore.projectId
      );
    }, callbacks);
  }

  /**
   * Syncs the current project with the selected installation's data.
   *
   * @param installation - The installation to sync data with.
   * @param callbacks - Called once the action is complete.
   */
  async function handleSync(
    installation: Omit<InstallationSchema, ""lastUpdate"">,
    callbacks: IOHandlerCallback = {}
  ): Promise<void> {
    await integrationsApi.handleRequest(
      async () => {
        const job =
          installation.type === ""GITHUB""
            ? await createGitHubProjectSync(
                projectStore.versionId,
                installation.installationOrgId,
                installation.installationId,
                integrationsStore.gitHubConfig
              )
            : await createJiraProjectSync(
                projectStore.versionId,
                installation.installationOrgId,
                installation.installationId
              );

        await jobApiStore.handleCreate(job);
      },
      callbacks,
      {
        success: `Integration data is being synced: ${installation.installationId}. 
       You'll receive a notification once data has completed syncing.`,
        error: `Unable to sync integration data.`,
      }
    );
  }

  /**
   * Creates a sync with a new installation.
   *
   * @param installationType - The installation type to sync data with.
   * @param callbacks - Called once the action is complete.
   */
  async function handleNewSync(
    installationType?: ""Jira"" | ""GitHub"",
    callbacks: IOHandlerCallback = {}
  ): Promise<void> {
    await handleSync(
      installationType === ""Jira""
        ? {
            type: ""JIRA"",
            installationOrgId: integrationsStore.jiraOrganization?.id || """",
            installationId: integrationsStore.jiraProject?.id || """",
          }
        : {
            type: ""GITHUB"",
            installationOrgId: integrationsStore.gitHubOrganization?.id || """",
            installationId: integrationsStore.gitHubProject?.name || """",
          },
      callbacks
    );
  }

  return {
    installations,
    handleReload,
    handleSync,
    handleNewSync,
  };
});

export default useIntegrationsApi(pinia);
"
src/hooks/api/integrations/index.ts,"export { default as integrationsApiStore } from ""./useIntegrationsApi"";
export { default as gitHubApiStore } from ""./useGitHubApi"";
export { default as jiraApiStore } from ""./useJiraApi"";
"
src/hooks/api/version/useGetVersionApi.ts,"import { defineStore } from ""pinia"";

import { computed, ref, watch } from ""vue"";
import {
  DocumentSchema,
  IdentifierSchema,
  IOHandlerCallback,
  VersionSchema,
} from ""@/types"";
import {
  documentStore,
  projectStore,
  sessionStore,
  setProjectApiStore,
  useApi,
} from ""@/hooks"";
import { navigateTo, QueryParams, Routes, router } from ""@/router"";
import { getProjectVersion, getProjectVersions } from ""@/api"";
import { pinia } from ""@/plugins"";

export const useGetVersionApi = defineStore(""getVersionApi"", () => {
  const getVersionApi = useApi(""getVersionApi"");
  const loadVersionApi = useApi(""loadVersionApi"");

  const allVersions = ref<VersionSchema[]>([]);

  const getLoading = computed(() => getVersionApi.loading);
  const loadLoading = computed(() => loadVersionApi.loading);

  const currentProject = computed(() => projectStore.project);
  const currentVersion = computed({
    get: () => projectStore.version,
    set(version: VersionSchema | undefined) {
      if (!version) return;

      handleLoad(version.versionId);
    },
  });

  /**
   * Loads the versions of a project.
   * If no project id is given, the current project is used, and all versions will be set.
   *
   * @param projectId - The id of the project to load the versions of.
   * @param callbacks - Callbacks for the action.
   */
  async function handleReload(
    projectId?: string,
    callbacks: IOHandlerCallback<VersionSchema[]> = {}
  ): Promise<void> {
    const id = projectId || currentProject.value?.projectId;

    await getVersionApi.handleRequest(async () => {
      const versions = id ? await getProjectVersions(id) : [];

      if (!projectId) {
        allVersions.value = versions;
      }

      return versions;
    }, callbacks);
  }

  /**
   * Load the given project version.
   * Navigates to the artifact view page to show the loaded project.
   *
   * @param versionId - The id of the version to retrieve and load.
   * @param document - The document to start with viewing.
   * @param doNavigate - Whether to navigate to the artifact tree if not already on an artifact page.
   */
  async function handleLoad(
    versionId: string,
    document?: DocumentSchema,
    doNavigate = true
  ): Promise<void> {
    const routeRequiresProject = router.currentRoute.value.matched.some(
      ({ meta }) => meta.requiresProject
    );

    await loadVersionApi.handleRequest(
      async () => {
        sessionStore.updateSession({ versionId });

        const project = await getProjectVersion(versionId);

        if (
          project.projectVersion &&
          !allVersions.value.find(
            ({ versionId }) => versionId === project.projectVersion?.versionId
          )
        ) {
          // Add the current version to the list of versions if it is not already there.
          allVersions.value = [project.projectVersion, ...allVersions.value];
        }

        await setProjectApiStore.handleSet(project);

        if (document) {
          // If a document is given, switch to it.
          await documentStore.switchDocuments(document);
        }

        if (!doNavigate || routeRequiresProject) return;

        await navigateTo(Routes.ARTIFACT, {
          [QueryParams.VERSION]: versionId,
        });
      },
      {},
      { useAppLoad: true }
    );
  }

  /**
   * Load the current version of the given project.
   *
   * @param identifier - The project to load the current version of.
   */
  async function handleLoadCurrent(
    identifier: IdentifierSchema
  ): Promise<void> {
    const versions = await getProjectVersions(identifier.projectId);

    await handleLoad(versions[0].versionId);
  }

  // Load the versions of the current project whenever the current project changes.
  watch(
    () => currentProject.value,
    () => handleReload()
  );

  return {
    getLoading,
    loadLoading,
    allVersions,
    currentVersion,
    handleReload,
    handleLoad,
    handleLoadCurrent,
  };
});

export default useGetVersionApi(pinia);
"
src/hooks/api/version/useCreateVersionApi.ts,"import { defineStore } from ""pinia"";

import { computed } from ""vue"";
import { IOHandlerCallback, VersionSchema, VersionType } from ""@/types"";
import { jobApiStore, useApi } from ""@/hooks"";
import { navigateTo, Routes } from ""@/router"";
import {
  createFlatFileUploadJob,
  createMajorVersion,
  createMinorVersion,
  createRevisionVersion,
} from ""@/api"";
import { pinia } from ""@/plugins"";

export const useCreateVersionApi = defineStore(""createVersionApi"", () => {
  const createVersionApi = useApi(""createVersionApi"");

  const loading = computed(() => createVersionApi.loading);

  /**
   * Creates a new version.
   *
   * @param projectId - The project to create a version for.
   * @param versionType - The version type to create.
   * @param callbacks - The callbacks to use on success, error, and complete.
   */
  async function handleCreate(
    projectId: string,
    versionType: VersionType,
    callbacks: IOHandlerCallback<VersionSchema>
  ): Promise<void> {
    await createVersionApi.handleRequest(
      () => {
        if (versionType === ""major"") {
          return createMajorVersion(projectId);
        } else if (versionType === ""minor"") {
          return createMinorVersion(projectId);
        } else {
          return createRevisionVersion(projectId);
        }
      },
      callbacks,
      {
        useAppLoad: true,
        success: `Created a new version.`,
        error: ""Unable to create a new version."",
      }
    );
  }

  /**
   * Creates a new version for a project, uploading the files related to it.
   *
   * @param projectId - The project that has been selected by the user.
   * @param versionId - The version associated with given project to update.
   * @param selectedFiles  - The flat files that will update given version.
   * @param setVersionIfSuccessful - Whether the store should be set to the uploaded version if successful.
   * @param isCompleteSet - Whether to delete any other artifacts in the current version.
   */
  async function handleImport(
    projectId: string,
    versionId: string,
    selectedFiles: File[],
    setVersionIfSuccessful: boolean,
    isCompleteSet = false
  ): Promise<void> {
    await createVersionApi.handleRequest(
      async () => {
        const formData = new FormData();

        selectedFiles.forEach((file: File) => {
          formData.append(""files"", file);
        });

        formData.append(""isCompleteSet"", JSON.stringify(isCompleteSet));

        const job = await createFlatFileUploadJob(versionId, formData);

        await jobApiStore.handleCreate(job);
      },
      {
        onComplete: async () => {
          if (!setVersionIfSuccessful) return;

          await navigateTo(Routes.UPLOAD_STATUS);
        },
      },
      { useAppLoad: true }
    );
  }

  return {
    loading,
    handleReset: () => createVersionApi.handleReset(),
    handleCreate,
    handleImport,
  };
});

export default useCreateVersionApi(pinia);
"
src/hooks/api/version/index.ts,"export { default as createVersionApiStore } from ""./useCreateVersionApi"";
export { default as getVersionApiStore } from ""./useGetVersionApi"";
"
src/hooks/api/data/useWarningApi.ts,"import { defineStore } from ""pinia"";

import { useApi, warningStore } from ""@/hooks"";
import { getWarningsInProjectVersion } from ""@/api"";
import { pinia } from ""@/plugins"";

export const useWarningApi = defineStore(""warningApi"", () => {
  const warningApi = useApi(""warningApi"");

  /**
   * Call this function whenever warnings need to be re-downloaded.
   *
   * @param versionId - The project version to load from.
   */
  async function handleReload(versionId: string): Promise<void> {
    await warningApi.handleRequest(async () => {
      warningStore.artifactWarnings = await getWarningsInProjectVersion(
        versionId
      );
    });
  }

  return { handleReload };
});

export default useWarningApi(pinia);
"
src/hooks/api/data/useDocumentApi.ts,"import { defineStore } from ""pinia"";

import { DocumentType, IOHandlerCallback, DocumentSchema } from ""@/types"";
import { createDocument, preserveObjectKeys } from ""@/util"";
import {
  useApi,
  logStore,
  documentStore,
  projectStore,
  documentSaveStore,
} from ""@/hooks"";
import {
  saveDocument,
  deleteDocument,
  getDocuments,
  setCurrentDocument,
  clearCurrentDocument,
} from ""@/api"";
import { pinia } from ""@/plugins"";

const useDocumentApi = defineStore(""documentApi"", () => {
  const documentApi = useApi(""documentApi"");

  /**
   * Creates a new document and updates app state.
   *
   * @param name - The document name create.
   * @param type - The document type create.
   * @param artifactIds - The artifacts shown in the document.
   */
  async function handleCreate(
    name: string,
    type: DocumentType,
    artifactIds: string[]
  ): Promise<void> {
    await documentApi.handleRequest(async () => {
      const versionId = projectStore.versionIdWithLog;
      const createdDocument = await saveDocument(
        versionId,
        createDocument({
          project: preserveObjectKeys(projectStore.project, [
            ""name"",
            ""description"",
            ""projectId"",
            ""members"",
            ""owner"",
          ]),
          artifactIds,
          name,
          type,
        })
      );

      await setCurrentDocument(createdDocument.documentId);
      await documentStore.addDocument(createdDocument);
    });
  }

  /**
   * Creates a new document from an existing document and updates app state.
   *
   * @param document - The document to create.
   * @param callbacks - The callbacks to call on success, error, and complete.
   */
  async function handleCreatePreset(
    document: DocumentSchema,
    callbacks: IOHandlerCallback = {}
  ): Promise<void> {
    const { name, type, artifactIds } = document;

    await documentApi.handleRequest(
      async () => {
        await documentStore.removeDocument(document);
        await handleCreate(name, type, artifactIds);
      },
      callbacks,
      {
        useAppLoad: true,
        success: `Document has been created: ${name}`,
        error: `Cannot create document: ${name}`,
      }
    );
  }

  /**
   * Updates an existing document and updates app state.
   *
   * @param document - The document to edit.
   */
  async function handleUpdate(document: DocumentSchema): Promise<void> {
    await documentApi.handleRequest(async () => {
      const versionId = projectStore.versionIdWithLog;
      const updatedDocument = await saveDocument(versionId, document);

      await documentStore.updateDocuments([updatedDocument]);
    });
  }

  /**
   * Deletes the document and updates app state.
   * Switches documents if the current one has been deleted.
   *
   * @param callbacks - The callbacks to call on success, error, and complete.
   */
  function handleDelete(callbacks: IOHandlerCallback): void {
    const document = documentSaveStore.editedDocument;
    const { name } = document;

    logStore.confirm(
      ""Delete Document"",
      `Are you sure you want to delete the document ""${name}""?`,
      async (confirmed) => {
        if (!confirmed) return;

        await documentApi.handleRequest(
          async () => {
            await deleteDocument(document);
            await documentStore.removeDocument(document);
          },
          callbacks,
          {
            useAppLoad: true,
            success: `Document has been deleted: ${name}`,
            error: `Unable to delete document: ${name}`,
          }
        );
      }
    );
  }

  /**
   * Updates the artifact for the all documents.
   *
   * @param versionId - The project version to load documents for.
   * @param artifacts - The full list of artifacts.
   */
  async function handleReload(
    versionId = projectStore.versionId,
    artifacts = projectStore.project.artifacts
  ): Promise<void> {
    await documentApi.handleRequest(async () => {
      const documents = await getDocuments(versionId);

      await documentStore.updateDocuments(documents);

      documentStore.baseDocument.artifactIds = artifacts.map(({ id }) => id);
    });
  }

  /**
   * Creates or updates a document, updates app state, and logs the result.
   *
   * @param callbacks - The callbacks to call on success, error, and complete.
   */
  async function handleSave(callbacks: IOHandlerCallback): Promise<void> {
    const document = documentSaveStore.finalizedDocument;
    const isUpdate = documentSaveStore.isUpdate;
    const { name, type, artifactIds } = document;

    await documentApi.handleRequest(
      async () =>
        isUpdate
          ? handleUpdate(document)
          : handleCreate(name, type, artifactIds),
      callbacks,
      {
        useAppLoad: true,
        success: isUpdate
          ? `Document has been edited: ${name}`
          : `Document has been created: ${name}`,
        error: isUpdate
          ? `Unable to edit document: ${name}`
          : `Unable to create document: ${name}`,
      }
    );
  }

  /**
   * Switches documents and updates the currently saved document.
   *
   * @param document - The current document.
   */
  async function handleSwitch(document: DocumentSchema): Promise<void> {
    await documentApi.handleRequest(async () => {
      await documentStore.switchDocuments(document);

      if (document.documentId) {
        await setCurrentDocument(document.documentId);
      } else {
        await clearCurrentDocument();
      }
    });
  }

  return {
    handleCreate,
    handleCreatePreset,
    handleUpdate,
    handleDelete,
    handleReload,
    handleSave,
    handleSwitch,
  };
});

export default useDocumentApi(pinia);
"
src/hooks/api/data/useLayoutApi.ts,"import { defineStore } from ""pinia"";

import { IOHandlerCallback } from ""@/types"";
import { useApi, documentStore, logStore, projectStore } from ""@/hooks"";
import { createLayout } from ""@/api"";
import { pinia } from ""@/plugins"";

export const useLayoutApi = defineStore(""layoutApi"", () => {
  const layoutApi = useApi(""layoutApi"");

  /**
   * Handles regenerating and storing the layout for the current project version and document.
   *
   * @param callbacks - Callbacks to handle the result of the operation.
   */
  async function handleRegenerate(
    callbacks: IOHandlerCallback = {}
  ): Promise<void> {
    await layoutApi.handleRequest(
      async () => {
        const versionId = projectStore.versionId;
        const documentId = documentStore.currentId;

        logStore.onInfo(""Regenerating the current layout."");

        const generatedLayouts = await createLayout(versionId, documentId);

        if (!documentId) {
          // Update the default layout.
          documentStore.updateBaseLayout(
            generatedLayouts.defaultDocumentLayout
          );
        } else {
          // Update the current document layout.
          Object.entries(generatedLayouts.documentLayoutMap).forEach(
            ([documentId, layout]) =>
              documentStore.updateDocumentLayout(documentId, layout)
          );
        }
      },
      callbacks,
      {
        useAppLoad: true,
        success: ""The current layout has been updated."",
        error: ""Unable to update the current layout."",
      }
    );
  }

  return { handleRegenerate };
});

export default useLayoutApi(pinia);
"
src/hooks/api/data/useSearchApi.ts,"import { defineStore } from ""pinia"";

import { GraphMode } from ""@/types"";
import { createDocument } from ""@/util"";
import {
  useApi,
  documentStore,
  layoutStore,
  projectStore,
  searchStore,
} from ""@/hooks"";
import { getProjectSearchQuery } from ""@/api"";
import { pinia } from ""@/plugins"";

export const useSearchApi = defineStore(""searchApi"", () => {
  const searchApi = useApi(""searchApi"");

  /**
   * Handles searching a project, and updating the UI to display the search results.
   */
  async function handleSearch(): Promise<void> {
    await searchApi.handleRequest(
      async () => {
        const searchQuery = searchStore.searchQuery;

        layoutStore.mode = GraphMode.tree;

        const searchResults = await getProjectSearchQuery(
          projectStore.versionId,
          searchQuery
        );

        const document = createDocument({
          project: projectStore.projectIdentifier,
          name: searchQuery.prompt || ""Search Query"",
          artifactIds: searchResults.artifactIds,
        });

        await documentStore.addDocument(document);
      },
      {},
      { useAppLoad: true, error: ""Unable to display search results."" }
    );
  }

  return { handleSearch };
});

export default useSearchApi(pinia);
"
src/hooks/api/data/useTraceMatrixApi.ts,"import { defineStore } from ""pinia"";

import { useApi, projectStore, timStore } from ""@/hooks"";
import { createTraceMatrix, deleteTraceMatrix } from ""@/api"";
import { pinia } from ""@/plugins"";

export const useTraceMatrixApi = defineStore(""traceMatrixApi"", () => {
  const traceMatrixApi = useApi(""traceMatrixApi"");

  /**
   * Creates traces from the given source to target artifact types.
   *
   * @param sourceTypeName - The source artifact type name.
   * @param targetTypeName - The target artifact type name.
   */
  async function handleCreate(
    sourceTypeName: string,
    targetTypeName: string
  ): Promise<void> {
    await traceMatrixApi.handleRequest(
      async () => {
        await createTraceMatrix(
          projectStore.versionId,
          sourceTypeName,
          targetTypeName
        );

        timStore.addTraceMatrix(sourceTypeName, targetTypeName);
      },
      {},
      {
        success: `Created trace matrix: ${sourceTypeName} -> ${targetTypeName}`,
        error: `Unable to create trace matrix: ${sourceTypeName} -> ${targetTypeName}`,
      }
    );
  }

  /**
   * Removes traces from the given source to target artifact types.
   *
   * @param sourceTypeName - The source artifact type name.
   * @param targetTypeName - The target artifact type name.
   */
  async function handleDeleteTypes(
    sourceTypeName: string,
    targetTypeName: string
  ): Promise<void> {
    await traceMatrixApi.handleRequest(
      async () => {
        await deleteTraceMatrix(
          projectStore.versionId,
          sourceTypeName,
          targetTypeName
        );

        timStore.deleteTraceMatrix(sourceTypeName, targetTypeName);
      },
      {},
      {
        success: `Deleted trace matrix: ${sourceTypeName} -> ${targetTypeName}`,
        error: `Unable to delete trace matrix: ${sourceTypeName} -> ${targetTypeName}`,
      }
    );
  }

  return {
    handleCreate,
    handleDeleteTypes,
  };
});

export default useTraceMatrixApi(pinia);
"
src/hooks/api/data/useTraceApi.ts,"import { defineStore } from ""pinia"";

import { computed, ref } from ""vue"";
import {
  ArtifactSchema,
  ArtifactCytoElementData,
  ApprovalType,
  TraceLinkSchema,
  TraceType,
  IOHandlerCallback,
} from ""@/types"";
import {
  useApi,
  logStore,
  traceStore,
  approvalStore,
  traceCommitApiStore,
  subtreeStore,
  traceSaveStore,
} from ""@/hooks"";
import { pinia } from ""@/plugins"";

export const useTraceApi = defineStore(""traceApi"", () => {
  const createTraceApi = useApi(""traceApi"");
  const approveTraceApi = useApi(""approveTraceApi"");
  const unreviewTraceApi = useApi(""unreviewTraceApi"");
  const declineTraceApi = useApi(""declineTraceApi"");

  const createLoading = computed(() => createTraceApi.loading);
  const approveLoading = computed(() => approveTraceApi.loading);
  const unreviewLoading = computed(() => unreviewTraceApi.loading);
  const declineLoading = computed(() => declineTraceApi.loading);

  const loadingTraceIds = ref<string[]>([]);
  const loadTrace = (traceId: string) =>
    (loadingTraceIds.value = [...loadingTraceIds.value, traceId]);
  const unloadTrace = (traceId: string) =>
    (loadingTraceIds.value = loadingTraceIds.value.filter(
      (id) => id !== traceId
    ));

  /**
   * Creates a new trace link.
   *
   * @param source - The artifact to link from.
   * @param target - The artifact to link to.
   * @param callbacks - The callbacks to call after the action.
   */
  async function handleCreate(
    source: ArtifactSchema | ArtifactCytoElementData,
    target: ArtifactSchema | ArtifactCytoElementData,
    callbacks: IOHandlerCallback = {}
  ): Promise<void> {
    const sourceName =
      ""artifactName"" in source ? source.artifactName : source.name;
    const targetName =
      ""artifactName"" in target ? target.artifactName : target.name;

    const traceLink: TraceLinkSchema = {
      traceLinkId: """",
      sourceId: source.id,
      sourceName,
      targetId: target.id,
      targetName,
      traceType: TraceType.MANUAL,
      approvalStatus: ApprovalType.APPROVED,
      score: 1,
    };

    await createTraceApi.handleRequest(
      async () => {
        const createdLinks = await traceCommitApiStore.handleCreate(traceLink);

        traceStore.addOrUpdateTraceLinks(createdLinks);
        subtreeStore.addTraceSubtree(traceLink);
      },
      callbacks,
      {
        success: `Created a new trace link: ${sourceName} -> ${targetName}`,
        error: `Unable to create trace link: ${sourceName} -> ${targetName}`,
      }
    );
  }

  /**
   * Creates a new trace link between all source to all target artifacts in the saved trace store.
   */
  async function handleCreateAll(): Promise<void> {
    for (const target of traceSaveStore.targets) {
      for (const source of traceSaveStore.sources) {
        if (!source || !target) continue;

        await handleCreate(source, target);
      }
    }
  }

  /**
   * Processes link approvals, setting the app state to loading in between, and updating trace links afterwards.
   *
   * @param traceLink - The trace link to process.
   * @param callbacks - The callbacks to call after the action.
   */
  async function handleApprove(
    traceLink: TraceLinkSchema,
    callbacks: IOHandlerCallback
  ): Promise<void> {
    await approveTraceApi.handleRequest(
      async () => {
        loadTrace(traceLink.traceLinkId);

        const updatedLinks = await traceCommitApiStore.handleApprove(traceLink);

        traceStore.addOrUpdateTraceLinks(updatedLinks);
        approvalStore.approveLink(traceLink);
      },
      {
        ...callbacks,
        onComplete: () => {
          unloadTrace(traceLink.traceLinkId);
          callbacks.onComplete?.();
        },
      },
      {
        success: `Trace link approved: ${traceLink.sourceName} -> ${traceLink.targetName}`,
        error: `Unable to approve trace link: ${traceLink.sourceName} -> ${traceLink.targetName}`,
      }
    );
  }

  /**
   * Processes link declines, setting the app state to loading in between, and updating trace links afterwards.
   *
   * @param traceLink - The trace link to process.
   * @param callbacks - The callbacks to call after the action.
   */
  async function handleDecline(
    traceLink: TraceLinkSchema,
    callbacks: IOHandlerCallback
  ): Promise<void> {
    await declineTraceApi.handleRequest(
      async () => {
        loadTrace(traceLink.traceLinkId);

        const updatedLinks = await traceCommitApiStore.handleDecline(traceLink);

        traceStore.deleteTraceLinks(updatedLinks);
        approvalStore.declineLink(traceLink);
        subtreeStore.deleteTraceSubtree(traceLink);
      },
      {
        ...callbacks,
        onComplete: () => {
          unloadTrace(traceLink.traceLinkId);
          callbacks.onComplete?.();
        },
      },
      {
        success: `Trace link declined: ${traceLink.sourceName} -> ${traceLink.targetName}`,
        error: `Unable to decline trace link: ${traceLink.sourceName} -> ${traceLink.targetName}`,
      }
    );
  }

  /**
   * Declines all unreviewed links, setting the app state to loading in between, and updating trace links.
   */
  async function handleDeclineAll(): Promise<void> {
    await logStore.confirm(
      ""Clear Unreviewed Links"",
      ""Are you sure you want to remove all unreviewed links?"",
      async (isConfirmed) => {
        if (!isConfirmed) return;

        const unreviewed = approvalStore.unreviewedLinks;

        await declineTraceApi.handleRequest(
          async () => {
            await traceCommitApiStore.handleDeclineAll(unreviewed);

            traceStore.deleteTraceLinks(unreviewed);
            unreviewed.map((link) => approvalStore.declineLink(link));
          },
          {
            onError: () =>
              unreviewed.map(
                (link) => (link.approvalStatus = ApprovalType.UNREVIEWED)
              ),
          },
          {
            useAppLoad: true,
            success: `Removed unreviewed trace links: ${unreviewed.length}`,
            error: `Unable to clear unreviewed trace links: ${unreviewed.length}`,
          }
        );
      }
    );
  }

  /**
   * Processes link unreview, setting the app state to loading in between, and updating trace links afterwards.
   *
   * @param traceLink - The trace link to process.
   * @param callbacks - The callbacks to call after the action.
   */
  async function handleUnreview(
    traceLink: TraceLinkSchema,
    callbacks: IOHandlerCallback
  ): Promise<void> {
    await unreviewTraceApi.handleRequest(
      async () => {
        loadTrace(traceLink.traceLinkId);

        const updatedLinks = await traceCommitApiStore.handleUnreview(
          traceLink
        );

        traceStore.addOrUpdateTraceLinks(updatedLinks);
        approvalStore.resetLink(traceLink);
      },
      {
        ...callbacks,
        onComplete: () => {
          unloadTrace(traceLink.traceLinkId);
          callbacks.onComplete?.();
        },
      },
      {
        useAppLoad: true,
        success: `Trace link unreviewed: ${traceLink.sourceName} -> ${traceLink.targetName}`,
        error: `Unable to unreview trace link: ${traceLink.sourceName} -> ${traceLink.targetName}`,
      }
    );
  }

  /**
   * Deletes a trace link after confirmation.
   *
   * @param traceLink - The trace link to delete.
   * @param callbacks - The callbacks to call after the action.
   */
  async function handleDelete(
    traceLink: TraceLinkSchema,
    callbacks: IOHandlerCallback
  ): Promise<void> {
    logStore.confirm(
      ""Delete Trace Link"",
      `Are you sure you want to delete ""${traceLink.sourceName} -> ${traceLink.targetName}""?`,
      async (confirmed) => {
        if (!confirmed) return;

        await handleDecline(traceLink, callbacks);
      }
    );
  }

  return {
    loadingTraceIds,
    createLoading,
    approveLoading,
    declineLoading,
    unreviewLoading,
    handleCreate,
    handleCreateAll,
    handleApprove,
    handleDecline,
    handleDeclineAll,
    handleUnreview,
    handleDelete,
  };
});

export default useTraceApi(pinia);
"
src/hooks/api/data/useArtifactApi.ts,"import { defineStore } from ""pinia"";

import { computed, ref, watch } from ""vue"";
import { ArtifactSchema, IOHandlerCallback } from ""@/types"";
import {
  useApi,
  artifactStore,
  logStore,
  projectStore,
  traceApiStore,
  traceStore,
  artifactCommitApiStore,
  artifactSaveStore,
} from ""@/hooks"";
import { getDoesArtifactExist } from ""@/api"";
import { pinia } from ""@/plugins"";

export const useArtifactApi = defineStore(""artifactApi"", () => {
  const artifactSaveApi = useApi(""artifactSaveApi"");
  const artifactDeleteApi = useApi(""artifactDeleteApi"");
  const artifactNameApi = useApi(""artifactNameApi"");

  const nameCheckTimer = ref<ReturnType<typeof setTimeout> | undefined>();
  const nameLoading = ref(false);

  const saveLoading = computed(() => artifactSaveApi.loading);
  const deleteLoading = computed(() => artifactDeleteApi.loading);

  const nameError = computed(() =>
    nameLoading.value ? false : artifactSaveStore.nameError
  );

  /**
   * Verifies that the edited artifact's name is unique.
   */
  async function handleCheckName(): Promise<void> {
    await artifactNameApi.handleRequest(async () => {
      const name = artifactSaveStore.editedArtifact.name || """";

      if (nameCheckTimer.value) {
        clearTimeout(nameCheckTimer.value);
      }

      artifactSaveStore.isNameValid = false;
      nameLoading.value = true;

      nameCheckTimer.value = setTimeout(() => {
        if (!name) {
          artifactSaveStore.isNameValid = false;
          nameLoading.value = false;
        } else if (!artifactSaveStore.hasNameChanged) {
          artifactSaveStore.isNameValid = true;
          nameLoading.value = false;
        } else {
          getDoesArtifactExist(projectStore.versionId, name)
            .then((nameExists) => {
              artifactSaveStore.isNameValid = !nameExists;
              nameLoading.value = false;
            })
            .catch(() => {
              artifactSaveStore.isNameValid = false;
              nameLoading.value = false;
            });
        }
      }, 500);
    });
  }

  /**
   * Creates or updates an artifact, and updates app state.
   *
   * @param artifact - The artifact to create.
   * @param isUpdate - Whether this operation should label this commit as
   * updating a previously existing artifact.
   * @param parentArtifact - The parent artifact to link to.
   * @param callbacks - Callbacks to run after the action.
   */
  async function handleSave(
    artifact: ArtifactSchema,
    isUpdate: boolean,
    parentArtifact: ArtifactSchema | undefined,
    callbacks: IOHandlerCallback = {}
  ): Promise<void> {
    await artifactSaveApi.handleRequest(
      async () => {
        const versionId = projectStore.versionIdWithLog;

        if (isUpdate) {
          const updatedArtifacts = await artifactCommitApiStore.handleUpdate(
            versionId,
            artifact
          );

          artifactStore.addOrUpdateArtifacts(updatedArtifacts);
        } else {
          const createdArtifacts = await artifactCommitApiStore.handleCreate(
            versionId,
            artifact
          );

          artifactStore.addCreatedArtifact(createdArtifacts[0]);

          if (parentArtifact) {
            for (const createdArtifact of createdArtifacts) {
              await traceApiStore.handleCreate(createdArtifact, parentArtifact);
            }
          }
        }
      },
      callbacks,
      {
        success: isUpdate
          ? `Edited artifact: ${artifact.name}`
          : `Created a new artifact: ${artifact.name}`,
        error: `Unable to save artifact: ${artifact.name}`,
      }
    );
  }

  /**
   * Duplicates an artifact, and updates the app state.
   *
   * @param artifact  - The artifact to duplicate.
   * @param callbacks - Callbacks to run after the action.
   */
  function handleDuplicate(
    artifact: ArtifactSchema,
    callbacks: IOHandlerCallback = {}
  ): Promise<void> {
    return handleSave(
      {
        ...artifact,
        name: artifact.name + "" (Copy)"",
        id: """",
        baseEntityId: """",
      },
      false,
      undefined,
      callbacks
    );
  }

  /**
   * Deletes an artifact, and updates the app state.
   *
   * @param artifact  - The artifact to delete.
   * @param callbacks - Callbacks to run after the action.
   */
  function handleDelete(
    artifact: ArtifactSchema,
    callbacks: IOHandlerCallback = {}
  ): void {
    logStore.confirm(
      ""Delete Artifact"",
      `Are you sure you would like to delete ""${artifact.name}""?`,
      async (isConfirmed: boolean) => {
        if (!isConfirmed) return;

        const relatedTraces = traceStore.allTraces.filter(
          ({ sourceId, targetId }) =>
            sourceId === artifact.id || targetId === artifact.id
        );

        await artifactDeleteApi.handleRequest(
          async () => {
            await artifactCommitApiStore.handleDelete(artifact, relatedTraces);

            artifactStore.deleteArtifacts([artifact]);
            traceStore.deleteTraceLinks(relatedTraces);
          },
          callbacks,
          {
            success: `Deleted artifact: ${artifact.name}`,
            error: `Unable to delete artifact: ${artifact.name}`,
          }
        );
      }
    );
  }

  // Check the name is unique when the artifact name is edited.
  watch(
    () => artifactSaveStore.editedArtifact.name,
    () => handleCheckName()
  );

  // Update the artifact type when the artifact type is edited.
  watch(
    () => artifactSaveStore.editedArtifact.type,
    () => artifactSaveStore.updateArtifactType()
  );

  return {
    saveLoading,
    deleteLoading,
    nameLoading,
    nameError,
    handleSave,
    handleDuplicate,
    handleDelete,
  };
});

export default useArtifactApi(pinia);
"
src/hooks/api/data/useDeltaApi.ts,"import { defineStore } from ""pinia"";

import { computed } from ""vue"";
import { IOHandlerCallback, VersionSchema } from ""@/types"";
import { useApi, deltaStore, projectStore, getVersionApiStore } from ""@/hooks"";
import { getProjectDelta } from ""@/api"";
import { pinia } from ""@/plugins"";

export const useDeltaApi = defineStore(""deltaApi"", () => {
  const deltaApi = useApi(""deltaApi"");

  const loading = computed(() => deltaApi.loading);

  const deltaVersions = computed(() => {
    const currentVersionId = projectStore.version?.versionId;

    return getVersionApiStore.allVersions.filter(
      ({ versionId }) => versionId !== currentVersionId
    );
  });

  /**
   * Sets a project delta.
   *
   * @param targetVersion - The target version of the project.
   * @param callbacks - Callbacks for the request.
   */
  async function handleCreate(
    targetVersion?: VersionSchema,
    callbacks: IOHandlerCallback = {}
  ): Promise<void> {
    await deltaApi.handleRequest(
      async () => {
        if (!targetVersion || !projectStore.version) return;

        const delta = await getProjectDelta(
          projectStore.version.versionId,
          targetVersion.versionId
        );

        await deltaStore.setDeltaPayload(delta, targetVersion);
      },
      callbacks,
      {
        success: ""Delta state was updated successfully."",
        error: ""Unable to set delta state."",
      }
    );
  }

  return { loading, deltaVersions, handleCreate };
});

export default useDeltaApi(pinia);
"
src/hooks/api/data/useArtifactTypeApi.ts,"import { defineStore } from ""pinia"";

import { ArtifactTypeSchema } from ""@/types"";
import { useApi, projectStore, timStore } from ""@/hooks"";
import { pinia } from ""@/plugins"";
import { createArtifactType, editArtifactType } from ""@/api/endpoints"";

export const useArtifactTypeApi = defineStore(""artifactTypeApi"", () => {
  const artifactTypeApi = useApi(""artifactTypeApi"");

  /**
   * Creates or updates the given artifact type.
   *
   * @param artifactType - The artifact type to add or edit.
   */
  async function handleSave(artifactType: ArtifactTypeSchema): Promise<void> {
    await artifactTypeApi.handleRequest(
      async () => {
        const updatedArtifactType = artifactType.typeId
          ? await editArtifactType(projectStore.projectId, artifactType)
          : await createArtifactType(projectStore.projectId, artifactType);

        timStore.addOrUpdateArtifactTypes([updatedArtifactType]);
      },
      {},
      {
        success: `Saved artifact type: ${artifactType.name}`,
        error: `Unable to save artifact type: ${artifactType.name}`,
      }
    );
  }

  return { handleSave };
});

export default useArtifactTypeApi(pinia);
"
src/hooks/api/data/index.ts,"export { default as warningApiStore } from ""./useWarningApi"";
export { default as artifactApiStore } from ""./useArtifactApi"";
export { default as artifactTypeApiStore } from ""./useArtifactTypeApi"";
export { default as traceApiStore } from ""./useTraceApi"";
export { default as traceMatrixApiStore } from ""./useTraceMatrixApi"";
export { default as layoutApiStore } from ""./useLayoutApi"";
export { default as documentApiStore } from ""./useDocumentApi"";
export { default as searchApiStore } from ""./useSearchApi"";
export { default as deltaApiStore } from ""./useDeltaApi"";
"
src/hooks/api/notifications/useStompApi.ts,"import { defineStore } from ""pinia"";
import { ref } from ""vue"";
import SockJS from ""sockjs-client"";
import Stomp, { Client, Message, Subscription } from ""webstomp-client"";

import { logStore } from ""@/hooks"";
import {
  MAX_RECONNECT_ATTEMPTS,
  RECONNECT_WAIT_TIME,
  WEBSOCKET_URL,
} from ""@/api"";
import { pinia } from ""@/plugins"";

/**
 * The singleton client for connecting to the backend websocket server.
 */
export const useStompApi = defineStore(""stompApi"", () => {
  const stompClient = ref<Client>();
  const socket = ref<WebSocket>();
  const reconnectInterval = ref<NodeJS.Timeout>();
  const reconnectAttempts = ref(0);

  /**
   * Returns the current stomp client, creating one if none exists.
   *
   * @param reconnect - Whether to create a new connection regardless
   * of websocket state.
   * @throws If unable to connect to the server.
   * @return The stomp client.
   */
  function getStomp(reconnect = false): Client | undefined {
    if (
      socket.value === undefined ||
      stompClient.value === undefined ||
      reconnect
    ) {
      try {
        socket.value = new SockJS(WEBSOCKET_URL(), { DEBUG: false });
        socket.value.onclose = () => {
          logStore.onDevInfo(""Closing WebSocket."");
          connectStomp().then();
        };
        stompClient.value = Stomp.over(socket.value, { debug: false });
      } catch (e) {
        if (!reconnect) {
          throw e;
        }
      }
    }

    return stompClient.value;
  }

  /**
   * Connects to BEND websocket server and tries to reconnect if
   * the connection fails.
   *
   * @param maxReconnectAttempts - The number of times to reconnect before failing.
   * @param reconnectWaitTime - The number of milliseconds to wait before reconnecting.
   * @param isReconnect - Whether this is a reconnect attempt.
   */
  function connectStomp(
    maxReconnectAttempts: number = MAX_RECONNECT_ATTEMPTS,
    reconnectWaitTime: number = RECONNECT_WAIT_TIME,
    isReconnect = false
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      const stomp = getStomp(isReconnect);

      if (!stomp) return;

      if (stomp.connected) {
        logStore.onDevInfo(""Client is connected to WebSocket."");
        clearInterval(reconnectInterval.value);
        return resolve();
      }

      if (reconnectAttempts.value > 0) {
        logStore.onDevInfo(
          `Websocket reconnect attempt:${reconnectAttempts.value}`
        );
      }

      reconnectAttempts.value++;

      stomp.connect(
        { host: WEBSOCKET_URL() },
        () => {
          logStore.onDevInfo(
            ""Websocket connection successful. "" +
              `Subscriptions: ${JSON.stringify(stomp.subscriptions)}`
          );

          clearInterval(reconnectInterval.value);

          reconnectAttempts.value = 0;
          resolve();
        },
        () => {
          logStore.onDevInfo(""Re-connecting with WebSocket."");

          clearInterval(reconnectInterval.value);

          reconnectInterval.value = setInterval(function () {
            if (reconnectAttempts.value < maxReconnectAttempts) {
              connectStomp(maxReconnectAttempts, reconnectWaitTime, true)
                .then(resolve)
                .catch(reject);
            } else {
              clearInterval(reconnectInterval.value);

              const error =
                ""Web Socket lost connection to server, please reload page."";
              logStore.onDevError(error);
              reject(error);
            }
          }, reconnectWaitTime);
        }
      );
    });
  }

  /**
   * Subscribes to a websocket destination and returns the subscription.
   *
   * @param destination - The destination url to subscribe to.
   * @param callback - The callback to run when a message is received.
   */
  async function subscribeToStomp(
    destination: string,
    callback?: (message: Message) => void
  ): Promise<Subscription | undefined> {
    await connectStomp();

    const stomp = getStomp();

    if (!stomp) return;

    return stomp.subscribe(destination, callback);
  }

  /**
   * Clears all subscriptions of the current user.
   */
  function clearStompSubscriptions(): void {
    const stomp = getStomp();

    if (!stomp) return;

    const subscriptionIds = Object.keys(stomp.subscriptions);

    subscriptionIds.forEach((subId) => stomp.unsubscribe(subId));
  }

  return {
    getStomp,
    connectStomp,
    subscribeToStomp,
    clearStompSubscriptions,
  };
});

export default useStompApi(pinia);
"
src/hooks/api/notifications/useJobApi.ts,"import { defineStore } from ""pinia"";

import { ref } from ""vue"";
import {
  ChangeMessageSchema,
  IOHandlerCallback,
  JobLogSchema,
  JobSchema,
} from ""@/types"";
import { jobStore, useApi } from ""@/hooks"";
import {
  deleteJobById,
  Endpoint,
  fillEndpoint,
  getJobLog,
  getUserJobs,
} from ""@/api"";
import { pinia } from ""@/plugins"";
import stompApiStore from ""./useStompApi"";

export const useJobApi = defineStore(""jobApi"", () => {
  const jobApi = useApi(""jobApi"");

  const jobLog = ref<JobLogSchema[][]>([]);
  const jobSteps = ref<string[]>([]);

  /**
   * Gets the log for a job.
   * @param job - The job to view.
   */
  async function handleViewLogs(job: JobSchema): Promise<void> {
    await jobApi.handleRequest(async () => {
      jobLog.value = await getJobLog(job.id);
      jobSteps.value = job.steps;
    });
  }

  /**
   * Closes the job log.
   */
  function handleCloseLogs(): void {
    jobLog.value = [];
    jobSteps.value = [];
  }

  /**
   * Subscribes to updates for job with given id.
   *
   * @param jobId - The id for the job whose updates we want to process.
   */
  async function subscribeToJob(jobId: string): Promise<void> {
    if (!jobId) return;

    await stompApiStore.subscribeToStomp(
      fillEndpoint(Endpoint.jobTopic, { jobId }),
      async (frame) => {
        await jobApi.handleRequest(async () => {
          const job: JobSchema | ChangeMessageSchema = JSON.parse(frame.body);

          if (!(""status"" in job)) return;

          jobStore.updateJob(job);
        });
      }
    );
  }

  /**
   * Subscribes to job updates via websocket messages, updates the
   * store, and selects the job.
   */
  async function handleCreate(job: JobSchema): Promise<void> {
    await subscribeToJob(job.id);
    jobStore.updateJob(job);
    jobStore.selectedJob = job;
  }

  /**
   * Deletes a job.
   *
   * @param job - The job to delete.
   * @param callbacks - The callbacks to run on success or error.
   */
  async function handleDelete(
    job: JobSchema,
    callbacks: IOHandlerCallback
  ): Promise<void> {
    await jobApi.handleRequest(() => deleteJobById(job.id), {
      ...callbacks,
      onSuccess: () => {
        jobStore.deleteJob(job);
        callbacks.onSuccess?.();
      },
    });
  }

  /**
   * Reloads the current list of jobs.
   */
  async function handleReload(): Promise<void> {
    await jobApi.handleRequest(
      async () => {
        const jobs = await getUserJobs();

        for (const job of jobs) {
          await subscribeToJob(job.id);
        }

        jobStore.jobs = jobs;

        if (jobs.length === 0) return;

        jobStore.selectedJob = jobs[0];
      },
      {},
      { useAppLoad: true }
    );
  }

  return {
    jobLog,
    jobSteps,
    handleViewLogs,
    handleCloseLogs,
    handleCreate,
    handleDelete,
    handleReload,
  };
});

export default useJobApi(pinia);
"
src/hooks/api/notifications/useNotificationApi.ts,"import { defineStore } from ""pinia"";
import { Frame } from ""webstomp-client"";

import {
  ActionType,
  ChangeMessageSchema,
  ChangeSchema,
  EntityType,
  notifyUserEntities,
  ProjectSchema,
} from ""@/types"";
import {
  appStore,
  artifactStore,
  attributesStore,
  documentStore,
  jobStore,
  membersStore,
  projectStore,
  subtreeStore,
  traceStore,
  logStore,
  stompApiStore,
  setProjectApiStore,
  getVersionApiStore,
  jobApiStore,
  warningApiStore,
  timStore,
} from ""@/hooks"";
import { router } from ""@/router"";
import { Endpoint, fillEndpoint, getChanges } from ""@/api"";
import { pinia } from ""@/plugins"";

export const useNotificationApi = defineStore(""notificationApi"", () => {
  /**
   * Deletes stored project information.
   *
   * @param change - The deletion change.
   */
  async function handleDeleteChange(change: ChangeSchema) {
    switch (change.entity) {
      case EntityType.PROJECT:
        // (entityIds.length should be 1 and equal to projectId)
        if (change.entityIds[0] !== projectStore.projectId) return;

        return setProjectApiStore.handleClear();
      case EntityType.MEMBERS:
        // (entityIds = projectMembershipsIds)
        membersStore.deleteMembers(change.entityIds);
        break;
      case EntityType.VERSION:
        // (entityIds = project version id)
        if (change.entityIds[0] !== projectStore.versionId) return;

        return setProjectApiStore.handleClear();
      case EntityType.TYPES:
        // (entityIds = type id)
        timStore.deleteArtifactTypes(change.entityIds);
        break;
      case EntityType.TRACE_MATRICES:
        timStore.deleteTraceMatrices(change.entityIds);
        break;
      case EntityType.DOCUMENT:
        // (entityIds = document id)
        change.entityIds.forEach((id) => documentStore.removeDocument(id));
        break;
      case EntityType.ARTIFACTS:
        // (entityIds = artifact ids)
        artifactStore.deleteArtifacts(change.entityIds);
        break;
      case EntityType.TRACES:
        // (entityIds = trace link ids)
        traceStore.deleteTraceLinks(change.entityIds);
        break;
      case EntityType.WARNINGS:
        // Never called, case here for completion.
        break;
      case EntityType.JOBS:
        // (entityIds = jobId)
        change.entityIds.forEach((id) => jobStore.deleteJob(id));
        break;
      case EntityType.LAYOUT:
        // Never called, case here for completion.
        break;
      case EntityType.MODELS:
        // (entityIds = modelIds)
        projectStore.updateProject({
          models: projectStore.models.filter(
            ({ id }) => !change.entityIds.includes(id)
          ),
        });
        break;
      case EntityType.ATTRIBUTES:
        // (entityIds = attribute keys)
        attributesStore.deleteAttributes(change.entityIds);
        break;
      case EntityType.ATTRIBUTE_LAYOUTS:
        // (entityIds = attribute layout ids)
        attributesStore.deleteAttributeLayouts(change.entityIds);
        break;
    }
  }

  /**
   * Updates stored project information.
   *
   * @param change - The update change.
   * @param project - The updated project.
   */
  async function handleUpdateChange(
    change: ChangeSchema,
    project: ProjectSchema
  ) {
    const versionId = projectStore.versionId;

    switch (change.entity) {
      case EntityType.PROJECT:
        projectStore.updateProject({
          name: project.name,
          description: project.description,
        });
        break;
      case EntityType.MEMBERS:
        membersStore.updateMembers(project.members);
        break;
      case EntityType.VERSION:
        return getVersionApiStore.handleLoad(versionId);
      case EntityType.TYPES:
        timStore.addOrUpdateArtifactTypes(project.artifactTypes);
        break;
      case EntityType.TRACE_MATRICES:
        timStore.addOrUpdateTraceMatrices(project.traceMatrices);
        break;
      case EntityType.DOCUMENT:
        await documentStore.updateDocuments(project.documents);
        break;
      case EntityType.ARTIFACTS:
        artifactStore.addOrUpdateArtifacts(project.artifacts);
        break;
      case EntityType.TRACES:
        traceStore.addOrUpdateTraceLinks(project.traces);
        break;
      case EntityType.WARNINGS:
        return warningApiStore.handleReload(versionId);
      case EntityType.JOBS:
        return jobApiStore.handleReload();
      case EntityType.LAYOUT:
        documentStore.updateBaseLayout(project.layout);
        break;
      case EntityType.SUBTREES:
        subtreeStore.initializeProject(project);
        break;
      case EntityType.MODELS:
        projectStore.updateProject({ models: project.models });
        break;
      case EntityType.ATTRIBUTES:
        attributesStore.updateAttributes(project.attributes || []);
        break;
      case EntityType.ATTRIBUTE_LAYOUTS:
        attributesStore.updateAttributeLayouts(project.attributeLayouts || []);
        break;
    }
  }

  /**
   * Handles changes messages by updating affected parts of the app.
   *
   * @param versionId - The project version being updated.
   * @param frame - The message describing changes.
   */
  async function handleEntityChangeMessage(
    versionId: string,
    frame: Frame
  ): Promise<void> {
    const routeRequiresProject = router.currentRoute.value.matched.some(
      ({ meta }) => meta.requiresProject
    );
    const message: ChangeMessageSchema = JSON.parse(frame.body);
    const project = await getChanges(versionId, message);
    let hasLayoutChange = false;

    // Step - Iterate through message and delete entities.
    for (const change of message.changes) {
      if (!notifyUserEntities.includes(change.entity)) return;

      if (change.action === ActionType.DELETE) {
        await handleDeleteChange(change);
      } else if (change.action === ActionType.UPDATE) {
        await handleUpdateChange(change, project);

        if (change.entity === EntityType.ARTIFACTS) {
          hasLayoutChange = true;
        }
      }
    }

    // Step - Update default layout if needed.
    if (!routeRequiresProject || !hasLayoutChange) return;

    appStore.enqueueChanges(async () => {
      documentStore.updateBaseLayout(project.layout);
    });
  }

  /**
   * Connects and subscribes to the given project and version.
   *
   * @param projectId - The project ID to connect to.
   * @param versionId - The project version ID to connect to.
   */
  async function handleSubscribeVersion(
    projectId: string,
    versionId: string
  ): Promise<void> {
    if (!projectId || !versionId) return;

    await stompApiStore.connectStomp();

    stompApiStore.clearStompSubscriptions();

    await stompApiStore.subscribeToStomp(
      fillEndpoint(Endpoint.projectTopic, { projectId }),
      (frame) =>
        handleEntityChangeMessage(versionId, frame).catch((e) =>
          logStore.onError(e)
        )
    );

    await stompApiStore.subscribeToStomp(
      fillEndpoint(Endpoint.versionTopic, { versionId }),
      (frame) =>
        handleEntityChangeMessage(versionId, frame).catch((e) =>
          logStore.onError(e)
        )
    );
  }

  return { handleSubscribeVersion };
});

export default useNotificationApi(pinia);
"
src/hooks/api/notifications/index.ts,"export { default as stompApiStore } from ""./useStompApi"";
export { default as jobApiStore } from ""./useJobApi"";
export { default as notificationApiStore } from ""./useNotificationApi"";
"
src/hooks/api/generation/useArtifactGenerationApi.ts,"import { defineStore } from ""pinia"";

import { computed, ref } from ""vue"";
import {
  GenerateArtifactSchema,
  IOHandlerCallback,
  ArtifactSchema,
  ArtifactSummaryConfirmation,
} from ""@/types"";
import {
  useApi,
  projectStore,
  artifactSaveStore,
  artifactApiStore,
  jobStore,
} from ""@/hooks"";
import { createGeneratedArtifacts, createPrompt, createSummary } from ""@/api"";
import { pinia } from ""@/plugins"";

export const useArtifactGenerationApi = defineStore(
  ""artifactGenerationApi"",
  () => {
    const nameGenerationApi = useApi(""nameGenerationApi"");
    const bodyGenerationApi = useApi(""bodyGenerationApi"");
    const summaryGenerationApi = useApi(""summaryGenerationApi"");
    const artifactGenerationApi = useApi(""artifactGenerationApi"");

    const summaryGenConfirm = ref<ArtifactSummaryConfirmation | undefined>(
      undefined
    );

    const nameGenLoading = computed(() => nameGenerationApi.loading);
    const bodyGenLoading = computed(() => bodyGenerationApi.loading);
    const summaryGenLoading = computed(() => summaryGenerationApi.loading);
    const artifactGenLoading = computed(() => artifactGenerationApi.loading);

    /**
     * Generates a summary for an artifact, and updates the app state.
     *
     * @param artifact - The artifact to summarize.
     * @param callbacks - The callbacks to use for the action.
     */
    async function handleGenerateSummary(
      artifact: ArtifactSchema,
      callbacks: IOHandlerCallback = {}
    ): Promise<void> {
      await summaryGenerationApi.handleRequest(
        async () => {
          const summary = await createSummary(artifact);

          const clear = () => (summaryGenConfirm.value = undefined);
          const confirm = () =>
            artifactApiStore.handleSave(
              {
                ...artifact,
                summary: summaryGenConfirm.value?.summary || """",
              },
              true,
              undefined,
              { onComplete: clear }
            );

          summaryGenConfirm.value = { summary, confirm, clear };
        },
        callbacks,
        {
          error: `Failed to generate summary: ${artifact.name}`,
        }
      );
    }

    /**
     * Generates the name of an artifact based on the body.
     * Uses the artifact currently being edited, and updates the edited artifact name to the response.
     *
     * @param callbacks - The callbacks to use for the action.
     */
    async function handleGenerateName(
      callbacks: IOHandlerCallback = {}
    ): Promise<void> {
      const artifact = artifactSaveStore.editedArtifact;

      await nameGenerationApi.handleRequest(
        async () => {
          artifact.name = await createPrompt(
            `Generate a 3 word name for:
\`\`\`
${artifact.body}
\`\`\``
          );
        },
        callbacks,
        {
          error: `Failed to generate name based on the body: ${artifact.name}`,
        }
      );
    }

    /**
     * Generates the body of an artifact based on an artifact prompt.
     * Uses the artifact currently being edited, and updates the edited artifact body to the response.
     *
     * @param callbacks - The callbacks to use for the action.
     */
    async function handleGenerateBody(
      callbacks: IOHandlerCallback = {}
    ): Promise<void> {
      const artifact = artifactSaveStore.editedArtifact;

      await bodyGenerationApi.handleRequest(
        async () => {
          artifact.body = await createPrompt(artifact.body);
        },
        callbacks,
        {
          error: `Failed to generate body based on prompt: ${artifact.name}`,
        }
      );
    }

    /**
     * Generates parent artifacts based on child artifacts, and stores the generated artifacts.
     *
     * @param configuration - The configuration for generating the artifacts.
     * @param callbacks - The callbacks for the action.
     */
    async function handleGenerateArtifacts(
      configuration: GenerateArtifactSchema,
      callbacks: IOHandlerCallback
    ): Promise<void> {
      await artifactGenerationApi.handleRequest(
        async () => {
          const job = await createGeneratedArtifacts(
            configuration,
            projectStore.versionId
          );

          jobStore.updateJob(job);
        },
        callbacks,
        {
          success:
            ""Artifacts are being generated. You'll receive an update when they have been created."",
          error: ""Unable to generate artifacts."",
        }
      );
    }

    return {
      summaryGenConfirm,
      nameGenLoading,
      bodyGenLoading,
      summaryGenLoading,
      artifactGenLoading,
      handleGenerateSummary,
      handleGenerateName,
      handleGenerateBody,
      handleGenerateArtifacts,
    };
  }
);

export default useArtifactGenerationApi(pinia);
"
src/hooks/api/generation/useModelApi.ts,"import { defineStore } from ""pinia"";

import {
  IOHandlerCallback,
  ModelShareType,
  GenerationModelSchema,
} from ""@/types"";
import { useApi, logStore, modelSaveStore, projectStore } from ""@/hooks"";
import { pinia } from ""@/plugins"";
import {
  createModel,
  deleteModel,
  getProjectModels,
  shareModel,
} from ""@/api/endpoints"";

export const useModelApi = defineStore(""modelApi"", () => {
  const modelApi = useApi(""modelApi"");

  /**
   * Loads models for the current project.
   */
  async function handleReload(): Promise<void> {
    await modelApi.handleRequest(async () =>
      projectStore.updateProject({
        models: await getProjectModels(projectStore.projectId),
      })
    );
  }

  /**
   * Saves a model, updates app state, and logs the status.
   *
   * @param callbacks - Callbacks for the request.
   */
  async function handleSave(
    callbacks: IOHandlerCallback<GenerationModelSchema>
  ): Promise<void> {
    const model = modelSaveStore.editedModel;

    await modelApi.handleRequest(
      async () => {
        logStore.onInfo(
          `Model is being saved, you'll receive a notification when it is ready: ${model.name}`
        );

        const createdModel = await createModel(projectStore.projectId, model);

        projectStore.models.push(createdModel);

        return createdModel;
      },
      callbacks,
      {
        success: `Model has been saved: ${model.name}.`,
        error: `Unable to save model: ${model.name}`,
      }
    );
  }

  /**
   * Deletes a model, updates app state, and logs the status.
   *
   * @param model - The model to create.
   */
  async function handleDelete(model: GenerationModelSchema): Promise<void> {
    await logStore.confirm(
      ""Delete Model"",
      `Are you sure you want to delete ${model.name}?`,
      async (isConfirmed) => {
        if (!isConfirmed) return;

        await modelApi.handleRequest(
          async () => {
            await deleteModel(projectStore.projectId, model.id);

            projectStore.updateProject({
              models: projectStore.models.filter(({ id }) => id !== model.id),
            });
          },
          {},
          {
            success: `Model has been deleted: ${model.name}`,
            error: `Unable to delete model: ${model.name}`,
          }
        );
      }
    );
  }

  /**
   * Shares a model with another project.
   *
   * @param targetProject - The id of the project to share the model to.
   * @param model - The model to share.
   * @param shareMethod - The method by which to share.
   */
  async function handleShare(
    targetProject: string,
    model: GenerationModelSchema,
    shareMethod: ModelShareType
  ): Promise<void> {
    await modelApi.handleRequest(
      async () => shareModel(targetProject, model, shareMethod),
      {},
      {
        success: `Successfully shared model: ""${model.name}`,
        error: `Unable to share model: ""${model.name}`,
      }
    );
  }

  return {
    handleReload,
    handleSave,
    handleDelete,
    handleShare,
  };
});

export default useModelApi(pinia);
"
src/hooks/api/generation/index.ts,"export { default as modelApiStore } from ""./useModelApi"";
export { default as artifactGenerationApiStore } from ""./useArtifactGenerationApi"";
export { default as traceGenerationApiStore } from ""./useTraceGenerationApi"";
"
src/hooks/api/generation/useTraceGenerationApi.ts,"import { defineStore } from ""pinia"";

import { computed } from ""vue"";
import {
  ApprovalType,
  MatrixSchema,
  FlatTraceLink,
  IOHandlerCallback,
  ModelType,
  GenerationModelSchema,
} from ""@/types"";
import { createGeneratedMatrix } from ""@/util"";
import {
  useApi,
  approvalStore,
  artifactStore,
  jobApiStore,
  projectStore,
} from ""@/hooks"";
import {
  createGeneratedLinks,
  createModelTraining,
  getGeneratedLinks,
} from ""@/api"";
import { pinia } from ""@/plugins"";

export const useTraceGenerationApi = defineStore(""traceGenerationApi"", () => {
  const traceGenerationApi = useApi(""traceGenerationApi"");

  const loading = computed(() => traceGenerationApi.loading);

  /**
   * Updates the storage of generated links.
   *
   * @param callbacks - The callbacks to use for the action.
   */
  async function handleReload(
    callbacks: IOHandlerCallback = {}
  ): Promise<void> {
    if (!projectStore.isProjectDefined) return;

    await traceGenerationApi.handleRequest(
      async () => {
        const traceLinks: FlatTraceLink[] = [];
        const approvedIds: string[] = [];
        const declinedIds: string[] = [];
        const generatedLinks = await getGeneratedLinks(projectStore.versionId);

        generatedLinks.forEach((link) => {
          const source = artifactStore.getArtifactById(link.sourceId);
          const target = artifactStore.getArtifactById(link.targetId);

          if (link.approvalStatus === ApprovalType.APPROVED) {
            approvedIds.push(link.traceLinkId);
          } else if (link.approvalStatus === ApprovalType.DECLINED) {
            declinedIds.push(link.traceLinkId);
          }

          traceLinks.push({
            ...link,
            sourceType: source?.type || """",
            sourceBody: source?.body || """",
            targetType: target?.type || """",
            targetBody: target?.body || """",
          });
        });

        approvalStore.initializeTraces({
          traceLinks,
          approvedIds,
          declinedIds,
        });
      },
      callbacks,
      { useAppLoad: true }
    );
  }

  /**
   * Generates links between sets of artifact types and adds them to the project.
   *
   * @param method - The base model to generate with.
   * @param matrices - An array of source and target artifact types to generate traces between.
   * @param callbacks - The callbacks to use for the action.
   */
  async function handleGenerate(
    method: ModelType | undefined,
    matrices: MatrixSchema[],
    callbacks: IOHandlerCallback
  ): Promise<void> {
    const matricesName = matrices
      .map(({ source, target }) => `${source} -> ${target}`)
      .join("", "");

    await traceGenerationApi.handleRequest(
      async () => {
        const job = await createGeneratedLinks({
          requests: [createGeneratedMatrix(matrices, method)],
          projectVersion: projectStore.version,
        });

        await jobApiStore.handleCreate(job);
      },
      callbacks,
      {
        success: `Started generating new trace links: ${matricesName}. You'll receive a notification once they are added.`,
        error: `Unable to generate new trace links: ${matricesName}`,
      }
    );
  }

  /**
   * Trains models on created trace links.
   *
   * @param model - The model to train.
   * @param matrices - An array of source and target artifact types to train on traces between.
   * @param callbacks - The callbacks to use for the action.
   */
  async function handleTrain(
    model: GenerationModelSchema,
    matrices: MatrixSchema[],
    callbacks: IOHandlerCallback
  ): Promise<void> {
    const matricesName = matrices
      .map(({ source, target }) => `${source} -> ${target}`)
      .join("", "");

    await traceGenerationApi.handleRequest(
      async () => {
        const job = await createModelTraining(projectStore.projectId, {
          requests: [createGeneratedMatrix(matrices, model.baseModel, model)],
        });

        await jobApiStore.handleCreate(job);
      },
      callbacks,
      {
        success: `Started training model on: ${matricesName}. You'll receive a notification once complete.`,
        error: `Unable to train model on: ${matricesName}`,
      }
    );
  }

  return { loading, handleReload, handleGenerate, handleTrain };
});

export default useTraceGenerationApi(pinia);
"
src/api/index.ts,"export * from ""./util"";
export * from ""./endpoints"";
"
src/api/endpoints/link-api.ts,"import {
  JobSchema,
  TraceLinkSchema,
  TrainOrGenerateLinksSchema,
} from ""@/types"";
import { authHttpClient, Endpoint, fillEndpoint } from ""@/api/util"";

/**
 * Returns all generated links for this project.
 *
 * @param versionId - The project version id whose related links are retrieved.
 * @return The generated links.
 */
export async function getGeneratedLinks(
  versionId: string
): Promise<TraceLinkSchema[]> {
  return authHttpClient<TraceLinkSchema[]>(
    fillEndpoint(Endpoint.getGeneratedLinks, { versionId }),
    { method: ""GET"" }
  );
}

/**
 * Generates links between source and target artifacts.
 *
 * @param config - Generated link configuration.
 * @return The created job.
 */
export async function createGeneratedLinks(
  config: TrainOrGenerateLinksSchema
): Promise<JobSchema> {
  return authHttpClient<JobSchema>(fillEndpoint(Endpoint.generateLinksJob), {
    method: ""POST"",
    body: JSON.stringify(config),
  });
}

/**
 * Trains a model between source and target artifacts.
 *
 * @param projectId - The project to train for.
 * @param config - Model training configuration.
 * @return The created job.
 */
export async function createModelTraining(
  projectId: string,
  config: TrainOrGenerateLinksSchema
): Promise<JobSchema> {
  return authHttpClient<JobSchema>(
    fillEndpoint(Endpoint.trainModelJob, { projectId }),
    {
      method: ""POST"",
      body: JSON.stringify(config),
    }
  );
}
"
src/api/endpoints/github-api.ts,"import { GitHubImportSchema, GitHubProjectSchema, JobSchema } from ""@/types"";
import { authHttpClient, Endpoint, fillEndpoint } from ""@/api"";

/**
 * The formatted scopes of GitHub permissions being requested.
 */
const scopes = encodeURI([""repo""].join("",""));

/**
 * Opens an external link to authorize GitHub.
 */
export function authorizeGitHub(): void {
  window.open(
    `https://github.com/login/oauth/authorize?` +
      `client_id=${process.env.VUE_APP_GITHUB_CLIENT_ID}&` +
      `redirect_uri=${process.env.VUE_APP_GITHUB_REDIRECT_LINK}&` +
      `scope=${scopes}`
  );
}

/**
 * Save an GitHub access code.
 *
 * @param accessCode - The access code received from authorizing GitHub.
 */
export async function saveGitHubCredentials(accessCode: string): Promise<void> {
  await authHttpClient(
    fillEndpoint(Endpoint.githubCreateCredentials, { accessCode }),
    {
      method: ""POST"",
    }
  );
}

/**
 * Checks if the saved GitHub credentials are valid.
 *
 * @return Whether the credentials are valid.
 */
export async function getGitHubCredentials(): Promise<boolean> {
  return (
    (await authHttpClient<boolean | null>(Endpoint.githubValidateCredentials, {
      method: ""GET"",
    })) === true
  );
}

/**
 * Checks if the saved GitHub credentials are valid.
 *
 * @return Whether the credentials are valid.
 */
export async function refreshGitHubCredentials(): Promise<boolean> {
  return (
    (await authHttpClient<boolean | null>(Endpoint.githubEditCredentials, {
      method: ""PUT"",
    })) === true
  );
}

/**
 * Deletes the stored GitHub credentials.
 */
export async function deleteGitHubCredentials(): Promise<void> {
  await authHttpClient(Endpoint.githubEditCredentials, {
    method: ""DELETE"",
  });
}

/**
 * Gets the list of authorized repositories from GitHub.
 *
 * @return The GitHub repositories for this user.
 */
export async function getGitHubProjects(): Promise<GitHubProjectSchema[]> {
  return (
    (await authHttpClient<GitHubProjectSchema[]>(Endpoint.githubGetProjects, {
      method: ""GET"",
    })) || []
  );
}

/**
 * Creates a new project based on a GitHub project.
 *
 * @param owner - The owner of the repository to create a project from.
 * @param repositoryName - The repository to create a project from.
 * @param configuration - The configuration to use for the integration.
 * @return The created import job.
 */
export async function createGitHubProject(
  owner: string,
  repositoryName: string,
  configuration?: GitHubImportSchema
): Promise<JobSchema> {
  return await authHttpClient<JobSchema>(
    fillEndpoint(Endpoint.githubCreateProject, {
      owner,
      repositoryName,
    }),
    {
      method: ""POST"",
      body: JSON.stringify(configuration),
    }
  );
}

/**
 * Synchronizes the state of GitHub artifacts in a project.
 *
 * @param versionId - The project version to sync data with.
 * @param owner - The owner of the repository to sync a project from.
 * @param repositoryName - The repository to create a project from.
 * @param configuration - The configuration to use for the sync.
 * @return The created import job.
 */
export async function createGitHubProjectSync(
  versionId: string,
  owner: string,
  repositoryName: string,
  configuration?: GitHubImportSchema
): Promise<JobSchema> {
  return await authHttpClient<JobSchema>(
    fillEndpoint(Endpoint.githubSyncProject, {
      versionId,
      owner,
      repositoryName,
    }),
    {
      method: ""PUT"",
      body: JSON.stringify(configuration),
    }
  );
}
"
src/api/endpoints/session-api.ts,"import {
  SessionSchema,
  PasswordResetSchema,
  UserPasswordSchema,
  UserResetSchema,
  PasswordChangeSchema,
  UserSchema,
} from ""@/types"";
import { BASE_URL, Endpoint, fillEndpoint, authHttpClient } from ""@/api"";

/**
 * Custom fetch call for session endpoints.
 *
 * @param args - Args to pass to fetch.
 * @throws Error - Response status was not 200.
 */
async function sessionFetch<T>(...args: Parameters<typeof fetch>): Promise<T> {
  const response = await fetch(`${BASE_URL}/${args[0]}`, {
    ...args[1],
    credentials: ""include"",
    headers: {
      ""Content-Type"": ""application/json"",
    },
  });

  if (!response.ok) {
    throw Error(""Unable to find a session."");
  }

  return response.json();
}

/**
 * Creates a new account.
 *
 * @param user - The user to create.
 * @return The session for the logged in user.
 * @throws If the account cannot be created.
 */
export async function createUser(
  user: UserPasswordSchema
): Promise<SessionSchema> {
  return sessionFetch<SessionSchema>(fillEndpoint(Endpoint.createAccount), {
    method: ""POST"",
    body: JSON.stringify(user),
  });
}

/**
 * Logs the given user in.
 *
 * @param user - The user to log in.
 * @return The session for the logged in user.
 * @throws If no session exists.
 */
export async function createLoginSession(
  user: UserPasswordSchema
): Promise<SessionSchema> {
  return sessionFetch<SessionSchema>(fillEndpoint(Endpoint.login), {
    method: ""POST"",
    body: JSON.stringify(user),
  });
}

/**
 * Gets the currently logged in user.
 *
 * @return The current user.
 * @throws If no user exists.
 */
export async function getCurrentUser(): Promise<UserSchema> {
  return authHttpClient<UserSchema>(fillEndpoint(Endpoint.getAccount), {
    method: ""GET"",
  });
}

/**
 * Requests to reset the password of the given user.
 *
 * @param user - The user to reset.
 */
export async function createPasswordReset(
  user: UserResetSchema
): Promise<void> {
  await authHttpClient(fillEndpoint(Endpoint.forgotPassword), {
    method: ""PUT"",
    body: JSON.stringify(user),
  });
}

/**
 * Requests to update a user's reset password.
 *
 * @param password - The password change information.
 * @throws The password change request was unsuccessful.
 */
export async function updatePassword(
  password: PasswordResetSchema
): Promise<void> {
  await sessionFetch(fillEndpoint(Endpoint.resetPassword), {
    method: ""PUT"",
    body: JSON.stringify(password),
  });
}

/**
 * Requests to change a user's password.
 *
 * @param password - The password change information.
 * @throws The password change request was unsuccessful.
 */
export async function savePassword(
  password: PasswordChangeSchema
): Promise<void> {
  await authHttpClient(fillEndpoint(Endpoint.updatePassword), {
    method: ""PUT"",
    body: JSON.stringify(password),
  });
}

/**
 * Requests to delete a user's account.
 *
 * @param password - The current password.
 * @throws The delete request was unsuccessful.
 */
export async function deleteAccount(password: string): Promise<void> {
  await authHttpClient(fillEndpoint(Endpoint.deleteAccount), {
    method: ""POST"",
    body: JSON.stringify({ password }),
  });
}

/**
 * Logs out the current user.
 */
export async function deleteSession(): Promise<void> {
  await authHttpClient(fillEndpoint(Endpoint.logout), {
    method: ""GET"",
  }).catch(() => {
    // TODO: this should not be failing.
  });
}
"
src/api/endpoints/files-api.ts,"import { authHttpClient, Endpoint, fillEndpoint } from ""@/api"";

/**
 * Downloads project files for the given version.
 * @param versionId - The version to download.
 * @param fileType - The file format to download.
 */
export async function getProjectFiles(
  versionId: string,
  fileType: ""csv"" | ""json"" = ""csv""
): Promise<string> {
  return authHttpClient<string>(
    fillEndpoint(Endpoint.getProjectFiles, { versionId, fileType }),
    {
      method: ""GET"",
    },
    { arrayBuffer: true }
  );
}
"
src/api/endpoints/summarization-api.ts,"import { ArtifactSchema } from ""@/types"";
import { authHttpClient, Endpoint, fillEndpoint } from ""@/api"";

/**
 * Generates a summary for an artifact.
 *
 * @param artifact - The artifact to summarize.
 * @return The artifact summary.
 */
export async function createSummary(artifact: ArtifactSchema): Promise<string> {
  const summaries = await authHttpClient<string[]>(
    fillEndpoint(Endpoint.summarize),
    {
      method: ""POST"",
      body: JSON.stringify({
        artifacts: [
          {
            name: artifact.name,
            content: artifact.body,
          },
        ],
      }),
    }
  );

  return summaries[0] || """";
}

/**
 * Generates a response based on a prompt.
 *
 * @param prompt - The prompt to generate with.
 * @return The response based on the prompt.
 */
export async function createPrompt(prompt: string): Promise<string> {
  const { completion } = await authHttpClient<{ completion: string }>(
    fillEndpoint(Endpoint.prompt),
    {
      method: ""POST"",
      body: JSON.stringify({ prompt }),
    }
  );

  return completion;
}
"
src/api/endpoints/jira-api.ts,"import { JiraOrganizationSchema, JiraProjectSchema, JobSchema } from ""@/types"";
import { authHttpClient, Endpoint, fillEndpoint } from ""@/api"";

/**
 * The formatted scopes of Jira permissions being requested.
 */
const scopes = encodeURI(
  [
    // Current Jira API version:
    ""read:jira-work"",
    ""read:jira-user"",
    ""offline_access"",
    // Upcoming Jira API version:
    // ""read:issue-type:jira"",
    // ""read:project:jira"",
    // ""read:project.property:jira"",
    // ""read:user:jira"",
    // ""read:application-role:jira"",
    // ""read:avatar:jira"",
    // ""read:group:jira"",
    // ""read:issue-type-hierarchy:jira"",
    // ""read:project-category:jira"",
    // ""read:project-version:jira"",
    // ""read:project.component:jira"",
  ].join("" "")
);

/**
 * Opens an external link to authorize Jira.
 */
export function authorizeJira(): void {
  window.open(
    `https://auth.atlassian.com/authorize?` +
      `audience=api.atlassian.com&` +
      `client_id=${process.env.VUE_APP_JIRA_CLIENT_ID}&` +
      `scope=${scopes}&` +
      `redirect_uri=${process.env.VUE_APP_JIRA_REDIRECT_LINK}&` +
      `state=${String(Math.random()).slice(0, 10)}&` +
      `response_type=code&` +
      `prompt=consent`
  );
}

/**
 * Save an Atlassian access code.
 *
 * @param accessCode - The access code received from authorizing Jira.
 */
export async function saveJiraCredentials(accessCode: string): Promise<void> {
  await authHttpClient(
    fillEndpoint(Endpoint.jiraCreateCredentials, { accessCode }),
    {
      method: ""POST"",
    }
  );
}

/**
 * Checks if the saved Jira credentials are valid.
 *
 * @return Whether the credentials are valid.
 */
export async function getJiraCredentials(): Promise<boolean> {
  return (
    (
      await authHttpClient<{ payload: boolean | null }>(
        Endpoint.jiraValidateCredentials,
        {
          method: ""GET"",
        }
      )
    ).payload === true
  );
}

/**
 * Checks if the saved Jira credentials are valid.
 *
 * @return Whether the credentials are valid.
 */
export async function refreshJiraCredentials(): Promise<boolean> {
  return (
    (
      await authHttpClient<{ payload: boolean | null }>(
        Endpoint.jiraEditCredentials,
        {
          method: ""PUT"",
        }
      )
    ).payload === true
  );
}

/**
 * Deletes the stored Jira credentials.
 */
export async function deleteJiraCredentials(): Promise<void> {
  await authHttpClient(Endpoint.jiraEditCredentials, {
    method: ""DELETE"",
  });
}

/**
 * Gets Jira installations.
 *
 * @return The user's installations.
 */
export async function getJiraInstallations(): Promise<
  JiraOrganizationSchema[]
> {
  return (
    (
      await authHttpClient<{ payload: JiraOrganizationSchema[] }>(
        Endpoint.jiraGetInstallations,
        {
          method: ""GET"",
        }
      )
    ).payload || []
  );
}

/**
 * Gets Jira projects for an organization.
 *
 * @param cloudId - The Jira installation to get projects for.
 * @return The user's projects.
 */
export async function getJiraProjects(
  cloudId: string
): Promise<JiraProjectSchema[]> {
  return (
    (
      await authHttpClient<{ payload: JiraProjectSchema[] }>(
        fillEndpoint(Endpoint.jiraGetProjects, { cloudId }),
        {
          method: ""GET"",
        }
      )
    ).payload || []
  );
}

/**
 * Creates a new project based on a Jira project.
 *
 * @param cloudId - The Jira installation to import projects from.
 * @param id - The Jira project id to import.
 * @return The created import job.
 */
export async function createJiraProject(
  cloudId: string,
  id: string
): Promise<JobSchema> {
  return (
    await authHttpClient<{ payload: JobSchema }>(
      fillEndpoint(Endpoint.jiraCreateProject, { cloudId, id }),
      {
        method: ""POST"",
      }
    )
  ).payload;
}

/**
 * Synchronizes the state of Jira artifacts in a project.
 *
 * @param versionId - The project version to sync.
 * @param cloudId - The Jira installation to import projects from.
 * @param id - The Jira project id to import.
 */
export async function createJiraProjectSync(
  versionId: string,
  cloudId: string,
  id: string
): Promise<JobSchema> {
  return (
    await authHttpClient<{ payload: JobSchema }>(
      fillEndpoint(Endpoint.jiraSyncProject, { versionId, cloudId, id }),
      {
        method: ""PUT"",
      }
    )
  ).payload;
}
"
src/api/endpoints/entity-retrieval-api.ts,"import { ArtifactSchema, ProjectSchema, TraceLinkSchema } from ""@/types"";
import { Endpoint, fillEndpoint, authHttpClient } from ""@/api/util"";

/**
 * Gets a specific version of a project.
 *
 * @param versionId - The project version ID to get.
 * @return The matching project.
 */
export async function getProjectVersion(
  versionId: string
): Promise<ProjectSchema> {
  return authHttpClient<ProjectSchema>(
    fillEndpoint(Endpoint.projectVersion, { versionId }),
    { method: ""GET"" }
  );
}

/**
 * Returns the list of artifacts in the given version.
 *
 * @param versionId - The version whose artifacts are returned.
 * @return The list of artifacts.
 */
export async function getArtifactsInVersion(
  versionId: string
): Promise<ArtifactSchema[]> {
  return authHttpClient<ArtifactSchema[]>(
    fillEndpoint(Endpoint.getArtifactsInVersion, { versionId }),
    { method: ""GET"" }
  );
}

/**
 * Returns the list of trace links in the given version.
 *
 * @param versionId - The version whose trace links are returned.
 * @return The list of trace links.
 */
export async function getTracesInVersion(
  versionId: string
): Promise<TraceLinkSchema[]> {
  return authHttpClient<TraceLinkSchema[]>(
    fillEndpoint(Endpoint.getTracesInVersion, { versionId }),
    { method: ""GET"" }
  );
}
"
src/api/endpoints/attribute-api.ts,"import { AttributeLayoutSchema, AttributeSchema } from ""@/types"";
import { authHttpClient, Endpoint, fillEndpoint } from ""@/api"";

/**
 * Creates a new artifact custom attribute.
 *
 * @param projectId - The project to create the attribute on.
 * @param attribute - The attribute to create.
 * @return The created attribute.
 */
export async function createAttribute(
  projectId: string,
  attribute: AttributeSchema
): Promise<AttributeSchema> {
  return authHttpClient<AttributeSchema>(
    fillEndpoint(Endpoint.createAttribute, {
      projectId,
    }),
    {
      method: ""POST"",
      body: JSON.stringify(attribute),
    }
  );
}

/**
 * Edits an artifact custom attribute.
 *
 * @param projectId - The project to edit the attribute on.
 * @param attribute - The attribute to edit.
 * @return The edited attribute.
 */
export async function editAttribute(
  projectId: string,
  attribute: AttributeSchema
): Promise<AttributeSchema> {
  return authHttpClient<AttributeSchema>(
    fillEndpoint(Endpoint.editAttribute, {
      projectId,
      key: attribute.key,
    }),
    {
      method: ""PUT"",
      body: JSON.stringify(attribute),
    }
  );
}

/**
 * Deletes an artifact custom attribute.
 *
 * @param projectId - The project to delete the attribute on.
 * @param attribute - The attribute to delete.
 */
export async function deleteAttribute(
  projectId: string,
  attribute: AttributeSchema
): Promise<void> {
  return authHttpClient<void>(
    fillEndpoint(Endpoint.editAttribute, {
      projectId,
      key: attribute.key,
    }),
    {
      method: ""DELETE"",
    }
  );
}

/**
 * Creates a new artifact attribute layout.
 *
 * @param projectId - The project to create the attribute layout on.
 * @param layout - The attribute layout to create.
 * @return The created attribute layout.
 */
export async function createAttributeLayout(
  projectId: string,
  layout: AttributeLayoutSchema
): Promise<AttributeLayoutSchema> {
  return authHttpClient<AttributeLayoutSchema>(
    fillEndpoint(Endpoint.createAttributeLayout, {
      projectId,
    }),
    {
      method: ""POST"",
      body: JSON.stringify(layout),
    }
  );
}

/**
 * Edits an artifact attribute layout.
 *
 * @param projectId - The project to edit the attribute layout on.
 * @param layout - The attribute layout to edit.
 * @return The edited attribute layout.
 */
export async function editAttributeLayout(
  projectId: string,
  layout: AttributeLayoutSchema
): Promise<AttributeLayoutSchema> {
  return authHttpClient<AttributeLayoutSchema>(
    fillEndpoint(Endpoint.editAttributeLayout, {
      projectId,
      id: layout.id,
    }),
    {
      method: ""PUT"",
      body: JSON.stringify(layout),
    }
  );
}

/**
 * Deletes an artifact attribute layout.
 *
 * @param projectId - The project to delete the attribute layout on.
 * @param layout - The attribute layout to delete.
 */
export async function deleteAttributeLayout(
  projectId: string,
  layout: AttributeLayoutSchema
): Promise<void> {
  return authHttpClient<void>(
    fillEndpoint(Endpoint.editAttributeLayout, {
      projectId,
      id: layout.id,
    }),
    {
      method: ""DELETE"",
    }
  );
}
"
src/api/endpoints/version-api.ts,"import { VersionSchema } from ""@/types"";
import { Endpoint, fillEndpoint, authHttpClient } from ""@/api"";

/**
 * Gets all versions of the given project.
 *
 * @param projectId - The project to return versions of.
 * @return All project versions.
 */
export async function getProjectVersions(
  projectId: string
): Promise<VersionSchema[]> {
  return authHttpClient<VersionSchema[]>(
    fillEndpoint(Endpoint.getProjectVersions, { projectId }),
    { method: ""GET"" }
  );
}

/**
 * Returns the current version of the given project.
 *
 * @param projectId - The project to return the current version of.
 * @return The current version.
 */
export async function getCurrentVersion(
  projectId: string
): Promise<VersionSchema> {
  return authHttpClient<VersionSchema>(
    fillEndpoint(Endpoint.getCurrentVersion, { projectId }),
    { method: ""GET"" }
  );
}

/**
 * Creates a new major version of the project.
 *
 * @param projectId - The project to create a new version of.
 * @return The new project version.
 */
export async function createMajorVersion(
  projectId: string
): Promise<VersionSchema> {
  return authHttpClient<VersionSchema>(
    fillEndpoint(Endpoint.createNewMajorVersion, { projectId }),
    { method: ""POST"" }
  );
}

/**
 * Creates a new minor version of the project.
 *
 * @param projectId - The project to create a new version of.
 * @return The new project version.
 */
export async function createMinorVersion(
  projectId: string
): Promise<VersionSchema> {
  return authHttpClient<VersionSchema>(
    fillEndpoint(Endpoint.createNewMinorVersion, { projectId }),
    { method: ""POST"" }
  );
}

/**
 * Creates a new revision version of the project.
 *
 * @param projectId - The project to create a new version of.
 * @return The new project version.
 */
export async function createRevisionVersion(
  projectId: string
): Promise<VersionSchema> {
  return authHttpClient<VersionSchema>(
    fillEndpoint(Endpoint.createNewRevisionVersion, { projectId }),
    {
      method: ""POST"",
    }
  );
}

/**
 * Deletes a version of the project.
 *
 * @param versionId - The version ID to delete.
 */
export async function deleteProjectVersion(versionId: string): Promise<void> {
  return authHttpClient<void>(
    fillEndpoint(Endpoint.projectVersion, { versionId }),
    {
      method: ""DELETE"",
    }
  );
}
"
src/api/endpoints/artifact-api.ts,"import { NameValidationSchema } from ""@/types"";
import { Endpoint, fillEndpoint, authHttpClient } from ""@/api"";

/**
 * Returns whether the given artifact name already exists.
 *
 * @param versionId - The project version to search within.
 * @param artifactName - The artifact name to search for.
 * @return Whether the artifact name is already taken.
 */
export async function getDoesArtifactExist(
  versionId: string,
  artifactName: string
): Promise<boolean> {
  const res = await authHttpClient<NameValidationSchema>(
    fillEndpoint(Endpoint.isArtifactNameTaken, { versionId }),
    { method: ""POST"", body: JSON.stringify({ artifactName }) }
  );

  return res.artifactExists;
}
"
src/api/endpoints/job-api.ts,"import { JobLogSchema, JobSchema } from ""@/types"";
import { authHttpClient, Endpoint, fillEndpoint } from ""@/api"";

/**
 * Creates a project from the given flat files.
 *
 * @param formData - Form data containing the project files.
 * @return The created project.
 */
export async function createProjectUploadJob(
  formData: FormData
): Promise<JobSchema> {
  return authHttpClient<JobSchema>(
    Endpoint.createProjectThroughFlatFiles,
    {
      method: ""POST"",
      body: formData,
    },
    { setJsonContentType: false }
  );
}

/**
 * Updates an existing project from the given flat files.
 *
 * @param versionId - The project version to update.
 * @param formData - Form data containing the project files.
 * @return The updated project.
 */
export async function createFlatFileUploadJob(
  versionId: string,
  formData: FormData
): Promise<JobSchema> {
  return authHttpClient<JobSchema>(
    fillEndpoint(Endpoint.updateProjectThroughFlatFiles, { versionId }),
    {
      method: ""POST"",
      body: formData,
    },
    { setJsonContentType: false }
  );
}

/**
 * Returns list of jobs created by user.
 *
 * @return Uses list.
 */
export async function getUserJobs(): Promise<JobSchema[]> {
  return authHttpClient<JobSchema[]>(fillEndpoint(Endpoint.getUserJobs, {}), {
    method: ""GET"",
  });
}

/**
 * Deletes the job with given id.
 *
 * @param jobId - The job to delete.
 */
export async function deleteJobById(jobId: string): Promise<void> {
  return authHttpClient<void>(fillEndpoint(Endpoint.deleteJobById, { jobId }), {
    method: ""DELETE"",
  });
}

/**
 * Returns the logs for a job.
 *
 * @param jobId - The job to get logs for.
 */
export async function getJobLog(jobId: string): Promise<JobLogSchema[][]> {
  return authHttpClient<JobLogSchema[][]>(
    fillEndpoint(Endpoint.getJobLog, { jobId }),
    {
      method: ""GET"",
    }
  );
}
"
src/api/endpoints/layout-api.ts,"import { GeneratedLayoutsSchema, LayoutRegenerationSchema } from ""@/types"";
import { authHttpClient, Endpoint, fillEndpoint } from ""@/api"";

/**
 * Regenerates layouts for a version & document.
 *
 * @param versionId - The version to generate layouts for.
 * @param documentId - The document to generate layouts for. If empty, the default document will be regenerated.
 * @return The generated layouts.
 */
export async function createLayout(
  versionId: string,
  documentId: string
): Promise<GeneratedLayoutsSchema> {
  const body: LayoutRegenerationSchema = documentId
    ? { defaultDocument: false, documentIds: [documentId] }
    : { defaultDocument: true, documentIds: [] };

  return authHttpClient<GeneratedLayoutsSchema>(
    fillEndpoint(Endpoint.refreshLayout, { versionId }),
    {
      method: ""POST"",
      body: JSON.stringify(body),
    }
  );
}
"
src/api/endpoints/search-api.ts,"import { SearchQuerySchema, SearchResultsSchema } from ""@/types"";
import { authHttpClient, Endpoint, fillEndpoint } from ""@/api"";

/**
 * Returns the search results within a project version for the given query.
 * @param versionId - The version to search within.
 * @param query - The query data defining what to search for.
 * @return The matching artifact ids.
 */
export function getProjectSearchQuery(
  versionId: string,
  query: SearchQuerySchema
): Promise<SearchResultsSchema> {
  return authHttpClient<SearchResultsSchema>(
    fillEndpoint(Endpoint.search, { versionId }),
    {
      method: ""POST"",
      body: JSON.stringify(query),
    }
  );
}
"
src/api/endpoints/matrix-api.ts,"import { authHttpClient, Endpoint, fillEndpoint } from ""@/api"";

/**
 * Persists trace matrices between given source and target
 * artifact types in given project.
 *
 * @param versionId - The project version whose trace matrix will be stored.
 * @param sourceType - The source artifact type name.
 * @param targetType - The target artifact type name.
 */
export async function createTraceMatrix(
  versionId: string,
  sourceType: string,
  targetType: string
): Promise<void> {
  return authHttpClient<void>(
    fillEndpoint(Endpoint.createTraceMatrix, {
      versionId,
      sourceType,
      targetType,
    }),
    {
      method: ""POST"",
    }
  );
}

/**
 * Deletes the trace matrix between the given source and target artifact types.
 *
 * @param versionId - The project version to delete this trace matrix within.
 * @param sourceType - The source artifact type name.
 * @param targetType - The target artifact type name.
 */
export async function deleteTraceMatrix(
  versionId: string,
  sourceType: string,
  targetType: string
): Promise<void> {
  return authHttpClient<void>(
    fillEndpoint(Endpoint.deleteTraceMatrix, {
      versionId,
      sourceType,
      targetType,
    }),
    {
      method: ""DELETE"",
    }
  );
}
"
src/api/endpoints/document-api.ts,"import { ArtifactSchema, DocumentSchema } from ""@/types"";
import { authHttpClient, Endpoint, fillEndpoint } from ""@/api"";

/**
 * Creates or updates given document under project specified.
 *
 * @param versionId - The version to mark the document as created.
 * @param document - The document to be created.
 * @return The saved document.
 */
export async function saveDocument(
  versionId: string,
  document: DocumentSchema
): Promise<DocumentSchema> {
  return authHttpClient<DocumentSchema>(
    fillEndpoint(Endpoint.createOrUpdateDocument, {
      versionId,
    }),
    {
      method: ""POST"",
      body: JSON.stringify(document),
    }
  );
}

/**
 * Returns list of documents associated with given project.
 *
 * @param versionId - The project version to get documents for.
 * @return The project's documents.
 */
export async function getDocuments(
  versionId: string
): Promise<DocumentSchema[]> {
  return authHttpClient<DocumentSchema[]>(
    fillEndpoint(Endpoint.getProjectDocuments, {
      versionId,
    }),
    {
      method: ""GET"",
    }
  );
}

/**
 * Deletes the given document from the database.
 * User must have edit permissions on the project.
 *
 * @param document - The document to be deleted.
 */
export async function deleteDocument(document: DocumentSchema): Promise<void> {
  await authHttpClient<void>(
    fillEndpoint(Endpoint.deleteDocument, {
      documentId: document.documentId,
    }),
    {
      method: ""DELETE"",
    }
  );
}

/**
 * Attaches artifacts to a document.
 *
 * @param versionId - The version to mark the addition to.
 * @param documentId - The document to which the artifacts are added to.
 * @param artifacts - The artifacts being added to the document.
 * @return The attached artifacts.
 */
export async function saveDocumentArtifacts(
  versionId: string,
  documentId: string,
  artifacts: ArtifactSchema[]
): Promise<ArtifactSchema[]> {
  return authHttpClient<ArtifactSchema[]>(
    fillEndpoint(Endpoint.addArtifactsToDocument, {
      versionId,
      documentId,
    }),
    {
      method: ""POST"",
      body: JSON.stringify(artifacts),
    }
  );
}

/**
 * Removed artifacts from a document.
 *
 * @param versionId - The version to mark the removal at.
 * @param documentId - The document to remove the artifacts from.
 * @param artifactId - The artifact to remove from the document.
 */
export async function deleteDocumentArtifact(
  versionId: string,
  documentId: string,
  artifactId: string
): Promise<void> {
  return authHttpClient<void>(
    fillEndpoint(Endpoint.removeArtifactFromDocument, {
      versionId,
      documentId,
      artifactId,
    }),
    {
      method: ""DELETE"",
    }
  );
}

/**
 * Sets the document to be the user's current document.
 * @param documentId The document to save.
 */
export async function setCurrentDocument(documentId: string): Promise<void> {
  return authHttpClient<void>(
    fillEndpoint(Endpoint.setCurrentDocument, {
      documentId,
    }),
    {
      method: ""POST"",
    }
  );
}

/**
 * Removes the current document affiliated with current user.
 */
export async function clearCurrentDocument(): Promise<void> {
  return authHttpClient<void>(fillEndpoint(Endpoint.clearCurrentDocument, {}), {
    method: ""DELETE"",
  });
}
"
src/api/endpoints/index.ts,"export * from ""./commit-api"";
export * from ""./artifact-api"";
export * from ""./link-api"";
export * from ""./parse-api"";
export * from ""./project-api"";
export * from ""./session-api"";
export * from ""./version-api"";
export * from ""./matrix-api"";
export * from ""./entity-retrieval-api"";
export * from ""./document-api"";
export * from ""./jira-api"";
export * from ""./warning-api"";
export * from ""./job-api"";
export * from ""./github-api"";
export * from ""./artifact-type-api"";
export * from ""./layout-api"";
export * from ""./sync-api"";
export * from ""./model-api"";
export * from ""./files-api"";
export * from ""./installations-api"";
export * from ""./attribute-api"";
export * from ""./search-api"";
export * from ""./summarization-api"";
export * from ""./hgen-api"";
"
src/api/endpoints/commit-api.ts,"import { CommitSchema } from ""@/types"";
import { Endpoint, fillEndpoint, authHttpClient } from ""@/api"";

/**
 * Sends commit to backend to be saved to the database.
 *
 * @param commit The commit to be persisted to the database.
 * @return The persisted commit.
 */
export async function persistCommit(
  commit: CommitSchema
): Promise<CommitSchema> {
  const { versionId } = commit.commitVersion;

  return authHttpClient<CommitSchema>(
    fillEndpoint(Endpoint.commit, { versionId }),
    {
      method: ""POST"",
      body: JSON.stringify(commit),
    }
  );
}
"
src/api/endpoints/model-api.ts,"import { ModelShareType, GenerationModelSchema } from ""@/types"";
import { authHttpClient, Endpoint, fillEndpoint } from ""@/api"";

/**
 * Returns the models for the given project.
 *
 * @param projectId - The id of the project to get models for.
 * @return The project's models.
 */
export async function getProjectModels(
  projectId: string
): Promise<GenerationModelSchema[]> {
  return authHttpClient<GenerationModelSchema[]>(
    fillEndpoint(Endpoint.getModels, {
      projectId,
    }),
    {
      method: ""GET"",
    }
  );
}

/**
 * Creates a new model.
 *
 * @param projectId - The id of the project to create models for.
 * @param model - The model to create.
 * @return The created model.
 */
export async function createModel(
  projectId: string,
  model: GenerationModelSchema
): Promise<GenerationModelSchema> {
  return authHttpClient<GenerationModelSchema>(
    fillEndpoint(Endpoint.createModel, {
      projectId,
    }),
    {
      method: ""POST"",
      body: JSON.stringify(model),
    }
  );
}

/**
 * Edits a model.
 *
 * @param projectId - The id of the project to edit the model on.
 * @param model - The edited model.
 * @return The edited model.
 */
export async function editModel(
  projectId: string,
  model: GenerationModelSchema
): Promise<GenerationModelSchema> {
  return authHttpClient<GenerationModelSchema>(
    fillEndpoint(Endpoint.editModel, {
      projectId,
      modelId: model.id,
    }),
    {
      method: ""PUT"",
      body: JSON.stringify(model),
    }
  );
}

/**
 * Deletes a model.
 *
 * @param projectId - The id of the project to delete the model on.
 * @param modelId - The model id to delete.
 */
export async function deleteModel(
  projectId: string,
  modelId: string
): Promise<void> {
  await authHttpClient<GenerationModelSchema>(
    fillEndpoint(Endpoint.deleteModel, {
      projectId,
      modelId,
    }),
    {
      method: ""DELETE"",
    }
  );
}

/**
 * Shares a model with another project.
 *
 * @param targetProject - The id of the project to share the model to.
 * @param model - The model to share.
 * @param shareMethod - The method by which to share.
 */
export async function shareModel(
  targetProject: string,
  model: GenerationModelSchema,
  shareMethod: ModelShareType
): Promise<void> {
  await authHttpClient(fillEndpoint(Endpoint.shareModel), {
    method: ""POST"",
    body: JSON.stringify({
      model,
      targetProject,
      shareMethod,
    }),
  });
}
"
src/api/endpoints/parse-api.ts,"import { ParseArtifactFileSchema, ParseTraceFileSchema } from ""@/types"";
import { Endpoint, fillEndpoint, authHttpClient } from ""@/api"";

/**
 * Parses an artifact file into artifacts.
 *
 * @param artifactType - The type of artifact to parse.
 * @param file - The artifact file to parse.
 * @return The parsed artifact file.
 */
export async function parseArtifactFile(
  artifactType: string,
  file: File
): Promise<ParseArtifactFileSchema> {
  const formData = new FormData();

  formData.append(""file"", file);

  return authHttpClient<ParseArtifactFileSchema>(
    fillEndpoint(Endpoint.parseArtifactFile, { artifactType }),
    {
      method: ""POST"",
      body: formData,
    },
    { setJsonContentType: false }
  );
}

/**
 * Parses a trace file into trace links.
 *
 * @param file - The trace file to parse.
 * @return The parsed trace file.
 */
export async function parseTraceFile(
  file: File
): Promise<ParseTraceFileSchema> {
  const formData = new FormData();

  formData.append(""file"", file);

  return authHttpClient<ParseTraceFileSchema>(
    Endpoint.parseTraceFile,
    {
      method: ""POST"",
      body: formData,
    },
    { setJsonContentType: false }
  );
}
"
src/api/endpoints/artifact-type-api.ts,"import { ArtifactTypeSchema } from ""@/types"";
import { authHttpClient, Endpoint, fillEndpoint } from ""@/api"";

/**
 * Creates a new artifact type.
 *
 * @param projectId - The project who's the type will be created for.
 * @param artifactType - The artifact type to create.
 * @return The saved artifact type.
 */
export async function createArtifactType(
  projectId: string,
  artifactType: ArtifactTypeSchema
): Promise<ArtifactTypeSchema> {
  return authHttpClient<ArtifactTypeSchema>(
    fillEndpoint(Endpoint.createArtifactType, {
      projectId,
    }),
    {
      method: ""POST"",
      body: JSON.stringify(artifactType),
    }
  );
}

/**
 * Edits an existing artifact type.
 *
 * @param projectId - The project who's the type will be edited for.
 * @param artifactType - The artifact type to update.
 * @return The saved artifact type.
 */
export async function editArtifactType(
  projectId: string,
  artifactType: ArtifactTypeSchema
): Promise<ArtifactTypeSchema> {
  return authHttpClient<ArtifactTypeSchema>(
    fillEndpoint(Endpoint.editArtifactType, {
      projectId,
      artifactTypeName: artifactType.name,
    }),
    {
      method: ""PUT"",
      body: JSON.stringify(artifactType),
    }
  );
}

/**
 * Deletes the artifact type with given id.
 *
 * @param artifactTypeName - The artifact type to delete.
 */
export async function deleteArtifactType(
  artifactTypeName: string
): Promise<void> {
  return authHttpClient<void>(
    fillEndpoint(Endpoint.deleteArtifactType, {
      artifactTypeName,
    }),
    {
      method: ""DELETE"",
    }
  );
}
"
src/api/endpoints/warning-api.ts,"import { WarningCollectionSchema } from ""@/types"";
import { authHttpClient, Endpoint, fillEndpoint } from ""@/api"";

/**
 * Returns the project warnings in the given project version.
 *
 * @param versionId The version id whose warnings are returned.
 * @return The project warnings.
 */
export async function getWarningsInProjectVersion(
  versionId: string
): Promise<WarningCollectionSchema> {
  return authHttpClient<WarningCollectionSchema>(
    fillEndpoint(Endpoint.getWarningsInProjectVersion, {
      versionId,
    }),
    {
      method: ""GET"",
    }
  );
}
"
src/api/endpoints/installations-api.ts,"import { InstallationSchema } from ""@/types"";
import { authHttpClient, Endpoint, fillEndpoint } from ""@/api"";

/**
 * Returns the 3rd party data installations linked to a given project.
 *
 * @param projectId - The linked project.
 * @return The installations linked to this project.
 */
export async function getProjectInstallations(
  projectId: string
): Promise<InstallationSchema[]> {
  return authHttpClient<InstallationSchema[]>(
    fillEndpoint(Endpoint.getInstallations, { projectId }),
    {
      method: ""GET"",
    }
  );
}
"
src/api/endpoints/hgen-api.ts,"import { GenerateArtifactSchema, JobSchema } from ""@/types"";
import { authHttpClient, Endpoint, fillEndpoint } from ""@/api"";

/**
 * Generates parent artifacts from child artifacts.
 *
 * @param config - The configuration for generating the artifacts.
 * @param versionId - The version to generate the artifacts for.
 * @returns The created commit with artifacts and traces.
 */
export function createGeneratedArtifacts(
  config: GenerateArtifactSchema,
  versionId: string
): Promise<JobSchema> {
  return authHttpClient<JobSchema>(
    fillEndpoint(Endpoint.generateArtifacts, { versionId }),
    {
      method: ""POST"",
      body: JSON.stringify(config),
    }
  );
}
"
src/api/endpoints/sync-api.ts,"import { ChangeMessageSchema, ProjectSchema } from ""@/types"";
import { authHttpClient, Endpoint, fillEndpoint } from ""@/api"";

/**
 * Get changes in EntityChangeMessage.
 *
 * @param versionId - The version of the entities to retrieve.
 * @param message - The message containing set of changed entities.
 * @return A project object with reflected changes.
 */
export async function getChanges(
  versionId: string,
  message: ChangeMessageSchema
): Promise<ProjectSchema> {
  return authHttpClient<ProjectSchema>(
    fillEndpoint(Endpoint.sync, { versionId }),
    {
      method: ""POST"",
      body: JSON.stringify(message),
    }
  );
}
"
src/api/endpoints/project-api.ts,"import {
  CreateProjectByJsonSchema,
  IdentifierSchema,
  JobSchema,
  MemberRequestSchema,
  MembershipSchema,
  VersionDeltaSchema,
  ProjectSchema,
  ProjectRole,
} from ""@/types"";
import { authHttpClient, Endpoint, fillEndpoint } from ""@/api"";

/**
 * Creates or updates the given project.
 *
 * @param project - The project to save.
 * @return The saved project.
 */
export async function saveProject(
  project: Pick<ProjectSchema, ""projectId"" | ""name"" | ""description"">
): Promise<ProjectSchema> {
  return authHttpClient<ProjectSchema>(Endpoint.project, {
    method: ""POST"",
    body: JSON.stringify(project),
  });
}

export async function createProjectCreationJob(
  payload: CreateProjectByJsonSchema
): Promise<JobSchema> {
  return authHttpClient<JobSchema>(Endpoint.createProjectJob, {
    method: ""POST"",
    body: JSON.stringify(payload),
  });
}

/**
 * Returns all project identifiers.
 *
 * @return All project identifiers.
 */
export async function getProjects(): Promise<IdentifierSchema[]> {
  return authHttpClient<IdentifierSchema[]>(Endpoint.project, {
    method: ""GET"",
  });
}

/**
 * Deletes a project.
 *
 * @param projectId - The project ID to delete.
 */
export async function deleteProject(projectId: string): Promise<void> {
  return authHttpClient<void>(
    fillEndpoint(Endpoint.updateProject, { projectId }),
    {
      method: ""DELETE"",
    }
  );
}

/**
 * Generates the delta between two project versions.
 *
 * @param sourceVersionId - The source version of the project.
 * @param targetVersionId - The target version of the project.
 * @return The delta from the source to the target versions.
 */
export async function getProjectDelta(
  targetVersionId: string,
  sourceVersionId: string
): Promise<VersionDeltaSchema> {
  return authHttpClient<VersionDeltaSchema>(
    fillEndpoint(Endpoint.getProjectDelta, {
      sourceVersionId,
      targetVersionId,
    }),
    {
      method: ""GET"",
    }
  );
}

/**
 * Returns the list of project members in given project.
 */
export async function getProjectMembers(
  projectId: string
): Promise<MembershipSchema[]> {
  return authHttpClient<MembershipSchema[]>(
    fillEndpoint(Endpoint.getProjectMembers, {
      projectId,
    }),
    {
      method: ""GET"",
    }
  );
}

/**
 * Shares a project with a user.
 *
 * @param projectId - The project to add this user to.
 * @param memberEmail - The email of the given user.
 * @param projectRole - The role to set for the given user.
 */
export async function saveProjectMember(
  projectId: string,
  memberEmail: string,
  projectRole: ProjectRole
): Promise<MembershipSchema> {
  return authHttpClient<MembershipSchema>(
    fillEndpoint(Endpoint.getProjectMembers, {
      projectId,
    }),
    {
      method: ""POST"",
      body: JSON.stringify({
        memberEmail,
        projectRole,
      } as MemberRequestSchema),
    }
  );
}

/**
 * Deletes a user from a project.
 *
 * @param projectMember - The user to delete.
 * @return The remaining users.
 */
export async function deleteProjectMember({
  projectMembershipId,
}: MembershipSchema): Promise<MembershipSchema[]> {
  return authHttpClient<MembershipSchema[]>(
    fillEndpoint(Endpoint.deleteProjectMember, {
      projectMemberId: projectMembershipId,
    }),
    {
      method: ""DELETE"",
    }
  );
}
"
src/api/util/endpoints.ts,"/**
 * The base URL for the project
 */
export const BASE_URL = process.env.VUE_APP_API_ENDPOINT;

if (!process.env.VUE_APP_API_ENDPOINT) {
  console.error(""API Endpoint environment variable not defined."");
}

/**
 * The number of times to attempt to reconnect to server
 * if connection is lost.
 */
export const MAX_RECONNECT_ATTEMPTS = 20;
/**
 * The amount of time to
 */
export const RECONNECT_WAIT_TIME = 5000;
/**
 * Returns a WebSocket url resolving function. Use only after all modules
 * have been loaded.
 * @constructor
 */
export const WEBSOCKET_URL = (): string => `${BASE_URL}/websocket`;

/**
 * Enumerates all possible endpoint paths.
 */
export enum Endpoint {
  // Accounts
  session = ""accounts/session"",
  login = ""login"",
  createAccount = ""accounts/create"",
  logout = ""logout"",
  forgotPassword = ""accounts/forgot"",
  resetPassword = ""accounts/reset"",
  updatePassword = ""accounts/change"",
  deleteAccount = ""accounts/delete"",
  getAccount = ""accounts/self"",

  // Jobs
  createProjectJob = ""jobs/projects"",
  createProjectThroughFlatFiles = ""jobs/projects/upload"",
  updateProjectThroughFlatFiles = ""jobs/projects/versions/:versionId"",
  getUserJobs = ""jobs"",
  deleteJobById = ""jobs/:jobId"",
  getJobLog = ""jobs/:jobId/logs"",
  jobTopic = ""/topic/:jobId"",
  projectTopic = ""/topic/:projectId"",
  versionTopic = ""/topic/:versionId"",

  // Projects
  project = ""projects"",
  updateProject = ""projects/:projectId"",
  getProjectMembers = ""projects/:projectId/members"",
  deleteProjectMember = ""projects/members/:projectMemberId"",

  // Integrations
  getInstallations = ""projects/installations/by-project/:projectId"",

  jiraCreateCredentials = ""accounts/jira/credentials/:accessCode"",
  jiraEditCredentials = ""accounts/jira/credentials"",
  jiraValidateCredentials = ""accounts/jira/credentials/validate"",
  jiraGetInstallations = ""accounts/jira/installations"",
  jiraGetProjects = ""projects/jira/:cloudId"",
  jiraCreateProject = ""projects/import/jira/:cloudId/:id"",
  jiraSyncProject = ""projects/versions/:versionId/import/jira/:cloudId/:id"",

  githubCreateCredentials = ""accounts/github/credentials/:accessCode"",
  githubEditCredentials = ""accounts/github/credentials"",
  githubValidateCredentials = ""accounts/github/credentials/check"",
  githubGetProjects = ""integrations/github/repos"",
  githubCreateProject = ""projects/import/github/:owner/:repositoryName"",
  githubSyncProject = ""projects/versions/:versionId/import/github/:owner/:repositoryName"",

  // Commits
  commit = ""projects/versions/:versionId/commit"",
  isArtifactNameTaken = ""projects/versions/:versionId/artifacts/validate/"",
  sync = ""projects/versions/:versionId/changes"",

  // Types
  createArtifactType = ""projects/:projectId/artifactTypes"",
  editArtifactType = ""projects/:projectId/artifactTypes/:artifactTypeName"",
  deleteArtifactType = ""projects/:projectId/artifactTypes/:artifactTypeName"",

  // Trace Matrices
  createTraceMatrix = ""projects/:versionId/matrices/:sourceType/:targetType"",
  deleteTraceMatrix = ""projects/:versionId/matrices/:sourceType/:targetType"",

  // Links
  getGeneratedLinks = ""projects/versions/:versionId/links/generated"",
  generateLinksJob = ""jobs/projects/links/generate"",
  trainModelJob = ""jobs/projects/:projectId/models/train"",

  // Entity Retrieval
  projectVersion = ""projects/versions/:versionId"",
  getArtifactsInVersion = ""projects/versions/:versionId/artifacts"",
  getTracesInVersion = ""projects/versions/:versionId/traces"",

  // Versions
  getProjectVersions = ""projects/:projectId/versions"",
  getCurrentVersion = ""projects/:projectId/versions/current"",
  createNewMajorVersion = ""projects/:projectId/versions/major"",
  createNewMinorVersion = ""projects/:projectId/versions/minor"",
  createNewRevisionVersion = ""projects/:projectId/versions/revision"",

  // Attributes
  createAttribute = ""projects/:projectId/attributes"",
  editAttribute = ""projects/:projectId/attributes/:key"",
  createAttributeLayout = ""projects/:projectId/attribute-layouts"",
  editAttributeLayout = ""projects/:projectId/attribute-layouts/:id"",

  // Layout
  refreshLayout = ""projects/versions/:versionId/layout"",

  // Documents
  createOrUpdateDocument = ""projects/versions/:versionId/documents"",
  getProjectDocuments = ""projects/versions/:versionId/documents"",
  deleteDocument = ""projects/documents/:documentId"",

  // Document Artifacts
  addArtifactsToDocument = ""projects/versions/:versionId/documents/:documentId/artifacts"",
  removeArtifactFromDocument = ""projects/versions/:versionId/documents/:documentId/artifacts/:artifactId"",
  setCurrentDocument = ""projects/documents/current/:documentId"",
  clearCurrentDocument = ""projects/documents/current"",

  // Delta
  getProjectDelta = ""projects/delta/:sourceVersionId/:targetVersionId"",

  // Parse Entities
  parseArtifactFile = ""projects/parse/artifacts/:artifactType"",
  parseTraceFile = ""projects/parse/traces"",

  // Warnings
  getWarningsInProjectVersion = ""projects/versions/:versionId/warnings"",

  // Models
  getModels = ""projects/:projectId/models"",
  createModel = ""projects/:projectId/models"",
  editModel = ""projects/:projectId/models/:modelId"",
  deleteModel = ""projects/:projectId/models/:modelId"",
  shareModel = ""projects/models/share"",

  // Files
  getProjectFiles = ""projects/versions/:versionId/flat-files/:fileType"",

  // Search
  search = ""search/:versionId"",

  // Generation

  summarize = ""summarize"",
  prompt = ""prompt"",
  generateArtifacts = ""hgen/:versionId"",
}

/**
 * Fills the given endpoint path with the given path variables.
 *
 * @param endpoint - The endpoint path to fill.
 * @param pathVariables - A collection of path variables, keyed by their id in the endpoint path.
 *
 * @return The filled in endpoint path.
 */
export function fillEndpoint(
  endpoint: Endpoint,
  pathVariables: Record<string, string> = {}
): string {
  let filledPath: string = endpoint;

  Object.entries(pathVariables).forEach(([id, value]) => {
    filledPath = filledPath.replace(`:${id}`, value);
  });

  return filledPath;
}
"
src/api/util/auth-http-client.ts,"import { APIOptions } from ""@/types"";
import { LOGOUT_ERROR } from ""@/util"";
import { BASE_URL } from ""@/api"";

/**
 * Executes an http request with the given parameters containing current
 * session token in request headers.
 *
 * @param relativeUrl - The URL relative to the BEND API endpoint.
 * @param options - Any options for this request, such as the method and any data.
 * @param setJsonContentType - If true, sets the content type of the request.
 * @param parseResponse - If true, the response will be parsed as JSON.
 * @param arrayBuffer - If true, the response will be parsed as an array buffer
 *
 * @return The request's response data.
 * @throws Any errors received from the request.
 */
export default async function authHttpClient<T>(
  relativeUrl: string,
  options: APIOptions,
  { setJsonContentType = true, parseResponse = true, arrayBuffer = false } = {}
): Promise<T> {
  const res = await fetch(`${BASE_URL}/${relativeUrl}`, {
    ...options,
    credentials: ""include"",
    headers: setJsonContentType
      ? {
          ...(options.headers || {}),
          ""Content-Type"": ""application/json"",
        }
      : options.headers,
  });

  if (arrayBuffer) {
    return (await res.arrayBuffer()) as unknown as T;
  }

  const content = await res.text();

  if (res.status === 403 && !relativeUrl.includes(""credentials"")) {
    // Log out of the app if credentials expire.
    // Ensure that we don't log out if the expired credential status is for an integration.
    throw Error(LOGOUT_ERROR);
  } else if (!parseResponse) {
    return content as unknown as T;
  }

  const data = content ? JSON.parse(content) : undefined;

  if (!res.ok) {
    throw Error(data.error);
  } else {
    return data;
  }
}
"
src/api/util/index.ts,"export * from ""./endpoints"";
export { default as authHttpClient } from ""./auth-http-client"";
"
src/views/index.ts,"export * from ""./public"";
export * from ""./private"";
"
src/views/public/index.ts,"export { default as CreateAccountView } from ""./CreateAccountView.vue"";
export { default as ForgotPasswordView } from ""./ForgotPasswordView.vue"";
export { default as LoginView } from ""./LoginView.vue"";
export { default as ResetPasswordView } from ""./ResetPasswordView.vue"";
export { default as DemoView } from ""./DemoView.vue"";
"
src/views/private/index.ts,"export { default as TracePredictionView } from ""./TracePredictionView.vue"";
export { default as ArtifactView } from ""./ArtifactView.vue"";
export { default as ProjectCreatorView } from ""./ProjectCreatorView.vue"";
export { default as ProjectSettingsView } from ""./ProjectSettingsView.vue"";
export { default as UploadStatusView } from ""./UploadStatusView.vue"";
export { default as HomeView } from ""./HomeView.vue"";
export { default as MyAccountView } from ""./MyAccountView.vue"";
export { default as ProjectSelectorView } from ""./ProjectSelectorView.vue"";
export { default as SearchView } from ""./SearchView.vue"";
"
src/router/routes.ts,"import { RouteRecordRaw } from ""vue-router"";
import {
  ArtifactView,
  CreateAccountView,
  DemoView,
  ForgotPasswordView,
  HomeView,
  LoginView,
  MyAccountView,
  ProjectCreatorView,
  ProjectSelectorView,
  ProjectSettingsView,
  ResetPasswordView,
  SearchView,
  TracePredictionView,
  UploadStatusView,
} from ""@/views"";

/**
 * Enumerates the possible routes within the app.
 */
export enum Routes {
  LOGIN_ACCOUNT = ""/login"",
  CREATE_ACCOUNT = ""/create-account"",
  FORGOT_PASSWORD = ""/forgot"",
  RESET_PASSWORD = ""/reset"",
  HOME = ""/"",
  PROJECT_CREATOR = ""/create"",
  MY_PROJECTS = ""/open"",
  ARTIFACT = ""/project"",
  PROJECT_SETTINGS = ""/settings"",
  TRACE_LINK = ""/links"",
  UPLOAD_STATUS = ""/uploads"",
  ACCOUNT = ""/account"",
  SEARCH = ""/search"",

  DEMO = ""/demo"",
}

/**
 * Enumerates query parameters used in the app.
 */
export enum QueryParams {
  LOGIN_PATH = ""to"",
  PW_RESET = ""token"",
  TAB = ""tab"",
  VERSION = ""version"",
  JIRA_TOKEN = ""code"",
  GITHUB_TOKEN = ""code"",
}

export const routes: Array<RouteRecordRaw> = [
  // Public
  {
    path: Routes.LOGIN_ACCOUNT,
    name: ""Login"",
    component: LoginView,
    meta: {
      isPublic: true,
    },
  },
  {
    path: Routes.CREATE_ACCOUNT,
    name: ""Create Account"",
    component: CreateAccountView,
    meta: {
      isPublic: true,
    },
  },
  {
    path: Routes.FORGOT_PASSWORD,
    name: ""Forgot Password"",
    component: ForgotPasswordView,
    meta: {
      isPublic: true,
    },
  },
  {
    path: Routes.RESET_PASSWORD,
    name: ""Reset Password"",
    component: ResetPasswordView,
    meta: {
      isPublic: true,
    },
  },
  // Private
  {
    path: Routes.ACCOUNT,
    name: ""My Account"",
    component: MyAccountView,
  },
  {
    path: Routes.HOME,
    name: ""Home"",
    component: HomeView,
  },
  {
    path: Routes.PROJECT_CREATOR,
    name: ""Create Project"",
    component: ProjectCreatorView,
  },
  {
    path: Routes.MY_PROJECTS,
    name: ""My Projects"",
    component: ProjectSelectorView,
  },
  {
    path: Routes.UPLOAD_STATUS,
    name: ""Upload Status"",
    component: UploadStatusView,
  },
  // Project Specific
  {
    path: Routes.ARTIFACT,
    name: ""Artifact View"",
    component: ArtifactView,
    meta: {
      requiresProject: true,
    },
  },
  {
    path: Routes.TRACE_LINK,
    name: ""Trace Prediction"",
    component: TracePredictionView,
    meta: {
      requiresProject: true,
    },
  },
  {
    path: Routes.PROJECT_SETTINGS,
    name: ""Project Settings"",
    component: ProjectSettingsView,
    meta: {
      requiresProject: true,
    },
  },
  {
    path: Routes.SEARCH,
    name: ""Project Search"",
    component: SearchView,
    meta: {
      requiresProject: true,
    },
  },
  // Demo
  {
    path: Routes.DEMO,
    name: ""SAFA Demo"",
    component: DemoView,
    meta: {
      isPublic: true,
    },
  },
];
"
src/router/router.ts,"import { createRouter, createWebHistory } from ""vue-router"";
import { routerAfterChecks, routerBeforeChecks } from ""@/router/checks"";
import { routes } from ""./routes"";

export const router = createRouter({
  history: createWebHistory(),
  routes,
});
router.beforeEach(async (to, from) => {
  for (const check of Object.values(routerBeforeChecks)) {
    const redirect = await check(to, from);

    if (!redirect) continue;

    return redirect;
  }
});

router.afterEach(async (to, from) => {
  for (const check of Object.values(routerAfterChecks)) {
    const redirect = await check(to, from);

    if (!redirect) continue;

    return redirect;
  }
});
"
src/router/checks.ts,"import { RouteLocationNormalized, RouteLocationRaw } from ""vue-router"";
import { getVersionApiStore, sessionApiStore } from ""@/hooks/api"";
import { appStore, sessionStore } from ""@/hooks/core"";
import { projectStore } from ""@/hooks/project"";
import { QueryParams, Routes } from ""@/router/routes"";

type RouteChecks = Record<
  string,
  (
    to: RouteLocationNormalized,
    from: RouteLocationNormalized
  ) => Promise<RouteLocationRaw | void>
>;

/**
 * Defines list of functions that are run before navigating to a new page.
 * This serves as the central location for setting any state a page might
 * expect to be in.
 *
 * Note, these checks are prioritized in the order they are defined meaning
 * that once a check has used the `next` function the remaining checks
 * are ignored.
 */
export const routerBeforeChecks: RouteChecks = {
  async resetPublicState(to) {
    const isPublic = to.matched.some(({ meta }) => meta.isPublic);

    if (!isPublic) return;

    sessionApiStore.handleReset();
  },
  async redirectToLoginIfNoSessionFound(to) {
    const isPublic = to.matched.some(({ meta }) => meta.isPublic);

    if (sessionStore.doesSessionExist || isPublic) {
      return;
    }

    try {
      await sessionApiStore.handleAuthentication();

      return;
    } catch (e) {
      return {
        path: Routes.LOGIN_ACCOUNT,
        query: {
          ...to.query,
          [QueryParams.LOGIN_PATH]: to.path,
        },
      };
    }
  },
  async closePanelsIfNotInGraph(to) {
    if (to.path === Routes.ARTIFACT) return;

    appStore.closeSidePanels();
  },
};

export const routerAfterChecks: RouteChecks = {
  async requireProjectForRoutes(to) {
    const requiresProject = to.matched.some(({ meta }) => meta.requiresProject);

    if (projectStore.isProjectDefined || !requiresProject) return;

    const versionId = to.query[QueryParams.VERSION];

    if (typeof versionId !== ""string"") return;

    await getVersionApiStore.handleLoad(versionId, undefined, false);
  },
};
"
src/router/index.ts,"export * from ""./hooks"";
export * from ""./checks"";
export * from ""./routes"";
export * from ""./router"";
"
src/router/hooks.ts,"import { URLParameter, URLQuery } from ""@/types"";
import { QueryParams, Routes } from ""@/router/routes"";
import { router } from ""@/router/router"";

/**
 * Navigates app to given route, if app is already on the route then
 * does nothing. This wrapper stops DuplicateNavigation exceptions.
 *
 * @param route - The route to navigate to.
 * @param query - Any query params to include.
 */
export async function navigateTo(
  route: Routes | string,
  query: URLQuery = {}
): Promise<void> {
  if (
    router.currentRoute.value.path === route &&
    Object.keys(query).length === 0
  ) {
    return;
  } else {
    await router.push({ path: route, query });
  }
}

/**
 * Navigates to the previous page.
 */
export function navigateBack(): void {
  router.back();
}

/**
 * Return the app's query parameters.
 */
export function getParams(): URLQuery {
  return router.currentRoute.value.query;
}

/**
 * Return one of the app's query parameters.
 *
 * @param key - The query param key.
 * @return The query parameter value.
 */
export function getParam(key: QueryParams): URLParameter {
  return router.currentRoute.value.query[key];
}

/**
 * Changes the app's query parameters.
 *
 * @param key - The query param key.
 * @param value - The query param value.
 */
export async function updateParam(key: string, value: string): Promise<void> {
  const currentRoute = router.currentRoute.value;

  if (currentRoute.query[key] === value) return;

  return navigateTo(currentRoute.path, { [key]: value });
}

/**
 * Removes all query parameters.
 */
export async function removeParams(): Promise<void> {
  const currentRoute = router.currentRoute.value;

  if (Object.values(currentRoute.query).length === 0) return;

  return navigateTo(currentRoute.path, {});
}
"
