package edu.nd.crc.safa.features.jobs.entities.jobs;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.stream.Collectors;

import edu.nd.crc.safa.features.commits.entities.app.ProjectCommitDefinition;
import edu.nd.crc.safa.features.common.ServiceProvider;
import edu.nd.crc.safa.features.delta.entities.db.ModificationType;
import edu.nd.crc.safa.features.generation.common.GenerationDataset;
import edu.nd.crc.safa.features.generation.tgen.entities.TGenRequestAppEntity;
import edu.nd.crc.safa.features.generation.tgen.entities.TracingRequest;
import edu.nd.crc.safa.features.generation.tgen.services.TraceGenerationService;
import edu.nd.crc.safa.features.jobs.entities.IJobStep;
import edu.nd.crc.safa.features.jobs.entities.db.JobDbEntity;
import edu.nd.crc.safa.features.jobs.logging.JobLogger;
import edu.nd.crc.safa.features.traces.ITraceGenerationController;
import edu.nd.crc.safa.features.traces.entities.app.TraceAppEntity;
import edu.nd.crc.safa.features.traces.entities.db.ApprovalStatus;
import edu.nd.crc.safa.features.traces.entities.db.TraceType;
import edu.nd.crc.safa.features.users.entities.db.SafaUser;
import edu.nd.crc.safa.features.versions.entities.ProjectVersion;

/**
 * Generates trace links between artifacts defined in request.
 */
public class GenerateLinksJob extends GenerationJob {
    /**
     * The request to generate trace links.
     */
    private final TGenRequestAppEntity TGenRequestAppEntity;
    /**
     * The project version to commit summaries and generated links to.
     */
    private final ProjectVersion projectVersion;
    /**
     * The traces generated by this job.
     */
    private List<TraceAppEntity> generatedTraces;

    public GenerateLinksJob(SafaUser user,
                            JobDbEntity jobDbEntity,
                            ServiceProvider serviceProvider,
                            ProjectCommitDefinition projectCommitDefinition,
                            TGenRequestAppEntity TGenRequestAppEntity) {
        super(user, jobDbEntity, serviceProvider, projectCommitDefinition);
        this.TGenRequestAppEntity = TGenRequestAppEntity;
        this.generatedTraces = new ArrayList<>();
        this.projectVersion = projectCommitDefinition.getCommitVersion();
    }

    /**
     * Returns the name of the job.
     *
     * @param TGenRequestAppEntity The trace generation request being performed by job.
     * @return Job Name.
     */
    public static String getJobName(TGenRequestAppEntity TGenRequestAppEntity) {
        int nArtifactLevels = TGenRequestAppEntity
            .getRequests()
            .stream()
            .mapToInt(r -> r.getArtifactLevels().size()).sum();
        return String.format("Generating links between %s artifact levels.", nArtifactLevels);
    }

    @IJobStep(value = "Generating links", position = 3)
    public void generateLinks(JobLogger logger) {
        ProjectCommitDefinition projectCommitDefinition = getProjectCommitDefinition();

        for (TracingRequest tracingRequest : TGenRequestAppEntity.getRequests()) {
            logger.log("Running tracing request:Levels: %s", tracingRequest.getArtifactLevels());

            GenerationDataset generationDataset = TraceGenerationService.extractPayload(tracingRequest,
                getProjectAppEntity());
            generationDataset.setSummary(this.projectVersion.getProject().getSpecification());

            ITraceGenerationController controller = this.getServiceProvider().getTraceGenerationController();
            this.generatedTraces = controller.generateLinks(generationDataset, this.getDbLogger());

            logger.log("Generated %d traces.", generatedTraces.size());

            // Step - Filter our trace links overriding manual or approved links
            HashMap<String, List<String>> traceHashMap = new HashMap<>();

            fillWithExistingLinks(traceHashMap);

            List<TraceAppEntity> filteredGeneratedLinks = this.generatedTraces
                .stream()
                .filter(t -> !traceHashMap.containsKey(t.getSourceName())
                    || !traceHashMap.get(t.getSourceName()).contains(t.getTargetName())).collect(Collectors.toList());

            logger.log("Filtered down to %d traces that will be committed.", filteredGeneratedLinks.size());

            projectCommitDefinition.addTraces(ModificationType.ADDED, filteredGeneratedLinks);
            logger.log("\n================\n");
        }

        logger.log("Total links generated: %d", projectCommitDefinition.getTraces().getSize());
    }

    private void fillWithExistingLinks(HashMap<String, List<String>> traceHashMap) {
        this.getServiceProvider()
            .getTraceService()
            .getAppEntities(projectVersion, getUser(), t -> t.getApprovalStatus() == ApprovalStatus.APPROVED
                || t.getTraceType() == TraceType.MANUAL)
            .forEach(t -> {
                if (traceHashMap.containsKey(t.getSourceName())) {
                    traceHashMap.get(t.getSourceName()).add(t.getTargetName());
                } else {
                    ArrayList<String> targets = new ArrayList<>();
                    targets.add(t.getTargetName());
                    traceHashMap.put(t.getSourceName(), targets);
                }
            });
    }
}
