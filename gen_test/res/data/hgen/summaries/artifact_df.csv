id,id,content,layer_id,summary
/Debug/DebugOptions.cpp,/Debug/DebugOptions.cpp,"This code defines some default boolean values for debug options. The options control things like rendering entity hitboxes, rendering a player hitbox, showing an FPS counter, and showing general debug information. These options are likely used to toggle debug visualization features for the system.",C++ Code,"Summary of This code defines some default boolean values for debug options. The options control things like rendering entity hitboxes, rendering a player hitbox, showing an FPS counter, and showing general debug information. These options are likely used to toggle debug visualization features for the system."
/Debug/Graphics/FPSCounter.cpp,/Debug/Graphics/FPSCounter.cpp,"This code implements an FPSCounter class that displays the current frames per second (FPS) of the application.

The constructor initializes an sf::Text object that will display the FPS and sets an initial refresh rate for how often the FPS should be updated.

The update() method is called every frame. It increments the frame count, checks if the specified time has elapsed since the last FPS update, and if so, calculates the FPS based on the frame count and time elapsed. It then displays the FPS by setting the sf::Text string.

The render() method draws the sf::Text to the screen, but only if the DebugOptions flag to show the FPS counter is enabled.

The getRefreshRate() and setRefreshRate() methods allow getting and setting how often the FPS should be updated.",C++ Code,Summary of This code implements an FPSCounter class that displays the current frames per second (FPS) of the application.
/Exception/Exception.cpp,/Exception/Exception.cpp,"This code defines an Exception class that is used to represent exceptions thrown within the system. When an exception is thrown, information about the exception such as the reason and stack trace are captured and stored. The what() method returns a human readable string representation of the exception, including the reason and stack trace.",C++ Code,"Summary of This code defines an Exception class that is used to represent exceptions thrown within the system. When an exception is thrown, information about the exception such as the reason and stack trace are captured and stored. The what() method returns a human readable string representation of the exception, including the reason and stack trace."
/Exception/Exception_Linux.cpp,/Exception/Exception_Linux.cpp,"This code provides functionality for printing stack traces when exceptions are thrown.

When C++ code is compiled, function names are ""mangled"" to make them valid symbols. This code uses the abi::__cxa_demangle function to ""demangle"" the mangled function names into a more readable format.

The saveStackTrace() function uses the backtrace function to save the current stack trace, including function calls up to the current point. 

The printStackTrace() function then demangles the function names in the stack trace and prints a formatted stack trace with function names and source code line numbers (using addr2line).",C++ Code,Summary of This code provides functionality for printing stack traces when exceptions are thrown.
/Exception/Exception_Windows.cpp,/Exception/Exception_Windows.cpp,"This code provides functionality for printing stack traces when exceptions occur on Windows. When an exception is thrown, the saveStackTrace method is called to capture the stack trace. Then the printStackTrace method can be used to print the stack trace to a string stream, including function names and line numbers where possible. This allows the exception information to be logged.",C++ Code,"Summary of This code provides functionality for printing stack traces when exceptions occur on Windows. When an exception is thrown, the saveStackTrace method is called to capture the stack trace. Then the printStackTrace method can be used to print the stack trace to a string stream, including function names and line numbers where possible. This allows the exception information to be logged."
/Game.cpp,/Game.cpp,"This code represents the core game loop for a 2D game. It initializes the render engine and screen, starts the main loop, and handles some basic events.

The main loop polls for events, handles any that it can, then forwards the rest to the screen. It then ticks the screen, begins rendering, calls the screen to render itself, and ends rendering.

The events it handles are:
- Window closed - Ends the main loop
- Window resized - Notifies the render engine 
- F3 pressed - Marks debug options as available",C++ Code,"Summary of This code represents the core game loop for a 2D game. It initializes the render engine and screen, starts the main loop, and handles some basic events."
/Graphics/Components/Button.cpp,/Graphics/Components/Button.cpp,"This code implements a button component. When the mouse hovers over the button, the background color changes. When the mouse clicks the button, a function is called. The button is laid out by centering its rectangle and text within the bounds of the component.",C++ Code,"Summary of This code implements a button component. When the mouse hovers over the button, the background color changes. When the mouse clicks the button, a function is called. The button is laid out by centering its rectangle and text within the bounds of the component."
/Graphics/Components/Component.cpp,/Graphics/Components/Component.cpp,"This code defines a Component class that represents UI components in a graphical user interface. The high-level usage is:

- Components have a position, size, and bounding box 
- Components can contain child components 
- Components can render themselves to a RenderWindow 
- Components can handle input events like mouse/keyboard and delegate them to children
- Components can layout their children when the window resizes",C++ Code,Summary of This code defines a Component class that represents UI components in a graphical user interface. The high-level usage is:
/Graphics/Components/HBox.cpp,/Graphics/Components/HBox.cpp,"This code implements an HBox component that lays out its child components horizontally. When layout() is called, it calculates the total width of all child components and sets its own size to that width and the maximum height of the child components. It then positions each child component by setting its left position to the current X position and centering it vertically.",C++ Code,"Summary of This code implements an HBox component that lays out its child components horizontally. When layout() is called, it calculates the total width of all child components and sets its own size to that width and the maximum height of the child components. It then positions each child component by setting its left position to the current X position and centering it vertically."
/Graphics/Components/Rectangle.cpp,/Graphics/Components/Rectangle.cpp,"This code defines a Rectangle component that can be rendered and laid out on a render window. It allows setting properties like fill color, outline color, and thickness and getting those property values. The renderComponent() method draws the rectangle on the given render window, while the layout() method positions and sizes the rectangle based on its global position and size.",C++ Code,"Summary of This code defines a Rectangle component that can be rendered and laid out on a render window. It allows setting properties like fill color, outline color, and thickness and getting those property values. The renderComponent() method draws the rectangle on the given render window, while the layout() method positions and sizes the rectangle based on its global position and size."
/Graphics/Components/Text.cpp,/Graphics/Components/Text.cpp,"This code defines a Text class that represents text that can be rendered and positioned on the screen. The class allows setting properties of the text like the string, font size, color, and position. It also provides methods to render the text to a render window, layout the text to fit its contents, and get metrics like the width and height of the text.",C++ Code,"Summary of This code defines a Text class that represents text that can be rendered and positioned on the screen. The class allows setting properties of the text like the string, font size, color, and position. It also provides methods to render the text to a render window, layout the text to fit its contents, and get metrics like the width and height of the text."
/Graphics/Components/VBox.cpp,/Graphics/Components/VBox.cpp,"This code implements a vertical box layout component. It accepts a list of child components and lays them out vertically. When the layout() method is called, it calculates the maximum width of all child components and the total height by summing the heights of all children. It then sets its own size to that maximum width and total height. It positions each child component by centering it horizontally and placing it below the previous child, incrementing the Y position.",C++ Code,"Summary of This code implements a vertical box layout component. It accepts a list of child components and lays them out vertically. When the layout() method is called, it calculates the maximum width of all child components and the total height by summing the heights of all children. It then sets its own size to that maximum width and total height. It positions each child component by centering it horizontally and placing it below the previous child, incrementing the Y position."
/Graphics/Menu/ColorSelectorMenu.cpp,/Graphics/Menu/ColorSelectorMenu.cpp,"This code implements a color selector menu GUI. It contains sliders to adjust the red, green, and blue color channels, a preview rectangle showing the selected color, and text labels for the sliders. The constructor initializes the GUI elements and adds them to the menu. The layout() method positions the elements based on the window size, placing the preview rectangle after the last slider, centering the text labels under the sliders, and centering the title text at the top.",C++ Code,"Summary of This code implements a color selector menu GUI. It contains sliders to adjust the red, green, and blue color channels, a preview rectangle showing the selected color, and text labels for the sliders. The constructor initializes the GUI elements and adds them to the menu. The layout() method positions the elements based on the window size, placing the preview rectangle after the last slider, centering the text labels under the sliders, and centering the title text at the top."
/Graphics/Menu/EscapeMenu.cpp,/Graphics/Menu/EscapeMenu.cpp,"This code defines an EscapeMenu class that displays an in-game menu with buttons to Quit, Resume, and open a Settings menu. When initialized, it is given the width and height of the screen and a reference to the Game and Screen objects. It lays out the buttons in the center of the screen and handles button callbacks by either quitting the game, resuming, or opening the settings menu. It also handles mouse clicks and screen resize events.",C++ Code,"Summary of This code defines an EscapeMenu class that displays an in-game menu with buttons to Quit, Resume, and open a Settings menu. When initialized, it is given the width and height of the screen and a reference to the Game and Screen objects. It lays out the buttons in the center of the screen and handles button callbacks by either quitting the game, resuming, or opening the settings menu. It also handles mouse clicks and screen resize events."
/Graphics/Menu/Menu.cpp,/Graphics/Menu/Menu.cpp,"This code defines a Menu class that provides functionality for rendering and positioning a basic menu UI component. The Menu class provides:

- A constructor that initializes a semi-transparent black box background of a given size 
- A center() method that positions the menu in the center of a given window
- A renderComponent() method that renders the background box and calls a child class's rendering function
- A layout() method that calls center() and positions child components
- Event handling methods for mouse button presses that check if the event occurred within the menu bounds",C++ Code,Summary of This code defines a Menu class that provides functionality for rendering and positioning a basic menu UI component. The Menu class provides:
/Graphics/Menu/SettingsMenu.cpp,/Graphics/Menu/SettingsMenu.cpp,"This code defines a SettingsMenu class that allows the user to configure light position settings. It contains sliders and text boxes to set the X, Y and Z position values of a light source. When the sliders are adjusted, the corresponding light position value will be updated.",C++ Code,"Summary of This code defines a SettingsMenu class that allows the user to configure light position settings. It contains sliders and text boxes to set the X, Y and Z position values of a light source. When the sliders are adjusted, the corresponding light position value will be updated."
/Graphics/Screen/WorldScreen.cpp,/Graphics/Screen/WorldScreen.cpp,"This code handles the rendering and logic for a 3D world screen. It handles:

- Constructing the screen with a window and game reference
- Handling events like mouse clicks, key presses, and resizing
- Placing/removing blocks when the mouse is clicked 
- Moving the player and handling rotation based on input
- Copying the selected block's color
- Updating FPS and ticking the player
- Rendering the player, world, FPS counter, and any active menus",C++ Code,Summary of This code handles the rendering and logic for a 3D world screen. It handles:
/Player.cpp,/Player.cpp,"This code defines a Player class that represents a player in a 3D game world. It contains functionality for:

- Getting and setting the player's position, rotation, and velocity
- Moving the player by applying their velocity, while preventing collisions with blocks
- Rendering the player's hitbox and selection box (the block they are looking at)
- Performing raycasting to determine which block the player is looking at",C++ Code,Summary of This code defines a Player class that represents a player in a 3D game world. It contains functionality for:
/Rendering/AABBRenderer.cpp,/Rendering/AABBRenderer.cpp,"This code renders axis-aligned bounding boxes (AABBs) in 3D space. It uses a buffer-based rendering approach where vertices are first generated and stored in a buffer, then drawn all at once.

The main renderAABB() method generates vertices for the 12 edges of the AABB by calling pushBlockVertices(). This method calculates the 8 corner points of the AABB and generates vertices for each edge.

The vertices are stored in a vertex buffer and drawn using OpenGL. A no-lighting shader is used to simply render the wireframe box with a uniform color.",C++ Code,"Summary of This code renders axis-aligned bounding boxes (AABBs) in 3D space. It uses a buffer-based rendering approach where vertices are first generated and stored in a buffer, then drawn all at once."
/Rendering/BlockSelection.cpp,/Rendering/BlockSelection.cpp,"This code implements a block selection feature. When a block face is selected, it renders a white axis-aligned bounding box around that block face using the AABBRenderer. When no block face is selected, nothing is rendered.",C++ Code,"Summary of This code implements a block selection feature. When a block face is selected, it renders a white axis-aligned bounding box around that block face using the AABBRenderer. When no block face is selected, nothing is rendered."
/Rendering/Image.cpp,/Rendering/Image.cpp,This code defines an Image class that represents an image loaded from disk. It uses the STB image library to load the image data and handles memory management of the loaded image data. The Image class supports move semantics to efficiently transfer ownership of the image data.,C++ Code,Summary of This code defines an Image class that represents an image loaded from disk. It uses the STB image library to load the image data and handles memory management of the loaded image data. The Image class supports move semantics to efficiently transfer ownership of the image data.
/Rendering/RenderEngine.cpp,/Rendering/RenderEngine.cpp,"This code provides a rendering engine that handles:
- Creating an OpenGL window
- Setting up OpenGL states like enabling depth testing, face culling, etc. 
- Compiling and binding OpenGL shaders
- Setting the perspective projection matrix based on the window size
- Handling window resize events
- Translating the camera view based on a player's position and rotation",C++ Code,Summary of This code provides a rendering engine that handles:
/Rendering/Renderable.cpp,/Rendering/Renderable.cpp,This code defines classes and functions for rendering 3D objects. It initializes vertex buffer objects and texture atlases for rendering. The Renderable class represents a renderable 3D object that can be initialized with vertex data and textures.,C++ Code,Summary of This code defines classes and functions for rendering 3D objects. It initializes vertex buffer objects and texture atlases for rendering. The Renderable class represents a renderable 3D object that can be initialized with vertex data and textures.
/Rendering/Shader.cpp,/Rendering/Shader.cpp,"This code represents a Shader class that is used to compile and manage OpenGL shader programs. The high-level usage is:

1. Create a Shader object specifying the shader type (vertex, fragment, etc.) and file name
2. Call the compile() method to compile the shader code from the file into an OpenGL shader object
3. The Shader destructor will automatically delete the OpenGL shader object when the Shader object is destroyed",C++ Code,Summary of This code represents a Shader class that is used to compile and manage OpenGL shader programs. The high-level usage is:
/Rendering/ShaderProgram.cpp,/Rendering/ShaderProgram.cpp,"This code defines a ShaderProgram class that represents a compiled OpenGL shader program. It loads vertex and fragment shaders from files, compiles them, links them into a program, and provides methods to bind and unbind that program. It also caches uniform locations to avoid querying them repeatedly.",C++ Code,"Summary of This code defines a ShaderProgram class that represents a compiled OpenGL shader program. It loads vertex and fragment shaders from files, compiles them, links them into a program, and provides methods to bind and unbind that program. It also caches uniform locations to avoid querying them repeatedly."
/Rendering/stb_image.cpp,/Rendering/stb_image.cpp,"This code includes the stb_image library, which allows you to load images from files and decode them into textures. The stb_image library provides a simple API to load an image file from disk, decode the image data into a raw pixel format, and optionally apply linear colorspace conversion and/or resize the image. This allows you to easily integrate image loading into your rendering system.",C++ Code,"Summary of This code includes the stb_image library, which allows you to load images from files and decode them into textures. The stb_image library provides a simple API to load an image file from disk, decode the image data into a raw pixel format, and optionally apply linear colorspace conversion and/or resize the image. This allows you to easily integrate image loading into your rendering system."
/Utils/AABB.cpp,/Utils/AABB.cpp,"This code defines an AABB (Axis Aligned Bounding Box) class which represents a 3D box. It allows initializing the box with a position and size, getting/setting the position and size, checking if the box collides with another box, and more.",C++ Code,"Summary of This code defines an AABB (Axis Aligned Bounding Box) class which represents a 3D box. It allows initializing the box with a position and size, getting/setting the position and size, checking if the box collides with another box, and more."
/Utils/Font.cpp,/Utils/Font.cpp,This code defines a Font class that represents a font and provides methods for rendering text using that font. The defaultFont static member represents a default font that can be used when no other font is specified. This allows text to be rendered using a default font without having to explicitly create a Font object.,C++ Code,Summary of This code defines a Font class that represents a font and provides methods for rendering text using that font. The defaultFont static member represents a default font that can be used when no other font is specified. This allows text to be rendered using a default font without having to explicitly create a Font object.
/Utils/ICollidable.cpp,/Utils/ICollidable.cpp,This code defines an interface for objects that can collide with each other. The ICollidable interface has a checkCollision method that checks if two ICollidable objects are colliding. The implementation of checkCollision checks the collision of the bounding boxes of the two objects.,C++ Code,Summary of This code defines an interface for objects that can collide with each other. The ICollidable interface has a checkCollision method that checks if two ICollidable objects are colliding. The implementation of checkCollision checks the collision of the bounding boxes of the two objects.
/World/Block.cpp,/World/Block.cpp,"This code defines a Block class representing a 3D cube in a 3D world. The Block has a position, color, and type (either solid or air). The usage is:

- Construct a Block with a position, color, and type
- Get/set the position, color, and type 
- Get the bounding box of the block, which returns an AABB (axis-aligned bounding box) of size (0,0,0) for air blocks and (1,1,1) for solid blocks.",C++ Code,"Summary of This code defines a Block class representing a 3D cube in a 3D world. The Block has a position, color, and type (either solid or air). The usage is:"
/World/BlockFace.cpp,/World/BlockFace.cpp,"This code defines a BlockFace class which represents a face on a 3D block. It stores information about the face such as its position, normal vector, and color. The constructors allow initializing a BlockFace from either a normal vector or a BlockFace::Face enum. Getters and setters are provided to access and modify the face's properties.",C++ Code,"Summary of This code defines a BlockFace class which represents a face on a 3D block. It stores information about the face such as its position, normal vector, and color. The constructors allow initializing a BlockFace from either a normal vector or a BlockFace::Face enum. Getters and setters are provided to access and modify the face's properties."
/World/Chunk.cpp,/World/Chunk.cpp,"This code represents a chunk of blocks in a 3D voxel world. The high-level usage is:

- Chunks are initialized with a position and reference to the World they belong to
- When the chunk needs to be rendered, it rebuilds its vertex array by iterating through each block and generating faces where solid blocks meet air blocks
- The vertex array is then sent to OpenGL for rendering
- Methods are provided to convert between local chunk coordinates and global world coordinates
- Blocks can be accessed and modified using getters/setters
- notifyChanged() can be called when a block changes to mark the chunk as needing an updated vertex array",C++ Code,Summary of This code represents a chunk of blocks in a 3D voxel world. The high-level usage is:
/World/World.cpp,/World/World.cpp,"This code represents a 3D voxel world composed of chunks. It provides functions to:

- Create the initial world chunks
- Render the world chunks 
- Get information about blocks within the world like position, type and color
- Set information about blocks like type and color
- Check for collisions with blocks
- Get the minimum and maximum positions within the world",C++ Code,Summary of This code represents a 3D voxel world composed of chunks. It provides functions to:
/main.cpp,/main.cpp,"This code provides high-level functionality for running a game. It initializes a logger, registers a signal handler for segmentation faults, runs the game, and handles any uncaught exceptions by logging details and exiting.",C++ Code,"Summary of This code provides high-level functionality for running a game. It initializes a logger, registers a signal handler for segmentation faults, runs the game, and handles any uncaught exceptions by logging details and exiting."
Generate Voxel Cubic Chunk World ET,Generate Voxel Cubic Chunk World ET,Generate Procedural 3D Voxel World Composed of Cubic Chunks Containing Block Data,Epic Title,
Render 3D Block World ET,Render 3D Block World ET,Render World and Blocks Using Vertex Arrays and Textures with Custom Shaders,Epic Title,
First Person Player Movement ET,First Person Player Movement ET,Implement First-Person Controls for Player Movement and Interaction,Epic Title,
Modular Interface Development ET,Modular Interface Development ET,"Develop Modular UI System for Menus, Settings, and In-Game Overlays",Epic Title,
Texture Loading Utilities ET,Texture Loading Utilities ET,"Provide Utilities for Texture Loading, Text Rendering, and Debugging",Epic Title,
Detect Block Collisions ET,Detect Block Collisions ET,Implement Collision Detection Between Player and World Blocks,Epic Title,
Improve Rendering Large Procedural Worlds ET,Improve Rendering Large Procedural Worlds ET,Optimize Rendering and Memory Usage for Large Procedural Worlds,Epic Title,
